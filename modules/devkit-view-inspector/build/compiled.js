;(function(jsio){jsio.path.set(["../node_modules/jsio/packages"]);jsio.path.cache={"jsio":"../node_modules/jsio/packages","squill":"../node_modules/squill","src":"./","util":"../node_modules/jsio/packages/util","math":"../node_modules/jsio/packages/math","lib":"../node_modules/jsio/packages/lib","std":"../node_modules/jsio/packages/std"};jsio.setCachedSrc('../node_modules/jsio/packages/base.js',"/**\n * base.js\n * This file contains all global functions provided by js.io.\n */\n\nexports.log = jsio.__env.log;\nexports.GLOBAL = jsio.__env.global;\n\n/**\n * Various polyfill methods to ensure js.io implementations provide\n * a baseline of JavaScript functionality. Feature compatibility (localStorage,\n * etc.) should be provided elsewhere.\n */\n\n// Array.isArray\n// Not available before ECMAScript 5.\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray\n\nif (!Array.isArray) {\n\tArray.isArray = function (arg) {\n\t\treturn Object.prototype.toString.call(arg) === '[object Array]';\n\t}\n};\n\n// Function.prototype.bind\n// Not available before ECMAScript 5.\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind\n\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function (oThis) {\n    if (typeof this !== \"function\") {\n      // closest thing possible to the ECMAScript 5 internal IsCallable function\n      throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\n    }\n\n    var aArgs = Array.prototype.slice.call(arguments, 1),\n        fToBind = this,\n        fNOP = function () {},\n        fBound = function () {\n          return fToBind.apply(this instanceof fNOP\n                                 ? this\n                                 : oThis,\n                               aArgs.concat(Array.prototype.slice.call(arguments)));\n        };\n\n    fNOP.prototype = this.prototype;\n    fBound.prototype = new fNOP();\n\n    return fBound;\n  };\n}\n\n/**\n * DEPRECATED. Old js.io polyfills.\n */\n\nvar SLICE = Array.prototype.slice;\n\n/* Use native isArray if available\n */\nif (typeof Array.isArray === 'function') {\n\texports.isArray = Array.isArray;\n} else {\n\texports.isArray = function (obj) {\n\t\treturn Object.prototype.toString.call(obj) === '[object Array]';\n\t}\n}\n\nexports.bind = function(context, method /*, VARGS*/) {\n\tif(arguments.length > 2) {\n\t\tvar args = SLICE.call(arguments, 2);\n\t\treturn typeof method == 'string'\n\t\t\t? function __bound() {\n\t\t\t\tif (context[method]) {\n\t\t\t\t\treturn context[method].apply(context, args.concat(SLICE.call(arguments, 0)));\n\t\t\t\t} else {\n\t\t\t\t\tthrow logger.error('No method:', method, 'for context', context);\n\t\t\t\t}\n\t\t\t}\n\t\t\t: function __bound() { return method.apply(context, args.concat(SLICE.call(arguments, 0))); }\n\t} else {\n\t\treturn typeof method == 'string'\n\t\t\t? function __bound() {\n\t\t\t\tif (context[method]) {\n\t\t\t\t\treturn context[method].apply(context, arguments);\n\t\t\t\t} else {\n\t\t\t\t\tthrow logger.error('No method:', method, 'for context', context);\n\t\t\t\t}\n\t\t\t}\n\t\t\t: function __bound() { return method.apply(context, arguments); }\n\t}\n}\n\n/**\n * Class constructor.\n */\n\nexports.Class = function(name, parent, proto) {\n\treturn exports.__class__(function() { return this.init && this.init.apply(this, arguments); }, name, parent, proto);\n}\n\nexports.__class__ = function (cls, name, parent, proto) {\n\tvar clsProto = function () {};\n\tvar logger;\n\n\tif (typeof name != 'string') {\n\t\tproto = parent;\n\t\tparent = name;\n\t\tname = null;\n\t}\n\n\tif (name) {\n\t\tlogger = exports.logging.get(name);\n\t}\n\n\tif (!parent) { throw new Error('parent or prototype not provided'); }\n\tif (!proto) { proto = parent; parent = null; }\n\n\tif (parent) {\n\t\tif (exports.isArray(parent)) { // multiple inheritance, use at your own risk =)\n\t\t\tclsProto.prototype = {};\n\t\t\tfor(var i = 0, p; p = parent[i]; ++i) {\n\t\t\t\tif (p == Error && ErrorParentClass) { p = ErrorParentClass; }\n\t\t\t\tfor (var item in p.prototype) {\n\t\t\t\t\tif (!(item in clsProto.prototype)) {\n\t\t\t\t\t\tclsProto.prototype[item] = p.prototype[item];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tparent = parent[0];\n\t\t} else {\n\t\t\tif (parent == Error && ErrorParentClass) { parent = ErrorParentClass; }\n\t\t\tclsProto.prototype = parent.prototype;\n\t\t}\n\t}\n\n\tvar supr = parent ? function(context, method, args) {\n\t\t\tvar f = parent.prototype[method];\n\t\t\tif (!f) { throw new Error('method ' + method + ' does not exist'); }\n\t\t\treturn f.apply(context, args || []);\n\t\t} : null;\n\n\tvar p = cls.prototype = new clsProto();\n\tp.constructor = cls;\n\tp.__parentClass__ = parent;\n\tif (name) { p.__class__ = name; }\n\tproto.call(p, logger || supr, logger && supr);\n\treturn cls;\n}\n\nvar ErrorParentClass = exports.__class__(function ErrorCls() {\n\t\tvar err = Error.prototype.constructor.apply(this, arguments);\n\t\tfor (var prop in err) {\n\t\t\tif (err.hasOwnProperty(prop)) {\n\t\t\t\tthis[prop] = err[prop];\n\t\t\t}\n\t\t}\n\t}, function() {});\n\n/**\n * Merge two objects together.\n */\n\nexports.Class.defaults =\nexports.merge = function(base, extra) {\n\tbase = base || {};\n\n\tfor (var i = 1, len = arguments.length; i < len; ++i) {\n\t\tvar copyFrom = arguments[i];\n\t\tfor (var key in copyFrom) {\n\t\t\tif (copyFrom.hasOwnProperty(key) && !base.hasOwnProperty(key)) {\n\t\t\t\tbase[key] = copyFrom[key];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn base;\n}\n\n/**\n * Create a timer delay.\n */\n\nexports.delay = function(orig, timeout) {\n\tvar _timer = null;\n\tvar ctx, args;\n\tvar f = function() { orig.apply(ctx, args); }\n\treturn function() {\n\t\tctx = this;\n\t\targs = arguments;\n\t\tif (_timer) { clearTimeout(_timer); }\n\t\t_timer = setTimeout(f, timeout || 0);\n\t}\n}\n\n/**\n * Log constructor and default \"logger\".\n */\n\nexports.logging = (function() {\n\n\t// logging namespace, this is what is exported\n\tvar logging = {\n\t\t\tDEBUG: 1,\n\t\t\tLOG: 2,\n\t\t\tINFO: 3,\n\t\t\tWARN: 4,\n\t\t\tERROR: 5,\n\t\t\tNONE: 10\n\t\t};\n\n\tvar _loggers = {}; // all loggers\n\tvar _production = false;\n\tvar _prefix = '';\n\n\tlogging.setPrefix = function(prefix) { _prefix = prefix + ' '; }\n\n\tlogging.setProduction = function(prod) {\n\t\t_production = !!prod;\n\t\tfor (var key in _loggers) {\n\t\t\t_loggers[key].setProduction(_production);\n\t\t}\n\t}\n\n\tlogging.get = function(name) {\n\t\tvar logger = name in _loggers ? _loggers[name] :\n\t\t\t(_loggers[name] = new Logger(name));\n\t\tlogger.setProduction(_production);\n\t\treturn logger;\n\t}\n\n\tlogging.set = function(name, logger) {\n\t\t_loggers[name] = logger;\n\t}\n\n\tlogging.getAll = function() { return _loggers; }\n\n\tlogging.__create = function(pkg, ctx) { ctx.logger = logging.get(pkg); }\n\n\tvar Logger = exports.__class__(\n\t\tfunction Logger(name, level) {\n\t\t\tthis._name = name;\n\t\t\tthis._isProduction = _production;\n\n\t\t\tthis.setLevel(level || logging.LOG);\n\t\t},\n\t\tfunction () {\n\t\t\tthis.setProduction = function (isProduction) {\n\t\t\t\tthis._isProduction = isProduction;\n\t\t\t\tisProduction && this.setLevel(logging.NONE);\n\t\t\t}\n\n\t\t\tthis.setLevel = function(level) {\n\t\t\t\tthis._level = level;\n\n\t\t\t\tif (this._isProduction) {\n\t\t\t\t\tlevel = logging.NONE;\n\t\t\t\t}\n\n\t\t\t\tthis.DEBUG = level <= logging.DEBUG;\n\t\t\t\tthis.LOG   = level <= logging.LOG;\n\t\t\t\tthis.INFO  = level <= logging.INFO;\n\t\t\t\tthis.WARN  = level <= logging.WARN;\n\t\t\t\tthis.ERROR = level <= logging.ERROR;\n\t\t\t}\n\n\t\t\tfunction makeLogger(type) {\n\t\t\t\tvar level = logging[type];\n\t\t\t\treturn function() {\n\t\t\t\t\tif (!this._isProduction && level >= this._level) {\n\t\t\t\t\t\tvar prefix = type + ' ' + _prefix + this._name;\n\t\t\t\t\t\tvar listener = this._listener || exports.log;\n\n\t\t\t\t\t\treturn listener && listener.apply(this._listener, [prefix].concat(SLICE.call(arguments)));\n\t\t\t\t\t}\n\t\t\t\t\treturn arguments[0];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.setListener = function(listener) { this._listener = listener; }\n\n\t\t\tthis.debug = makeLogger(\"DEBUG\");\n\t\t\tthis.log = makeLogger(\"LOG\");\n\t\t\tthis.info = makeLogger(\"INFO\");\n\t\t\tthis.warn = makeLogger(\"WARN\");\n\t\t\tthis.error = makeLogger(\"ERROR\");\n\t\t});\n\n\treturn logging;\n})();\n\nvar logger = exports.logging.get('jsiocore');\n\n");
jsio.setCachedSrc('devkit-view-inspector/debugger/index.js',"/* globals Class, bind, logger */\n\njsio('from util.browser import $');\njsio('import util.path');\njsio('import squill.Widget as Widget');\n\njsio('import .DetailsWidget');\njsio('import .ViewNode');\njsio('import .BatchGetView');\njsio('import squill.Button as Button');\n\nif (!devkit) {\n  console.error('no devkit api available?');\n} else {\n  var module = devkit.getSimulator().getModules()['devkit-view-inspector'];\n  var directory = util.path.splitPath(module.path).directory;\n  var link = document.createElement('link');\n  link.rel = 'stylesheet';\n  link.href = util.path.join(directory, 'inspector.css');\n  document.querySelector('head').appendChild(link);\n}\n\nvar ViewInspector = Class(Widget, function(supr) {\n  this._def = {\n    id: 'devkit-view-inspector',\n    style: {\n      width: '650px',\n      display: 'none'\n    },\n    children: [\n      {id: '_tree', children: [\n        // {id: '_moveBtn', tag: 'button', text: 'move'},\n        // {id: '_clearViewBtn', tag: 'button', text: 'clear'}\n      ]},\n      {id: '_details', type: DetailsWidget}\n    ]\n  };\n\n  this.init = function () {\n    this._highlight = {timer: 0};\n    this._t = 0;\n    this._highlighted = {};\n\n    this._trace = {\n      list: [],\n      hash: {}\n    };\n\n    // keep a dictionary of all tree nodes for fast highlighting based on view uid\n    this._nodeIndex = {};\n\n    var simulator = devkit.getSimulator();\n    var node = simulator.getParent();\n    var contentArea = node && node.parentNode || document.body;\n\n    this._deepTrace = document.createElement(\"div\");\n    this._deepTrace.setAttribute(\"id\", \"_deepTrace\");\n    contentArea.appendChild(this._deepTrace);\n\n    supr(this, 'init', [{parent: contentArea}]);\n\n    this._details.setInspector(this);\n\n    $.onEvent(this._tree, 'mouseover', this, function () {\n      this._disableHighlight = false;\n    });\n\n    this.setSimulator(simulator);\n    var getViews = this._channel.request.bind(this._channel, 'getViews');\n    this._batchGetView = new BatchGetView(getViews);\n\n    new Button({\n      id: 'devkit-view-inspector-toggle-button',\n      parent: contentArea,\n      children: [{\n        tagName: 'span',\n        className: 'glyphicon glyphicon-search'\n      }]\n    }).on('Select', bind(this, 'toggleVisibility'));\n  };\n\n  this.setSimulator = function (simulator) {\n    this._simulator = simulator;\n\n    this._channel = simulator\n      .getChannel('devkit.debugging.viewInspector')\n\n      .on('inputMove', bind(this, 'onInputMove'))\n      .on('inputSelect', bind(this, 'onInputSelect'))\n      .on('inputTrace', bind(this, 'onInputTrace'))\n      .on('viewPollData', bind(this, function (data) {\n        if(data.uid === this._highlightUID) {\n          this._highlightPos = data;\n        }\n\n        if(data.uid === this._selectedUID) {\n          this._selectedPos = data;\n        }\n      }));\n  };\n\n  this.getViewProps = function (uid) {\n    return this._channel.request('getViewProps', uid);\n  };\n\n  this.setViewProp = function (uid, key, value) {\n    return this._channel.request('setViewProp', {\n        uid: uid,\n        key: key,\n        value: value\n      });\n  };\n\n  this.setImage = function (uid, image) {\n    return this._channel.request('replaceImage', {\n        uid: uid,\n        image: image\n      });\n  };\n\n  this.startDebugging = function () {\n    if (!this._simulator) { return; }\n\n    if (this._unbindMouseout) {\n      this._unbindMouseout();\n      this._unbindMouseout = null;\n    }\n\n    var mouseOut = bind(this, 'onMouseOut');\n    var mouseOver = bind(this, 'onMouseOver');\n\n    var frame = this._simulator.getFrame();\n    if (frame) {\n      this._unbindMouseout = bind(frame, 'removeEventListener', 'mouseout', mouseOut, true);\n      frame.addEventListener('mouseout', mouseOut, true);\n      frame.addEventListener('mouseover', mouseOver, true);\n    }\n\n    this._connectMouseEvents();\n\n    if (this._node) {\n      this._node.destroy();\n    }\n\n    this._channel\n      .request('getRootUID')\n      .bind(this)\n      .then(function (uid) {\n        this._node = new ViewNode({\n            parent: this._tree,\n            inspector: this,\n            viewUID: uid,\n            id: 'rootNode'\n          });\n      }, function (e) {\n        logger.warn(e);\n      });\n  };\n\n  this.requestView = function (uid) {\n    return this._batchGetView.request(uid);\n  };\n\n  this.startTimer = function() {\n    if (!this._timer) {\n      this._timer = setInterval(bind(this, 'tick'), 20);\n    }\n  };\n\n  this.stopTimer = function() {\n    if (this._timer) {\n      clearInterval(this._timer);\n      this._timer = null;\n    }\n  };\n\n  this.onInputMove = function (evt) {\n    if (!this._timer) { return; }\n\n    this._trace.hash = {};\n    this._trace.list = evt.parents;\n    this._trace.autoExpand = {};\n    for (var i = 0, uid; uid = evt.parents[i]; ++i) {\n      this._trace.hash[uid] = true;\n      this._trace.autoExpand[uid] = true;\n    }\n\n    var targetUID = evt.parents[i - 1];\n    this.highlightView(targetUID);\n    this._mouseHoverView = targetUID;\n\n    this.updateTrace();\n  };\n\n  this.onInputSelect = function (evt) {\n    if (!this._timer) { return; }\n\n    this._trace.hash = {};\n    this._trace.list = evt.parents;\n    for (var i = 0, uid; uid = evt.parents[i]; ++i) {\n      this._trace.hash[uid] = true;\n    }\n\n    var targetUID = evt.parents[i - 1];\n\n    this.selectView(targetUID);\n    //this.highlightView(targetUID);\n    //this._mouseHoverView = targetUID;\n\n    this.updateTrace();\n\n  };\n\n  this.onInputTrace = function (evt) {\n    if (!this._timer) { return; }\n\n    this.updateDeepTrace(evt);\n  };\n\n  function onOver(e) {\n    this._disableHighlight = false;\n    var uid = e.target.getAttribute(\"data-id\");\n    this.highlightView(+uid);\n  }\n\n  function onSelect(e) {\n    var uid = e.target.getAttribute(\"data-id\");\n    this.selectView(+uid);\n    this._deepTrace.style.display = \"none\";\n  }\n\n  var indent = 15; //indentation in pixel\n\n  this.updateDeepTrace = function (evt) {\n    var simulator = this._simulator;\n    var offset = simulator.getFrame().getBoundingClientRect();\n    var ratio = simulator.getDevicePixelRatio();\n    this._deepTrace.style.display = \"block\";\n    this._deepTrace.style.left = offset.left + evt.x / ratio + 5 + \"px\";\n    this._deepTrace.style.top = offset.top + evt.y / ratio + \"px\";\n\n    // document fragments perform much better for large amount of nodes\n    var frag = document.createDocumentFragment();\n    var i = evt.trace.length;\n    while (i--) {\n      // create the element\n      var el = document.createElement(\"div\");\n      el.innerText = evt.trace[i].tag;\n\n      el.setAttribute(\"data-id\", evt.trace[i].uid);\n      if (evt.trace[i].uid == evt.target) {\n        el.setAttribute(\"class\", \"active\");\n      }\n\n      el.style.paddingLeft = indent * evt.trace[i].depth + 8 + \"px\";\n\n      // bind events\n      el.onmouseover = bind(this, onOver);\n      el.onclick = bind(this, onSelect);\n\n      // add to the fragment\n      frag.appendChild(el);\n    }\n\n    // cheap way to remove all children\n    this._deepTrace.innerHTML = \"\";\n    this._deepTrace.appendChild(frag);\n  };\n\n  // since expanding a node is async, we need to call updateTrace\n  // every time a new node expands so we can highlight the nodes\n  // along the trace.\n  this.updateTrace = function () {\n    for (var uid in this._highlighted) {\n      if (!(uid in this._trace.hash)) {\n        delete this._highlighted[uid];\n        var node = this._nodeIndex[uid];\n        node && node.highlight(false);\n      }\n    }\n\n    var end = this._trace.list.length - 1;\n    for (var i = 0, uid; uid = this._trace.list[i]; ++i) {\n      var node = this._nodeIndex[uid];\n      if (node) {\n        if (this._trace.autoExpand[uid]) {\n          delete this._trace.autoExpand[uid];\n          if (!node.isToggled()) {\n            node.toggle();\n          }\n        }\n\n        node.highlight(true, i == end);\n        this._highlighted[uid] = true;\n      }\n    }\n  };\n\n  this.onMouseOut = function () {\n    if (this._mouseHoverView == this._highlight.target) {\n      for (var uid in this._highlighted) {\n        var node = this._nodeIndex[uid];\n        node && node.highlight(false);\n      }\n\n      this._highlighted = {};\n      this.highlightView();\n\n      // disable any further highlighting until mouse over\n      this._disableHighlight = true;\n    }\n  };\n\n  // on mouse over, let highlighting happen again\n  this.onMouseOver = function () {\n    this._disableHighlight = false;\n  };\n\n  this.highlightView = function (viewUID) {\n    var highlight = this._highlight;\n    highlight.target = viewUID;\n    this._highlightUID = viewUID;\n\n    // this._disableHighlight flag prevents race conditions between mouse out\n    // and move\n    if (!viewUID || this._disableHighlight) {\n      viewUID = this._selectedUID;\n    }\n\n    this._channel.emit('highlightView', viewUID);\n    this._details.showView(viewUID);\n  };\n\n  this.selectView = function (viewUID) {\n    var node;\n    if (this._selectedUID) {\n      node = this._nodeIndex[this._selectedUID];\n      node && node.setSelected(false);\n    }\n\n    node = this._nodeIndex[viewUID];\n    if (!node) {\n      return console.error(\"No node found for\", viewUID);\n    }\n\n    node.setSelected(true);\n    this._details.imageView(viewUID, node);\n\n    this._selectedUID = viewUID;\n\n    this._channel.emit('selectView', viewUID);\n  };\n\n  var PERIOD = 8000;\n\n  this.tick = function() {\n    if (!this._node) { return; }\n\n    this._node.refresh();\n    this._batchGetView.dispatch();\n\n    var highlight = this._highlight;\n    if (!highlight.target) { return; }\n\n    var t = +new Date();\n    var dt = t - this._t;\n    this._t = t;\n\n    highlight.timer += dt;\n    if (highlight.timer > PERIOD) {\n      highlight.timer -= PERIOD;\n    }\n  };\n\n  this.toggleVisibility = function () {\n    this._isShowing = !this._isShowing;\n    if (this._isShowing) {\n      this.open();\n    } else {\n      this.close();\n    }\n  };\n\n  this.isOpen = function () { return this._isShowing; };\n\n  this.onShow = function() {\n    supr(this, 'onShow', arguments);\n\n    var style = this.getElement().style;\n    style.display = 'flex';\n    style.left = '0px';\n    style.opacity = 1;\n    this.startDebugging();\n\n    this.startTimer();\n  };\n\n  this.open = function () {\n    $.removeClass(this._el, 'closed');\n\n    this._isShowing = true;\n    this.show();\n\n    this.emit('open');\n  };\n\n  this.close = function() {\n    this._isShowing = false;\n    this.stopTimer();\n\n    // cancel the view position polling if it's active\n    this._disconnectMouseEvents();\n\n    $.addClass(this._el, 'closed');\n    var style = this._el.style;\n    style.left = -this._el.offsetWidth + 'px';\n    style.opacity = 0;\n\n    setTimeout(function () {\n      style.display = 'none';\n    }, 300);\n\n    this._selectedUID = null;\n    this._highlightUID = null;\n    this._channel.emit('selectView', {uid: null});\n    this._channel.emit('highlightView', {uid: null});\n\n    this.stopTimer();\n    this.emit('close');\n  };\n\n  this._connectMouseEvents = function () {\n    return this._channel.request('enableInputListener');\n  };\n\n  this._disconnectMouseEvents = function () {\n    this._channel.emit('stopPollView');\n    return this._channel.request('disableInputListener');\n  };\n\n  this._addNode = function(id, node) { this._nodeIndex[id] = node; };\n  this._removeNode = function(id) { delete this._nodeIndex[id]; };\n});\n\nmodule.exports = new ViewInspector();\n");
jsio.setCachedSrc('../node_modules/jsio/packages/util/browser.js',"jsio('external .sizzle import Sizzle');\n\njsio('import math.geom.Rect');\n\nfunction isWindow(el) {\n\treturn el && !$.isElement(el) && $.isElement(el.document);\n}\n\nvar singleId = /^#([\\w-]+)$/;\n\nvar $ = exports.$ = function(selector, win) {\n\tswitch(typeof selector) {\n\t\tcase 'object':\n\t\t\tif ($.isElement(selector)) {\n\t\t\t\treturn $.remove(selector);\n\t\t\t} else if ($.isElement(selector.document && selector.document.body)) {\n\t\t\t\treturn $.size(selector);\n\t\t\t}\n\t\t\treturn $.create(selector);\n\t\tcase 'string':\n\t\t\tif (singleId.test(selector)) { return $.id(selector.substring(1), win); }\n\t\t\treturn Sizzle.apply(GLOBAL, arguments);\n\t}\n}\n\nvar DOM2 = typeof HTMLElement === \"object\";\n$.isElement = DOM2\n\t? function(el) { return el && el instanceof HTMLElement; }\n\t: function(el) { return el && typeof el.nodeType == 'number' && typeof el.nodeName == 'string' };\n\n$.id = function(id, win) { return typeof id == 'string' ? (win || window).document.getElementById(id) : id; }\n\n$.apply = function(el, params) {\n\tif (params.attrs) {\n\t\tfor(attr in params.attrs) {\n\t\t\tel.setAttribute(attr, params.attrs[attr]);\n\t\t}\n\t}\n\n\tif (params.id) { el.id = params.id; }\n\tif (params.style) { $.style(el, params.style); }\n\tif (params.src) { el.src = params.src; }\n\tif (params['class'] || params['className']) {\n\t\tel.className = params['class'] || params['className'];\n\t}\n\n\tvar parent = params.parent || params.parentNode;\n\tif (parent && params.first) {\n\t\t$.insertBefore(parent, el, parent.firstChild);\n\t} else if (params.before) {\n\t\t$.insertBefore(params.before.parentNode || parent, el, params.before);\n\t} else if (params.after) {\n\t\t$.insertAfter(params.after.parentNode || parent, el, params.after);\n\t} else if (parent) {\n\t\tparent.appendChild(el);\n\t}\n\n\tif ('html' in params) { el.innerHTML = params.html; }\n\tif ('text' in params) { $.setText(el, params.text); }\n\n\tif (params.children) {\n\t\tvar c = params.children;\n\t\tfor (var i = 0, n = c.length; i < n; ++i) {\n\t\t\tel.appendChild($.isElement(c[i]) ? c[i] : $(c[i]));\n\t\t}\n\t}\n\n\treturn el;\n}\n\n$.insertBefore = function(parentNode, el, beforeNode) {\n\tif (!parentNode || !el) { return; }\n\tif (beforeNode && beforeNode.parentNode == parentNode) {\n\t\tparentNode.insertBefore(el, beforeNode);\n\t} else {\n\t\tparentNode.appendChild(el);\n\t}\n}\n\n$.insertAfter = function(parentNode, el, afterNode) {\n\tif (!parentNode || !el) { return; }\n\tif (!afterNode || afterNode.parentNode != parentNode) {\n\t\t$.insertBefore(parentNode, el, parentNode.firstChild);\n\t} else if (!afterNode.nextSibling) {\n\t\tparentNode.appendChild(el);\n\t} else {\n\t\tparentNode.insertBefore(el, afterNode.nextSibling);\n\t}\n}\n\n$.create = function(params) {\n\tvar doc = ((params && params.win) || window).document;\n\tif (!params || typeof params == 'string') {\n\t\treturn doc.createElement(params || 'div');\n\t};\n\n\treturn $.apply(params.el || doc.createElement(params.tag || params.tagName || 'div'), params);\n}\n\n$.show = function(el, how) { $.id(el).style.display = how || 'block'; }\n$.hide = function(el) { $.id(el).style.display = 'none'; }\n\n// accepts an array or a space-delimited string of classNames\n$.addClass = function(el, classNames) {\n\tif (!el) { return; }\n\tvar el = $.id(el);\n\tif (typeof classNames == \"string\") {\n\t\tclassNames = classNames.split(' ');\n\t}\n\n\tvar current = ' ' + el.className + ' ';\n\tfor (var i = 0, len = classNames.length; i < len; ++i) {\n\t\tvar c = classNames[i];\n\t\tif (current.indexOf(' ' + c + ' ') == -1) {\n\t\t\tcurrent += c + ' ';\n\t\t}\n\t}\n\n\tel.className = current.replace(/^\\s+|\\s+$/g, '');\n\treturn $;\n}\n\n/* returns true if the given className is found in the list of\n * classes on the given element.\n */\n$.hasClass = function(el, className) {\n\tif (!el) { return false; }\n\n\tvar el = $.id(el);\n\tvar classNames = el.className.split(' ');\n\n\tfor (var i = 0, len = classNames.length; i < len; ++i) {\n\t\tif (classNames[i].trim() === className) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n};\n\n$.getTag = function(from, tag) { return from.getElementsByTagName(tag); }\n\n$.removeClass = function(el, classNames) {\n\tif (!el) { return; }\n\tvar el = $.id(el);\n\tel.className = (' ' + el.className + ' ')\n\t\t.replace(' ', '  ')\n\t\t.replace(new RegExp('( ' + classNames.replace('\\s+', ' | ').replace('-','\\-') + ' )', 'g'), ' ')\n\t\t.replace(/\\s+/, ' ')\n\t\t.replace(/^\\s+|\\s+$/g, '');\n}\n\nfunction ieGetAlpha(el) {\n\ttry {\n\t\treturn el.filters.item(\"alpha\");\n\t} catch(e) {}\n\n\ttry {\n\t\treturn el.filters.item(\"progid:DXImageTransform.Microsoft.Alpha\");\n\t} catch(e) {}\n\n\treturn null;\n}\n\n$.style = function(el, style) {\n\tif(el instanceof Array) {\n\t\tfor(var i = 0, o; o = el[i]; ++i) { $.style(o, style); }\n\t\treturn;\n\t}\n\n\tel = $.id(el);\n\tvar s = el.style;\n\tfor(prop in style) {\n\t\tswitch(prop) {\n\t\t\tcase 'styleFloat':\n\t\t\tcase 'cssFloat':\n\t\t\tcase 'float':\n\t\t\t\ts.styleFloat = s.cssFloat = style[prop];\n\t\t\t\tbreak;\n\t\t\tcase 'opacity':\n\t\t\t\ts.opacity = style[prop];\n\t\t\t\tif(el.filters) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar alpha = ieGetAlpha();\n\t\t\t\t\t\tvar opacity = style[prop] == 1 ? 99.99 : style[prop] * 100;\n\t\t\t\t\t\tif(!alpha) {\n\t\t\t\t\t\t\t// TODO: this might destroy any existing filters?\n\t\t\t\t\t\t\ts.filter = \"alpha(opacity=\" + opacity + \")\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\talpha.Opacity = opacity;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(e) {}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'borderRadius':\n\t\t\t\ts.borderRadius = s.MozBorderRadius = style[prop];\n\t\t\t\tbreak;\n\t\t\tcase 'boxSizing':\n\t\t\t\ts.MsBoxSizing = s.MozBoxSizing = s.WebkitBoxSizing = style[prop];\n\t\t\tdefault:\n\t\t\t\ts[prop] = style[prop];\n\t\t\t\tbreak;\n\t\t}\n\t}\n};\n\n$.onEvent = function(el, name, f) {\n\tif (typeof f != 'function') {\n\t\tf = bind.apply(GLOBAL, Array.prototype.slice.call(arguments, 2));\n\t}\n\n\tvar handler = f;\n\n\tel = $.id(el);\n\tif(el.addEventListener) {\n\t\tel.addEventListener(name, handler, false);\n\t} else {\n\t\thandler = function(e) {\n\t\t\tvar evt = e || window.event;\n\t\t\t// TODO: normalize the event object\n\t\t\tf(evt);\n\t\t};\n\n\t\tel.attachEvent('on' + name, handler);\n\t}\n\n\treturn bind($, 'removeEvent', el, name, handler);\n};\n\n$.removeEvent = function(el, name, f) {\n\tel = $.id(el);\n\tif (el.addEventListener) {\n\t\tel.removeEventListener(name, f, false);\n\t} else {\n\t\tel.detachEvent('on' + name, f);\n\t}\n}\n\n$.stopEvent = function(e) {\n\tif (e) {\n\t\te.cancelBubble = true;\n\t\tif(e.stopPropagation) e.stopPropagation();\n\t\tif(e.preventDefault) e.preventDefault();\n\t}\n}\n\n$.setText = function(el, text) {\n\tel = $.id(el);\n\ttext = String(text);\n\tif ('textContent' in el) {\n\t\tel.textContent = text;\n\t} else if ('innerText' in el) {\n\t\tel.innerText = text.replace(/\\n/g, ' ');\n\t} else {\n\t\tel.innerHTML = '';\n\t\tel.appendChild(document.createTextNode(text));\n\t}\n}\n\n$.setValue = function(el, value) {\n\tel = $.id(el);\n\tif ('value' in el) {\n\t\tel.value = value;\n\t} else if ('value' in el.firstChild) {\n\t\tel.firstChild.value = value;\n\t}\n};\n\n$.remove = function(el) {\n\tel = $.id(el);\n\tif(el && el.parentNode) {\n\t\tel.parentNode.removeChild(el);\n\t}\n}\n\n$.cursorPos = function(ev, el) {\n\tvar offset = $.pos(el);\n\toffset.top = ev.clientY - offset.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);\n\toffset.left = ev.clientX - offset.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft);\n\treturn offset;\n}\n\n$.pos = function(el) {\n\tvar parent = el;\n\tvar offset = {top: 0, left: 0};\n\twhile(parent && parent != document.body) {\n\t\toffset.left += parent.offsetLeft;\n\t\toffset.top += parent.offsetTop;\n\t\twhile(parent.offsetParent != parent.parentNode) {\n\t\t\toffset.top -= parent.scrollTop; offset.left -= parent.scrollLeft;\n\t\t\tparent = parent.parentNode;\n\t\t}\n\t\tparent = parent.offsetParent;\n\t}\n\treturn offset;\n}\n\n$.size = function(el) {\n\tif ($.isElement(el)) {\n\t\treturn {width: el.offsetWidth, height: el.offsetHeight};\n\t} else if (el.document) {\n\t\tvar doc = el.document.documentElement || el.document.body;\n\t\treturn new math.geom.Rect(\n\t\t\tdoc.offsetTop,\n\t\t\tdoc.offsetLeft,\n\t\t\tel.innerWidth || (doc.clientWidth || doc.clientWidth),\n\t\t\tel.innerHeight || (doc.clientHeight || doc.clientHeight)\n\t\t);\n\t}\n}\n\n$.insertCSSFile = function(filename) {\n\tdocument.getElementsByTagName('head')[0].appendChild($({\n\t\ttag: 'link',\n\t\tattrs: {\n\t\t\trel: 'stylesheet',\n\t\t\ttype: 'text/css',\n\t\t\thref: filename\n\t\t}\n\t}));\n}\n");
jsio.setCachedSrc('../node_modules/jsio/packages/util/sizzle.js',"/*!\n * Sizzle CSS Selector Engine - v1.0\n *  Copyright 2009, The Dojo Foundation\n *  Released under the MIT, BSD, and GPL Licenses.\n *  More information: http://sizzlejs.com/\n */\n\nSizzle = (function(){\n\nvar chunker = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^[\\]]*\\]|['\"][^'\"]*['\"]|[^[\\]'\"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?/g,\n\tdone = 0,\n\ttoString = Object.prototype.toString,\n\thasDuplicate = false;\n\nvar Sizzle = function(selector, context, results, seed) {\n\tresults = results || [];\n\tvar origContext = context = context || document;\n\n\tif ( context.nodeType !== 1 && context.nodeType !== 9 ) {\n\t\treturn [];\n\t}\n\t\n\tif ( !selector || typeof selector !== \"string\" ) {\n\t\treturn results;\n\t}\n\n\tvar parts = [], m, set, checkSet, check, mode, extra, prune = true, contextXML = isXML(context);\n\t\n\t// Reset the position of the chunker regexp (start from head)\n\tchunker.lastIndex = 0;\n\t\n\twhile ( (m = chunker.exec(selector)) !== null ) {\n\t\tparts.push( m[1] );\n\t\t\n\t\tif ( m[2] ) {\n\t\t\textra = RegExp.rightContext;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( parts.length > 1 && origPOS.exec( selector ) ) {\n\t\tif ( parts.length === 2 && Expr.relative[ parts[0] ] ) {\n\t\t\tset = posProcess( parts[0] + parts[1], context );\n\t\t} else {\n\t\t\tset = Expr.relative[ parts[0] ] ?\n\t\t\t\t[ context ] :\n\t\t\t\tSizzle( parts.shift(), context );\n\n\t\t\twhile ( parts.length ) {\n\t\t\t\tselector = parts.shift();\n\n\t\t\t\tif ( Expr.relative[ selector ] )\n\t\t\t\t\tselector += parts.shift();\n\n\t\t\t\tset = posProcess( selector, set );\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\t// (but not if it'll be faster if the inner selector is an ID)\n\t\tif ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&\n\t\t\t\tExpr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {\n\t\t\tvar ret = Sizzle.find( parts.shift(), context, contextXML );\n\t\t\tcontext = ret.expr ? Sizzle.filter( ret.expr, ret.set )[0] : ret.set[0];\n\t\t}\n\n\t\tif ( context ) {\n\t\t\tvar ret = seed ?\n\t\t\t\t{ expr: parts.pop(), set: makeArray(seed) } :\n\t\t\t\tSizzle.find( parts.pop(), parts.length === 1 && (parts[0] === \"~\" || parts[0] === \"+\") && context.parentNode ? context.parentNode : context, contextXML );\n\t\t\tset = ret.expr ? Sizzle.filter( ret.expr, ret.set ) : ret.set;\n\n\t\t\tif ( parts.length > 0 ) {\n\t\t\t\tcheckSet = makeArray(set);\n\t\t\t} else {\n\t\t\t\tprune = false;\n\t\t\t}\n\n\t\t\twhile ( parts.length ) {\n\t\t\t\tvar cur = parts.pop(), pop = cur;\n\n\t\t\t\tif ( !Expr.relative[ cur ] ) {\n\t\t\t\t\tcur = \"\";\n\t\t\t\t} else {\n\t\t\t\t\tpop = parts.pop();\n\t\t\t\t}\n\n\t\t\t\tif ( pop == null ) {\n\t\t\t\t\tpop = context;\n\t\t\t\t}\n\n\t\t\t\tExpr.relative[ cur ]( checkSet, pop, contextXML );\n\t\t\t}\n\t\t} else {\n\t\t\tcheckSet = parts = [];\n\t\t}\n\t}\n\n\tif ( !checkSet ) {\n\t\tcheckSet = set;\n\t}\n\n\tif ( !checkSet ) {\n\t\tthrow \"Syntax error, unrecognized expression: \" + (cur || selector);\n\t}\n\n\tif ( toString.call(checkSet) === \"[object Array]\" ) {\n\t\tif ( !prune ) {\n\t\t\tresults.push.apply( results, checkSet );\n\t\t} else if ( context && context.nodeType === 1 ) {\n\t\t\tfor ( var i = 0; checkSet[i] != null; i++ ) {\n\t\t\t\tif ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && contains(context, checkSet[i])) ) {\n\t\t\t\t\tresults.push( set[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( var i = 0; checkSet[i] != null; i++ ) {\n\t\t\t\tif ( checkSet[i] && checkSet[i].nodeType === 1 ) {\n\t\t\t\t\tresults.push( set[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmakeArray( checkSet, results );\n\t}\n\n\tif ( extra ) {\n\t\tSizzle( extra, origContext, results, seed );\n\t\tSizzle.uniqueSort( results );\n\t}\n\n\treturn results;\n};\n\nSizzle.uniqueSort = function(results){\n\tif ( sortOrder ) {\n\t\thasDuplicate = false;\n\t\tresults.sort(sortOrder);\n\n\t\tif ( hasDuplicate ) {\n\t\t\tfor ( var i = 1; i < results.length; i++ ) {\n\t\t\t\tif ( results[i] === results[i-1] ) {\n\t\t\t\t\tresults.splice(i--, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nSizzle.matches = function(expr, set){\n\treturn Sizzle(expr, null, null, set);\n};\n\nSizzle.find = function(expr, context, isXML){\n\tvar set, match;\n\n\tif ( !expr ) {\n\t\treturn [];\n\t}\n\n\tfor ( var i = 0, l = Expr.order.length; i < l; i++ ) {\n\t\tvar type = Expr.order[i], match;\n\t\t\n\t\tif ( (match = Expr.match[ type ].exec( expr )) ) {\n\t\t\tvar left = RegExp.leftContext;\n\n\t\t\tif ( left.substr( left.length - 1 ) !== \"\\\\\" ) {\n\t\t\t\tmatch[1] = (match[1] || \"\").replace(/\\\\/g, \"\");\n\t\t\t\tset = Expr.find[ type ]( match, context, isXML );\n\t\t\t\tif ( set != null ) {\n\t\t\t\t\texpr = expr.replace( Expr.match[ type ], \"\" );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( !set ) {\n\t\tset = context.getElementsByTagName(\"*\");\n\t}\n\n\treturn {set: set, expr: expr};\n};\n\nSizzle.filter = function(expr, set, inplace, not){\n\tvar old = expr, result = [], curLoop = set, match, anyFound,\n\t\tisXMLFilter = set && set[0] && isXML(set[0]);\n\n\twhile ( expr && set.length ) {\n\t\tfor ( var type in Expr.filter ) {\n\t\t\tif ( (match = Expr.match[ type ].exec( expr )) != null ) {\n\t\t\t\tvar filter = Expr.filter[ type ], found, item;\n\t\t\t\tanyFound = false;\n\n\t\t\t\tif ( curLoop == result ) {\n\t\t\t\t\tresult = [];\n\t\t\t\t}\n\n\t\t\t\tif ( Expr.preFilter[ type ] ) {\n\t\t\t\t\tmatch = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );\n\n\t\t\t\t\tif ( !match ) {\n\t\t\t\t\t\tanyFound = found = true;\n\t\t\t\t\t} else if ( match === true ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( match ) {\n\t\t\t\t\tfor ( var i = 0; (item = curLoop[i]) != null; i++ ) {\n\t\t\t\t\t\tif ( item ) {\n\t\t\t\t\t\t\tfound = filter( item, match, i, curLoop );\n\t\t\t\t\t\t\tvar pass = not ^ !!found;\n\n\t\t\t\t\t\t\tif ( inplace && found != null ) {\n\t\t\t\t\t\t\t\tif ( pass ) {\n\t\t\t\t\t\t\t\t\tanyFound = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcurLoop[i] = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( pass ) {\n\t\t\t\t\t\t\t\tresult.push( item );\n\t\t\t\t\t\t\t\tanyFound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( found !== undefined ) {\n\t\t\t\t\tif ( !inplace ) {\n\t\t\t\t\t\tcurLoop = result;\n\t\t\t\t\t}\n\n\t\t\t\t\texpr = expr.replace( Expr.match[ type ], \"\" );\n\n\t\t\t\t\tif ( !anyFound ) {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Improper expression\n\t\tif ( expr == old ) {\n\t\t\tif ( anyFound == null ) {\n\t\t\t\tthrow \"Syntax error, unrecognized expression: \" + expr;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\told = expr;\n\t}\n\n\treturn curLoop;\n};\n\nvar Expr = Sizzle.selectors = {\n\torder: [ \"ID\", \"NAME\", \"TAG\" ],\n\tmatch: {\n\t\tID: /#((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)/,\n\t\tCLASS: /\\.((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)/,\n\t\tNAME: /\\[name=['\"]*((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)['\"]*\\]/,\n\t\tATTR: /\\[\\s*((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)\\s*(?:(\\S?=)\\s*(['\"]*)(.*?)\\3|)\\s*\\]/,\n\t\tTAG: /^((?:[\\w\\u00c0-\\uFFFF\\*_-]|\\\\.)+)/,\n\t\tCHILD: /:(only|nth|last|first)-child(?:\\((even|odd|[\\dn+-]*)\\))?/,\n\t\tPOS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^-]|$)/,\n\t\tPSEUDO: /:((?:[\\w\\u00c0-\\uFFFF_-]|\\\\.)+)(?:\\((['\"]*)((?:\\([^\\)]+\\)|[^\\2\\(\\)]*)+)\\2\\))?/\n\t},\n\tattrMap: {\n\t\t\"class\": \"className\",\n\t\t\"for\": \"htmlFor\"\n\t},\n\tattrHandle: {\n\t\thref: function(elem){\n\t\t\treturn elem.getAttribute(\"href\");\n\t\t}\n\t},\n\trelative: {\n\t\t\"+\": function(checkSet, part, isXML){\n\t\t\tvar isPartStr = typeof part === \"string\",\n\t\t\t\tisTag = isPartStr && !/\\W/.test(part),\n\t\t\t\tisPartStrNotTag = isPartStr && !isTag;\n\n\t\t\tif ( isTag && !isXML ) {\n\t\t\t\tpart = part.toUpperCase();\n\t\t\t}\n\n\t\t\tfor ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {\n\t\t\t\tif ( (elem = checkSet[i]) ) {\n\t\t\t\t\twhile ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}\n\n\t\t\t\t\tcheckSet[i] = isPartStrNotTag || elem && elem.nodeName === part ?\n\t\t\t\t\t\telem || false :\n\t\t\t\t\t\telem === part;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( isPartStrNotTag ) {\n\t\t\t\tSizzle.filter( part, checkSet, true );\n\t\t\t}\n\t\t},\n\t\t\">\": function(checkSet, part, isXML){\n\t\t\tvar isPartStr = typeof part === \"string\";\n\n\t\t\tif ( isPartStr && !/\\W/.test(part) ) {\n\t\t\t\tpart = isXML ? part : part.toUpperCase();\n\n\t\t\t\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\t\t\t\tvar elem = checkSet[i];\n\t\t\t\t\tif ( elem ) {\n\t\t\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\t\t\tcheckSet[i] = parent.nodeName === part ? parent : false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\t\t\t\tvar elem = checkSet[i];\n\t\t\t\t\tif ( elem ) {\n\t\t\t\t\t\tcheckSet[i] = isPartStr ?\n\t\t\t\t\t\t\telem.parentNode :\n\t\t\t\t\t\t\telem.parentNode === part;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( isPartStr ) {\n\t\t\t\t\tSizzle.filter( part, checkSet, true );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"\": function(checkSet, part, isXML){\n\t\t\tvar doneName = done++, checkFn = dirCheck;\n\n\t\t\tif ( !/\\W/.test(part) ) {\n\t\t\t\tvar nodeCheck = part = isXML ? part : part.toUpperCase();\n\t\t\t\tcheckFn = dirNodeCheck;\n\t\t\t}\n\n\t\t\tcheckFn(\"parentNode\", part, doneName, checkSet, nodeCheck, isXML);\n\t\t},\n\t\t\"~\": function(checkSet, part, isXML){\n\t\t\tvar doneName = done++, checkFn = dirCheck;\n\n\t\t\tif ( typeof part === \"string\" && !/\\W/.test(part) ) {\n\t\t\t\tvar nodeCheck = part = isXML ? part : part.toUpperCase();\n\t\t\t\tcheckFn = dirNodeCheck;\n\t\t\t}\n\n\t\t\tcheckFn(\"previousSibling\", part, doneName, checkSet, nodeCheck, isXML);\n\t\t}\n\t},\n\tfind: {\n\t\tID: function(match, context, isXML){\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && !isXML ) {\n\t\t\t\tvar m = context.getElementById(match[1]);\n\t\t\t\treturn m ? [m] : [];\n\t\t\t}\n\t\t},\n\t\tNAME: function(match, context, isXML){\n\t\t\tif ( typeof context.getElementsByName !== \"undefined\" ) {\n\t\t\t\tvar ret = [], results = context.getElementsByName(match[1]);\n\n\t\t\t\tfor ( var i = 0, l = results.length; i < l; i++ ) {\n\t\t\t\t\tif ( results[i].getAttribute(\"name\") === match[1] ) {\n\t\t\t\t\t\tret.push( results[i] );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ret.length === 0 ? null : ret;\n\t\t\t}\n\t\t},\n\t\tTAG: function(match, context){\n\t\t\treturn context.getElementsByTagName(match[1]);\n\t\t}\n\t},\n\tpreFilter: {\n\t\tCLASS: function(match, curLoop, inplace, result, not, isXML){\n\t\t\tmatch = \" \" + match[1].replace(/\\\\/g, \"\") + \" \";\n\n\t\t\tif ( isXML ) {\n\t\t\t\treturn match;\n\t\t\t}\n\n\t\t\tfor ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {\n\t\t\t\tif ( elem ) {\n\t\t\t\t\tif ( not ^ (elem.className && (\" \" + elem.className + \" \").indexOf(match) >= 0) ) {\n\t\t\t\t\t\tif ( !inplace )\n\t\t\t\t\t\t\tresult.push( elem );\n\t\t\t\t\t} else if ( inplace ) {\n\t\t\t\t\t\tcurLoop[i] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\t\tID: function(match){\n\t\t\treturn match[1].replace(/\\\\/g, \"\");\n\t\t},\n\t\tTAG: function(match, curLoop){\n\t\t\tfor ( var i = 0; curLoop[i] === false; i++ ){}\n\t\t\treturn curLoop[i] && isXML(curLoop[i]) ? match[1] : match[1].toUpperCase();\n\t\t},\n\t\tCHILD: function(match){\n\t\t\tif ( match[1] == \"nth\" ) {\n\t\t\t\t// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'\n\t\t\t\tvar test = /(-?)(\\d*)n((?:\\+|-)?\\d*)/.exec(\n\t\t\t\t\tmatch[2] == \"even\" && \"2n\" || match[2] == \"odd\" && \"2n+1\" ||\n\t\t\t\t\t!/\\D/.test( match[2] ) && \"0n+\" + match[2] || match[2]);\n\n\t\t\t\t// calculate the numbers (first)n+(last) including if they are negative\n\t\t\t\tmatch[2] = (test[1] + (test[2] || 1)) - 0;\n\t\t\t\tmatch[3] = test[3] - 0;\n\t\t\t}\n\n\t\t\t// TODO: Move to normal caching system\n\t\t\tmatch[0] = done++;\n\n\t\t\treturn match;\n\t\t},\n\t\tATTR: function(match, curLoop, inplace, result, not, isXML){\n\t\t\tvar name = match[1].replace(/\\\\/g, \"\");\n\t\t\t\n\t\t\tif ( !isXML && Expr.attrMap[name] ) {\n\t\t\t\tmatch[1] = Expr.attrMap[name];\n\t\t\t}\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[4] = \" \" + match[4] + \" \";\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\t\tPSEUDO: function(match, curLoop, inplace, result, not){\n\t\t\tif ( match[1] === \"not\" ) {\n\t\t\t\t// If we're dealing with a complex expression, or a simple one\n\t\t\t\tif ( chunker.exec(match[3]).length > 1 || /^\\w/.test(match[3]) ) {\n\t\t\t\t\tmatch[3] = Sizzle(match[3], null, null, curLoop);\n\t\t\t\t} else {\n\t\t\t\t\tvar ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);\n\t\t\t\t\tif ( !inplace ) {\n\t\t\t\t\t\tresult.push.apply( result, ret );\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn match;\n\t\t},\n\t\tPOS: function(match){\n\t\t\tmatch.unshift( true );\n\t\t\treturn match;\n\t\t}\n\t},\n\tfilters: {\n\t\tenabled: function(elem){\n\t\t\treturn elem.disabled === false && elem.type !== \"hidden\";\n\t\t},\n\t\tdisabled: function(elem){\n\t\t\treturn elem.disabled === true;\n\t\t},\n\t\tchecked: function(elem){\n\t\t\treturn elem.checked === true;\n\t\t},\n\t\tselected: function(elem){\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\telem.parentNode.selectedIndex;\n\t\t\treturn elem.selected === true;\n\t\t},\n\t\tparent: function(elem){\n\t\t\treturn !!elem.firstChild;\n\t\t},\n\t\tempty: function(elem){\n\t\t\treturn !elem.firstChild;\n\t\t},\n\t\thas: function(elem, i, match){\n\t\t\treturn !!Sizzle( match[3], elem ).length;\n\t\t},\n\t\theader: function(elem){\n\t\t\treturn /h\\d/i.test( elem.nodeName );\n\t\t},\n\t\ttext: function(elem){\n\t\t\treturn \"text\" === elem.type;\n\t\t},\n\t\tradio: function(elem){\n\t\t\treturn \"radio\" === elem.type;\n\t\t},\n\t\tcheckbox: function(elem){\n\t\t\treturn \"checkbox\" === elem.type;\n\t\t},\n\t\tfile: function(elem){\n\t\t\treturn \"file\" === elem.type;\n\t\t},\n\t\tpassword: function(elem){\n\t\t\treturn \"password\" === elem.type;\n\t\t},\n\t\tsubmit: function(elem){\n\t\t\treturn \"submit\" === elem.type;\n\t\t},\n\t\timage: function(elem){\n\t\t\treturn \"image\" === elem.type;\n\t\t},\n\t\treset: function(elem){\n\t\t\treturn \"reset\" === elem.type;\n\t\t},\n\t\tbutton: function(elem){\n\t\t\treturn \"button\" === elem.type || elem.nodeName.toUpperCase() === \"BUTTON\";\n\t\t},\n\t\tinput: function(elem){\n\t\t\treturn /input|select|textarea|button/i.test(elem.nodeName);\n\t\t}\n\t},\n\tsetFilters: {\n\t\tfirst: function(elem, i){\n\t\t\treturn i === 0;\n\t\t},\n\t\tlast: function(elem, i, match, array){\n\t\t\treturn i === array.length - 1;\n\t\t},\n\t\teven: function(elem, i){\n\t\t\treturn i % 2 === 0;\n\t\t},\n\t\todd: function(elem, i){\n\t\t\treturn i % 2 === 1;\n\t\t},\n\t\tlt: function(elem, i, match){\n\t\t\treturn i < match[3] - 0;\n\t\t},\n\t\tgt: function(elem, i, match){\n\t\t\treturn i > match[3] - 0;\n\t\t},\n\t\tnth: function(elem, i, match){\n\t\t\treturn match[3] - 0 == i;\n\t\t},\n\t\teq: function(elem, i, match){\n\t\t\treturn match[3] - 0 == i;\n\t\t}\n\t},\n\tfilter: {\n\t\tPSEUDO: function(elem, match, i, array){\n\t\t\tvar name = match[1], filter = Expr.filters[ name ];\n\n\t\t\tif ( filter ) {\n\t\t\t\treturn filter( elem, i, match, array );\n\t\t\t} else if ( name === \"contains\" ) {\n\t\t\t\treturn (elem.textContent || elem.innerText || \"\").indexOf(match[3]) >= 0;\n\t\t\t} else if ( name === \"not\" ) {\n\t\t\t\tvar not = match[3];\n\n\t\t\t\tfor ( var i = 0, l = not.length; i < l; i++ ) {\n\t\t\t\t\tif ( not[i] === elem ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tCHILD: function(elem, match){\n\t\t\tvar type = match[1], node = elem;\n\t\t\tswitch (type) {\n\t\t\t\tcase 'only':\n\t\t\t\tcase 'first':\n\t\t\t\t\twhile ( (node = node.previousSibling) )  {\n\t\t\t\t\t\tif ( node.nodeType === 1 ) return false;\n\t\t\t\t\t}\n\t\t\t\t\tif ( type == 'first') return true;\n\t\t\t\t\tnode = elem;\n\t\t\t\tcase 'last':\n\t\t\t\t\twhile ( (node = node.nextSibling) )  {\n\t\t\t\t\t\tif ( node.nodeType === 1 ) return false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\tcase 'nth':\n\t\t\t\t\tvar first = match[2], last = match[3];\n\n\t\t\t\t\tif ( first == 1 && last == 0 ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar doneName = match[0],\n\t\t\t\t\t\tparent = elem.parentNode;\n\t\n\t\t\t\t\tif ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {\n\t\t\t\t\t\tvar count = 0;\n\t\t\t\t\t\tfor ( node = parent.firstChild; node; node = node.nextSibling ) {\n\t\t\t\t\t\t\tif ( node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\tnode.nodeIndex = ++count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} \n\t\t\t\t\t\tparent.sizcache = doneName;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar diff = elem.nodeIndex - last;\n\t\t\t\t\tif ( first == 0 ) {\n\t\t\t\t\t\treturn diff == 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn ( diff % first == 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tID: function(elem, match){\n\t\t\treturn elem.nodeType === 1 && elem.getAttribute(\"id\") === match;\n\t\t},\n\t\tTAG: function(elem, match){\n\t\t\treturn (match === \"*\" && elem.nodeType === 1) || elem.nodeName === match;\n\t\t},\n\t\tCLASS: function(elem, match){\n\t\t\treturn (\" \" + (elem.className || elem.getAttribute(\"class\")) + \" \")\n\t\t\t\t.indexOf( match ) > -1;\n\t\t},\n\t\tATTR: function(elem, match){\n\t\t\tvar name = match[1],\n\t\t\t\tresult = Expr.attrHandle[ name ] ?\n\t\t\t\t\tExpr.attrHandle[ name ]( elem ) :\n\t\t\t\t\telem[ name ] != null ?\n\t\t\t\t\t\telem[ name ] :\n\t\t\t\t\t\telem.getAttribute( name ),\n\t\t\t\tvalue = result + \"\",\n\t\t\t\ttype = match[2],\n\t\t\t\tcheck = match[4];\n\n\t\t\treturn result == null ?\n\t\t\t\ttype === \"!=\" :\n\t\t\t\ttype === \"=\" ?\n\t\t\t\tvalue === check :\n\t\t\t\ttype === \"*=\" ?\n\t\t\t\tvalue.indexOf(check) >= 0 :\n\t\t\t\ttype === \"~=\" ?\n\t\t\t\t(\" \" + value + \" \").indexOf(check) >= 0 :\n\t\t\t\t!check ?\n\t\t\t\tvalue && result !== false :\n\t\t\t\ttype === \"!=\" ?\n\t\t\t\tvalue != check :\n\t\t\t\ttype === \"^=\" ?\n\t\t\t\tvalue.indexOf(check) === 0 :\n\t\t\t\ttype === \"$=\" ?\n\t\t\t\tvalue.substr(value.length - check.length) === check :\n\t\t\t\ttype === \"|=\" ?\n\t\t\t\tvalue === check || value.substr(0, check.length + 1) === check + \"-\" :\n\t\t\t\tfalse;\n\t\t},\n\t\tPOS: function(elem, match, i, array){\n\t\t\tvar name = match[2], filter = Expr.setFilters[ name ];\n\n\t\t\tif ( filter ) {\n\t\t\t\treturn filter( elem, i, match, array );\n\t\t\t}\n\t\t}\n\t}\n};\n\nvar origPOS = Expr.match.POS;\n\nfor ( var type in Expr.match ) {\n\tExpr.match[ type ] = new RegExp( Expr.match[ type ].source + /(?![^\\[]*\\])(?![^\\(]*\\))/.source );\n}\n\nvar makeArray = function(array, results) {\n\tarray = Array.prototype.slice.call( array, 0 );\n\n\tif ( results ) {\n\t\tresults.push.apply( results, array );\n\t\treturn results;\n\t}\n\t\n\treturn array;\n};\n\n// Perform a simple check to determine if the browser is capable of\n// converting a NodeList to an array using builtin methods.\ntry {\n\tArray.prototype.slice.call( document.documentElement.childNodes, 0 );\n\n// Provide a fallback method if it does not work\n} catch(e){\n\tmakeArray = function(array, results) {\n\t\tvar ret = results || [];\n\n\t\tif ( toString.call(array) === \"[object Array]\" ) {\n\t\t\tArray.prototype.push.apply( ret, array );\n\t\t} else {\n\t\t\tif ( typeof array.length === \"number\" ) {\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i++ ) {\n\t\t\t\t\tret.push( array[i] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( var i = 0; array[i]; i++ ) {\n\t\t\t\t\tret.push( array[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t};\n}\n\nvar sortOrder;\n\nif ( document.documentElement.compareDocumentPosition ) {\n\tsortOrder = function( a, b ) {\n\t\tvar ret = a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1;\n\t\tif ( ret === 0 ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn ret;\n\t};\n} else if ( \"sourceIndex\" in document.documentElement ) {\n\tsortOrder = function( a, b ) {\n\t\tvar ret = a.sourceIndex - b.sourceIndex;\n\t\tif ( ret === 0 ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn ret;\n\t};\n} else if ( document.createRange ) {\n\tsortOrder = function( a, b ) {\n\t\tvar aRange = a.ownerDocument.createRange(), bRange = b.ownerDocument.createRange();\n\t\taRange.selectNode(a);\n\t\taRange.collapse(true);\n\t\tbRange.selectNode(b);\n\t\tbRange.collapse(true);\n\t\tvar ret = aRange.compareBoundaryPoints(Range.START_TO_END, bRange);\n\t\tif ( ret === 0 ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn ret;\n\t};\n}\n\n// Check to see if the browser returns elements by name when\n// querying by getElementById (and provide a workaround)\n(function(){\n\t// We're going to inject a fake input element with a specified name\n\tvar form = document.createElement(\"div\"),\n\t\tid = \"script\" + (new Date).getTime();\n\tform.innerHTML = \"<a name='\" + id + \"'/>\";\n\n\t// Inject it into the root element, check its status, and remove it quickly\n\tvar root = document.documentElement;\n\troot.insertBefore( form, root.firstChild );\n\n\t// The workaround has to do additional checks after a getElementById\n\t// Which slows things down for other browsers (hence the branching)\n\tif ( !!document.getElementById( id ) ) {\n\t\tExpr.find.ID = function(match, context, isXML){\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && !isXML ) {\n\t\t\t\tvar m = context.getElementById(match[1]);\n\t\t\t\treturn m ? m.id === match[1] || typeof m.getAttributeNode !== \"undefined\" && m.getAttributeNode(\"id\").nodeValue === match[1] ? [m] : undefined : [];\n\t\t\t}\n\t\t};\n\n\t\tExpr.filter.ID = function(elem, match){\n\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n\t\t\treturn elem.nodeType === 1 && node && node.nodeValue === match;\n\t\t};\n\t}\n\n\troot.removeChild( form );\n\troot = form = null; // release memory in IE\n})();\n\n(function(){\n\t// Check to see if the browser returns only elements\n\t// when doing getElementsByTagName(\"*\")\n\n\t// Create a fake element\n\tvar div = document.createElement(\"div\");\n\tdiv.appendChild( document.createComment(\"\") );\n\n\t// Make sure no comments are found\n\tif ( div.getElementsByTagName(\"*\").length > 0 ) {\n\t\tExpr.find.TAG = function(match, context){\n\t\t\tvar results = context.getElementsByTagName(match[1]);\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( match[1] === \"*\" ) {\n\t\t\t\tvar tmp = [];\n\n\t\t\t\tfor ( var i = 0; results[i]; i++ ) {\n\t\t\t\t\tif ( results[i].nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( results[i] );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresults = tmp;\n\t\t\t}\n\n\t\t\treturn results;\n\t\t};\n\t}\n\n\t// Check to see if an attribute returns normalized href attributes\n\tdiv.innerHTML = \"<a href='#'></a>\";\n\tif ( div.firstChild && typeof div.firstChild.getAttribute !== \"undefined\" &&\n\t\t\tdiv.firstChild.getAttribute(\"href\") !== \"#\" ) {\n\t\tExpr.attrHandle.href = function(elem){\n\t\t\treturn elem.getAttribute(\"href\", 2);\n\t\t};\n\t}\n\n\tdiv = null; // release memory in IE\n})();\n\nif ( document.querySelectorAll ) (function(){\n\tvar oldSizzle = Sizzle, div = document.createElement(\"div\");\n\tdiv.innerHTML = \"<p class='TEST'></p>\";\n\n\t// Safari can't handle uppercase or unicode characters when\n\t// in quirks mode.\n\tif ( div.querySelectorAll && div.querySelectorAll(\".TEST\").length === 0 ) {\n\t\treturn;\n\t}\n\t\n\tSizzle = function(query, context, extra, seed){\n\t\tcontext = context || document;\n\n\t\t// Only use querySelectorAll on non-XML documents\n\t\t// (ID selectors don't work in non-HTML documents)\n\t\tif ( !seed && context.nodeType === 9 && !isXML(context) ) {\n\t\t\ttry {\n\t\t\t\treturn makeArray( context.querySelectorAll(query), extra );\n\t\t\t} catch(e){}\n\t\t}\n\t\t\n\t\treturn oldSizzle(query, context, extra, seed);\n\t};\n\n\tfor ( var prop in oldSizzle ) {\n\t\tSizzle[ prop ] = oldSizzle[ prop ];\n\t}\n\n\tdiv = null; // release memory in IE\n})();\n\nif ( document.getElementsByClassName && document.documentElement.getElementsByClassName ) (function(){\n\tvar div = document.createElement(\"div\");\n\tdiv.innerHTML = \"<div class='test e'></div><div class='test'></div>\";\n\n\t// Opera can't find a second classname (in 9.6)\n\tif ( div.getElementsByClassName(\"e\").length === 0 )\n\t\treturn;\n\n\t// Safari caches class attributes, doesn't catch changes (in 3.2)\n\tdiv.lastChild.className = \"e\";\n\n\tif ( div.getElementsByClassName(\"e\").length === 1 )\n\t\treturn;\n\n\tExpr.order.splice(1, 0, \"CLASS\");\n\tExpr.find.CLASS = function(match, context, isXML) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && !isXML ) {\n\t\t\treturn context.getElementsByClassName(match[1]);\n\t\t}\n\t};\n\n\tdiv = null; // release memory in IE\n})();\n\nfunction dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {\n\tvar sibDir = dir == \"previousSibling\" && !isXML;\n\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\tvar elem = checkSet[i];\n\t\tif ( elem ) {\n\t\t\tif ( sibDir && elem.nodeType === 1 ){\n\t\t\t\telem.sizcache = doneName;\n\t\t\t\telem.sizset = i;\n\t\t\t}\n\t\t\telem = elem[dir];\n\t\t\tvar match = false;\n\n\t\t\twhile ( elem ) {\n\t\t\t\tif ( elem.sizcache === doneName ) {\n\t\t\t\t\tmatch = checkSet[elem.sizset];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( elem.nodeType === 1 && !isXML ){\n\t\t\t\t\telem.sizcache = doneName;\n\t\t\t\t\telem.sizset = i;\n\t\t\t\t}\n\n\t\t\t\tif ( elem.nodeName === cur ) {\n\t\t\t\t\tmatch = elem;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\telem = elem[dir];\n\t\t\t}\n\n\t\t\tcheckSet[i] = match;\n\t\t}\n\t}\n}\n\nfunction dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {\n\tvar sibDir = dir == \"previousSibling\" && !isXML;\n\tfor ( var i = 0, l = checkSet.length; i < l; i++ ) {\n\t\tvar elem = checkSet[i];\n\t\tif ( elem ) {\n\t\t\tif ( sibDir && elem.nodeType === 1 ) {\n\t\t\t\telem.sizcache = doneName;\n\t\t\t\telem.sizset = i;\n\t\t\t}\n\t\t\telem = elem[dir];\n\t\t\tvar match = false;\n\n\t\t\twhile ( elem ) {\n\t\t\t\tif ( elem.sizcache === doneName ) {\n\t\t\t\t\tmatch = checkSet[elem.sizset];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\tif ( !isXML ) {\n\t\t\t\t\t\telem.sizcache = doneName;\n\t\t\t\t\t\telem.sizset = i;\n\t\t\t\t\t}\n\t\t\t\t\tif ( typeof cur !== \"string\" ) {\n\t\t\t\t\t\tif ( elem === cur ) {\n\t\t\t\t\t\t\tmatch = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {\n\t\t\t\t\t\tmatch = elem;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telem = elem[dir];\n\t\t\t}\n\n\t\t\tcheckSet[i] = match;\n\t\t}\n\t}\n}\n\nvar contains = document.compareDocumentPosition ?  function(a, b){\n\treturn a.compareDocumentPosition(b) & 16;\n} : function(a, b){\n\treturn a !== b && (a.contains ? a.contains(b) : true);\n};\n\nvar isXML = function(elem){\n\treturn elem.nodeType === 9 && elem.documentElement.nodeName !== \"HTML\" ||\n\t\t!!elem.ownerDocument && elem.ownerDocument.documentElement.nodeName !== \"HTML\";\n};\n\nvar posProcess = function(selector, context){\n\tvar tmpSet = [], later = \"\", match,\n\t\troot = context.nodeType ? [context] : context;\n\n\t// Position selectors must be done after the filter\n\t// And so must :not(positional) so we move all PSEUDOs to the end\n\twhile ( (match = Expr.match.PSEUDO.exec( selector )) ) {\n\t\tlater += match[0];\n\t\tselector = selector.replace( Expr.match.PSEUDO, \"\" );\n\t}\n\n\tselector = Expr.relative[selector] ? selector + \"*\" : selector;\n\n\tfor ( var i = 0, l = root.length; i < l; i++ ) {\n\t\tSizzle( selector, root[i], tmpSet );\n\t}\n\n\treturn Sizzle.filter( later, tmpSet );\n};\n\nreturn Sizzle;\n\n})();\n");
jsio.setCachedSrc('../node_modules/jsio/packages/math/geom/Rect.js',"jsio('import lib.Enum');\njsio('import .Point');\njsio('import .Line');\njsio('import .intersect');\n\n/**\n * Model a rectangle.\n */\n\nvar Rect = exports = Class(function() {\n\tthis.init = function(a, b, c, d) {\n\t\tswitch(arguments.length) {\n\t\t\tcase 0: // init\n\t\t\t\tthis.width = this.height = this.x = this.y = 0;\n\t\t\t\tbreak;\n\t\t\tcase 1: // copy\n\t\t\t\tthis.width = a.width;\n\t\t\t\tthis.height = a.height;\n\t\t\t\tthis.x = a.x;\n\t\t\t\tthis.y = a.y;\n\t\t\t\tbreak;\n\t\t\tcase 2: // (x, y), (width, height)\n\t\t\t\tthis.x = a.x;\n\t\t\t\tthis.y = a.y;\n\t\t\t\tthis.width = b.x;\n\t\t\t\tthis.height = b.y;\n\t\t\t\tbreak;\n\t\t\tcase 3: // (x, y), width, height\n\t\t\t\tthis.x = a.x;\n\t\t\t\tthis.y = a.y;\n\t\t\t\tthis.width = b;\n\t\t\t\tthis.height = c;\n\t\t\t\tbreak;\n\t\t\tcase 4: // x, y, width, height\n\t\t\t\tthis.x = a;\n\t\t\t\tthis.y = b;\n\t\t\t\tthis.width = c;\n\t\t\t\tthis.height = d;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Normalize negative height and width dimensions by adjusting the position\n\t * of the rect.\n\t */\n\t\n\tthis.normalize = function() {\n\t\tif (this.width < 0) {\n\t\t\tthis.x -= this.width;\n\t\t\tthis.width = -this.width;\n\t\t}\n\t\t\n\t\tif (this.height < 0) {\n\t\t\tthis.y -= this.height;\n\t\t\tthis.height = -this.height;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Generate the intersection of a rectange with another rectangle.\n\t */\n\n\tthis.intersectRect = function (rect) {\n\t\tif (intersect.isRectAndRect(this, rect)) {\n\t\t\tvar x1 = this.x;\n\t\t\tvar y1 = this.y;\n\t\t\tvar x2 = this.x + this.width;\n\t\t\tvar y2 = this.y + this.height;\n\n\t\t\tthis.x = Math.max(x1, rect.x),\n\t\t\tthis.y = Math.max(y1, rect.y),\n\t\t\tthis.width = Math.min(x2, rect.x + rect.width) - this.x;\n\t\t\tthis.height = Math.min(y2, rect.y + rect.height) - this.y;\n\t\t} else {\n\t\t\tthis.width = 0;\n\t\t\tthis.height = 0;\n\t\t}\n\t}\n\t\n\t/**\n\t * Generate the union of a rectange with another rectangle.\n\t */\n\t\n\tthis.unionRect = function(rect) {\n\t\tthis.normalize();\n\t\tif (rect.normalize) { rect.normalize(); }\n\t\t\n\t\tvar x2 = this.x + this.width,\n\t\t\ty2 = this.y + this.height;\n\t\t\n\t\tvar rx2 = rect.x + rect.width,\n\t\t\try2 = rect.y + rect.height;\n\t\t\n\t\tthis.x = this.x < rect.x ? this.x : rect.x;\n\t\tthis.y = this.y < rect.y ? this.y : rect.y;\n\t\t\n\t\tthis.width = (x2 > rx2 ? x2 : rx2) - this.x;\n\t\tthis.height = (y2 > ry2 ? y2 : ry2) - this.y;\n\t};\n\n\t/**\n\t * Get a point for the given corner.\n\t */\n\t\n\tthis.getCorner = function(i) {\n\t\tswitch(i) {\n\t\t\tcase CORNERS.TOP_LEFT:\n\t\t\t\treturn new Point(this.x, this.y);\n\t\t\tcase CORNERS.TOP_RIGHT:\n\t\t\t\treturn new Point(this.x + this.width, this.y);\n\t\t\tcase CORNERS.BOTTOM_LEFT:\n\t\t\t\treturn new Point(this.x, this.y + this.height);\n\t\t\tcase CORNERS.BOTTOM_RIGHT:\n\t\t\t\treturn new Point(this.x + this.width, this.y + this.height);\n\t\t}\n\t}\n\t\n\t/**\n\t * Return a line corresponding to the given side.\n\t */\n\t\n\tthis.getSide = function(i) {\n\t\tswitch(i) {\n\t\t\tcase SIDES.TOP:\n\t\t\t\treturn new Line(this.getCorner(CORNERS.TOP_LEFT), this.getCorner(CORNERS.TOP_RIGHT));\n\t\t\tcase SIDES.RIGHT:\n\t\t\t\treturn new Line(this.getCorner(CORNERS.TOP_RIGHT), this.getCorner(CORNERS.BOTTOM_RIGHT));\n\t\t\tcase SIDES.BOTTOM:\n\t\t\t\treturn new Line(this.getCorner(CORNERS.BOTTOM_RIGHT), this.getCorner(CORNERS.BOTTOM_LEFT));\n\t\t\tcase SIDES.LEFT:\n\t\t\t\treturn new Line(this.getCorner(CORNERS.BOTTOM_LEFT), this.getCorner(CORNERS.TOP_LEFT));\n\t\t}\n\t}\n\n\t/**\n\t * Return the center point of a rectangle.\n\t */\n\t\n\tthis.getCenter = function() {\n\t\treturn new Point(this.x + this.width / 2, this.y + this.height / 2);\n\t}\n});\n\nvar SIDES = Rect.SIDES = lib.Enum('TOP', 'BOTTOM', 'LEFT', 'RIGHT');\nvar CORNERS = Rect.CORNERS = lib.Enum('TOP_LEFT', 'TOP_RIGHT', 'BOTTOM_RIGHT', 'BOTTOM_LEFT');\n");
jsio.setCachedSrc('../node_modules/jsio/packages/lib/Enum.js',"exports = function() {\n\tif (arguments.length == 1) {\n\t\tif (typeof arguments[0] == 'object') {\n\t\t\tvar obj = arguments[0];\n\t\t\tfor (var i in obj) {\n\t\t\t\tif (!(obj[i] in obj)) {\n\t\t\t\t\tobj[obj[i]] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn obj;\n\t\t} else if (typeof arguments[0] != 'string') {\n\t\t\tkeys = arguments[0];\n\t\t}\n\t}\n\t\n\tif (!keys) { var keys = arguments; }\n\tvar obj = {};\n\tfor(var i = 0, len = keys.length; i < len; ++i) {\n\t\tif (keys[i]) {\n\t\t\tobj[keys[i]] = i + 1;\n\t\t}\n\t\tobj[i + 1] = keys[i];\n\t}\n\treturn obj;\n}");
jsio.setCachedSrc('../node_modules/jsio/packages/math/geom/Point.js',"/**\n * @package math.geom.Point;\n * Models a Point in 2D space.\n */\n\nvar Point = exports = Class(function() {\n\tthis.init = function(a, b) {\n\t\tswitch(arguments.length) {\n\t\t\tcase 0:\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tthis.x = a.x || 0;\n\t\t\t\tthis.y = a.y || 0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tthis.x = a || 0;\n\t\t\t\tthis.y = b || 0;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Rotates this point around the origin by a value in radians.\n\t */\n\t\n\tthis.rotate = function(r) {\n\t\tvar x = this.x,\n\t\t\ty = this.y,\n\t\t\tcosr = Math.cos(r),\n\t\t\tsinr = Math.sin(r);\n\t\t\n\t\tthis.x = x * cosr - y * sinr;\n\t\tthis.y = x * sinr + y * cosr;\n\t\t\n\t\treturn this;\n\t}\n\n\t/**\n\t * Translate this point by two scalars or by another point.\n\t */\n\t\n\tthis.translate = this.add = function(x, y) {\n\t\tif (typeof x == 'number') {\n\t\t\tthis.x += x;\n\t\t\tthis.y += y;\n\t\t} else {\n\t\t\tthis.x += x.x;\n\t\t\tthis.y += x.y;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Subtract this point by two scalars or by another point.\n\t */\n\t\n\tthis.subtract = function(x, y) {\n\t\tif (typeof x == 'number') {\n\t\t\tthis.x -= x;\n\t\t\tthis.y -= y;\n\t\t} else {\n\t\t\tthis.x -= x.x;\n\t\t\tthis.y -= x.y;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Scale this number.\n\t */\n\n\tthis.scale = function(sx, sy) {\n\t\t//if no scaleY specified\n\t\tif(sy === undefined) sy = sx;\n\n\t\tthis.x *= sx;\n\t\tthis.y *= sy;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the magnitude of this point at a constant angle.\n\t */\n\t\n\tthis.setMagnitude = function(m) {\n\t\tvar theta = this.getAngle();\n\t\tthis.x = m * Math.cos(theta);\n\t\tthis.y = m * Math.sin(theta);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Normalize this point to the unit circle.\n\t */\n\t\n\tthis.normalize = function() {\n\t\tvar m = this.getMagnitude();\n\t\tthis.x /= m;\n\t\tthis.y /= m;\n\t\treturn this;\n\t};\n\n\t/**\n\t * Add magnitude to this point.\n\t */\n\t\n\tthis.addMagnitude = function(m) {\n\t\treturn this.setMagnitude(this.getMagnitude() + m);\n\t};\n\n\tthis.getMagnitude = function() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\n\t};\n\n\tthis.getSquaredMagnitude = function() {\n\t\treturn this.x * this.x + this.y * this.y;\n\t};\n\n\tthis.getDirection = this.getAngle = function() {\n\t\treturn Math.atan2(this.y, this.x);\n\t};\n\t\n});\n\n/*\n */\nPoint.getPolarR = function(x, y) { \n\tthrow \"notImplemented\";\n}\n\n/*\n\t### Class Method: Point.getPolarTheta (x, y)\n\t1. `x {number}`\n\t2. `y {number}`\n\t3. Return: `{number}`\n*/\nPoint.getPolarTheta = function(x, y) { \n\tvar val = Math.atan2(y,x) + (Math.PI * 2); \n\treturn val > Math.PI * 2 ? val % (Math.PI * 2) : val;\n}\n\n/*\n\t### Class Method: Point.add (a, b, c, d)\n\t### Class Method: Point.translate (a, b, c, d)\n\t1. `a {number}`\n\t2. `b {number}`\n\t3. `c {number}`\n\t4. `d {number}`\n\t5. Return: `{Point}`\n */\nPoint.add = Point.translate = function(a, b, c, d) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).add(b);\n\t\tcase 3: return new Point(a).add(b, c);\n\t\tcase 4: return new Point(a, b).add(c, d);\n\t}\n}\n\n/*\n\t### Class Method: Point.subtract (a, b, c, d)\n\t1. `a {number}`\n\t2. `b {number}`\n\t3. `c {number}`\n\t4. `d {number}`\n\t5. Return: `{Point}`\n */\nPoint.subtract = function(a, b, c, d) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).subtract(b);\n\t\tcase 3: return new Point(a).subtract(b, c);\n\t\tcase 4: return new Point(a, b).subtract(c, d);\n\t}\n}\n\n/*\n\t### Class Method: Point.scale (a, b, c) \n\t1. `a {number}`\n\t2. `b {number}`\n\t3. `c {number}`\n\t4. Return: `{Point}`\n */\nPoint.scale = function(a, b, c) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).scale(b);\n\t\tcase 3: return new Point(a, b).scale(c);\n\t}\n}\n\n/*\n\t### Class Method: Point.setMagnitude (a, b, c)\n\t1. `a {number}`\n\t2. `b {number}`\n\t3. `c {number}`\n\t4. Return: `{Point}`\n*/\nPoint.setMagnitude = function(a, b, c) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).setMagnitude(c);\n\t\tcase 3: return new Point(a, b).setMagnitude(c);\n\t}\n}\n\n/*\n\t### Class Method: Point.addMagnitude (a, b, c)\n\t1. `a {number}`\n\t2. `b {number}`\n\t3. `c {number}`\n\t4. Return: `{Point}`\n */\nPoint.addMagnitude = function(a, b, c) {\n\tswitch(arguments.length) {\n\t\tcase 2: pt = new Point(a); break;\n\t\tcase 3: pt = new Point(a, b); b = c; break;\n\t}\n\t\n\treturn pt.addMagnitude(b);\n}\n\n/*\n\t### Class Method: Point.getMagnitude (a, b)\n\t1. `a {number}`\n\t2. `b {number}`\n\t3. Return: `{Point}`\n */\nPoint.getMagnitude = function(a, b) { return new Point(a, b).getMagnitude(); }\n\n/*\n\t### Class Method: Point.rotate (a, b, c)\n\t1. `a {number}`\n\t2. `b {number}`\n\t3. `c {number}`\n\t4. Return: `{Point}`\n */\nPoint.rotate = function(a, b, c) {\n\tswitch(arguments.length) {\n\t\tcase 2: return new Point(a).rotate(b);\n\t\tcase 3: return new Point(a, b).rotate(c);\n\t}\n}\n\n/**\n * Treat two points as vectors and project a onto b\n *  (a dot unit(b)) * unit(b)\n */\nPoint.project = function (a, b) {\n\tvar unitB = new Point(b).normalize();\n\treturn unitB.scale(unitB.x * a.x + unitB.y * a.y);\n}\n");
jsio.setCachedSrc('../node_modules/jsio/packages/math/geom/Line.js',"jsio('import .Point');\n\nexports = Class(function() {\n\tthis.init = function(a, b, c, d) {\n\t\tswitch(arguments.length) {\n\t\t\tcase 0:\n\t\t\t\tthis.start = new Point();\n\t\t\t\tthis.end = new Point();\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tthis.start = new Point(a.start);\n\t\t\t\tthis.end = new Point(a.end);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tthis.start = new Point(a);\n\t\t\t\tthis.end = new Point(b);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tthis.start = new Point(a);\n\t\t\t\tthis.end = new Point(b, c);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\tdefault:\n\t\t\t\tthis.start = new Point(a, b);\n\t\t\t\tthis.end = new Point(c, d);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tthis.getMagnitude = \n\tthis.getLength = function() {\n\t\tvar dx = this.end.x - this.start.x,\n\t\t\tdy = this.end.y - this.start.y;\n\t\t\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n});\n");
jsio.setCachedSrc('../node_modules/jsio/packages/math/geom/intersect.js',"jsio('import .Point');\njsio('import .Line');\njsio('import .Rect');\n\n/**\n * @package math.geom.intersect\n */\nvar intersect = exports;\n\nintersect.pointAndRect = intersect.ptAndRect = function (pt, rect) {\n\tvar x = pt.x,\n\t\t\ty = pt.y;\n\treturn (x >= rect.x &&\n\t\t\t\t\tx <= rect.x + rect.width &&\n\t\t\t\t\ty >= rect.y &&\n\t\t\t\t\ty <= rect.y + rect.height);\n};\n\nintersect.rectAndPoint = intersect.rectAndPt = function (rect, pt) {\n\treturn intersect.pointAndRect(pt, rect);\n};\n\nintersect.pointAndCircle = intersect.ptAndCirc = function(pt, circle) {\n\tvar dx = pt.x - circle.x,\n\t\t\tdy = pt.y - circle.y;\n\treturn dx * dx + dy * dy < circle.radius * circle.radius;\n};\n\nintersect.circleAndPoint = intersect.circAndPt = function (circle, pt) {\n\treturn intersect.pointAndCircle(pt, circle);\n};\n\nintersect.circleAndCircle = function(circle1, circle2) {\n\tvar dx = circle2.x - circle1.x,\n\t\tdy = circle2.y - circle1.y;\n\tvar radiusSum = circle1.radius + circle2.radius;\n\treturn dx * dx + dy * dy <= radiusSum * radiusSum;\n};\n\nintersect.isRectAndRect = function (rect1, rect2) {\n\treturn !((rect1.y + rect1.height < rect2.y) ||\n\t\t\t\t\t (rect2.y + rect2.height < rect1.y) ||\n\t\t\t\t\t (rect1.x + rect1.width < rect2.x) ||\n\t\t\t\t\t (rect2.x + rect2.width < rect1.x));\n};\n\nintersect.circleAndRect = function(circle, rect) {\n\tif (intersect.pointAndRect(circle, rect)) {\n\t\treturn true;\n\t}\n\treturn (intersect.lineAndCircle(rect.getSide(1), circle) ||\n\t\t\t\t\tintersect.lineAndCircle(rect.getSide(2), circle) ||\n\t\t\t\t\tintersect.lineAndCircle(rect.getSide(3), circle) ||\n\t\t\t\t\tintersect.lineAndCircle(rect.getSide(4), circle));\n};\n\nintersect.rectAndCircle = function(rect, circle) {\n\treturn intersect.circleAndRect(circle, rect);\n};\n\nintersect.lineAndCircle = function (line, circle) {\n\tvar vec = intersect.pointToLine(circle, line);\n\treturn vec.getMagnitude() < circle.radius;\n};\n\nintersect.circleAndLine = function (circle, line) {\n\treturn intersect.lineAndCircle(line, circle);\n};\n\n// returns line from pt to nearest pt on line\nintersect.pointToLine = intersect.ptToLine = function (pt, line) {\n\tvar dx = (line.end.x - line.start.x),\n\t\t\tdy = (line.end.y - line.start.y),\n\t\t\tu = ((pt.x - line.start.x) * dx\t// TODO can we abstract this from 2D to 2D/3D?\n\t\t\t\t\t + (pt.y - line.start.y) * dy) / (dx * dx + dy * dy);\n\n\tvar i;\n\tif (u < 0) {\n\t\ti = new Point(line.start);\n\t} else if (u > 1) {\n\t\ti = new Point(line.end);\n\t} else {\n\t\ti = new Point(line.start.x + u * dx, line.start.y + u * dy);\n\t}\n\treturn new Line(i, pt);\n};\n\n// returns rectangle of intersection\nintersect.rectAndRect = function (rect1, rect2) {\n\tjsio('import .Rect');\n\treturn (intersect.rectAndRect = function(rect1, rect2) {\n\t\tif (rect1 === true) { return new Rect(rect2); }\n\t\tif (rect2 === true) { return new Rect(rect2); }\n\n\t\tif (intersect.isRectAndRect(rect1, rect2)) {\n\t\t\tvar x1 = Math.max(rect1.x, rect2.x),\n\t\t\t\t\ty1 = Math.max(rect1.y, rect2.y),\n\t\t\t\t\tx2 = Math.min(rect1.x + rect1.width, rect2.x + rect2.width),\n\t\t\t\t\ty2 = Math.min(rect1.y + rect1.height, rect2.y + rect2.height);\n\t\t\treturn new Rect(x1, y1, x2 - x1, y2 - y1);\n\t\t}\n\t\treturn null;\n\t})(rect1, rect2);\n}\n");
jsio.setCachedSrc('../node_modules/jsio/packages/util/path.js',"var util = jsio.__jsio.__util;\n\nexports.join = util.buildPath;\nexports.resolveRelativePath = util.resolveRelativePath;\nexports.splitPath = util.splitPath;\nexports.relative = util.relative;\nexports.splitExt = function(path) {\n\tvar res = exports.splitPath(path);\n\tvar i = res.filename.lastIndexOf('.');\n\tif (i == -1) {\n\t\tres.basename = res.filename;\n\t\tres.ext = '';\n\t} else {\n\t\tres.basename = res.filename.substring(0, i);\n\t\tres.ext = res.filename.substring(i);\n\t}\n\treturn res;\n}\n");
jsio.setCachedSrc('../node_modules/squill/Alpha.js',"jsio('from util.browser import $');\njsio('import .Widget');\n\njsio('import .jscolor.jscolor as jscolor');\n\nvar alphaSelect = false,\n\talphaIndicator;\n\nvar Alpha = exports = Class(Widget, function(supr) {\n\tthis._css = 'lph';\n\tthis._type = 'text';\n\n\tthis.init = function(params) {\n\t\tparams = merge(params, {tag: 'input'});\n\t\tsupr(this, 'init', [params]);\n\t};\n\n\tthis.buildWidget = function() {\n\t\tvar el = this._el;\n\n\t\tel.widget = this;\n\n\t\t$.onEvent(el, 'focus', this, '_onFocus');\n\t\t$.onEvent(el, 'blur', this, '_onBlur');\n\t\t$.onEvent(el, 'change', this, '_onChange');\n\n\t\tvar alphaGradient,\n\t\t\tctx,\n\t\t\tstyle,\n\t\t\trect;\n\n\t\tif (!alphaSelect) {\n\t\t\talphaSelect = document.createElement('div');\n\t\t\talphaSelect.style.display = 'none';\n\t\t\talphaSelect.className = 'colorMenu';\n\t\t\tdocument.body.appendChild(alphaSelect);\n\n\t\t\t$.onEvent(alphaSelect, 'mousedown', this, '_onSelect');\n\n\t\t\talphaGradient = document.createElement('canvas');\n\t\t\talphaGradient.width = 20;\n\t\t\talphaGradient.height = 100;\n\t\t\talphaSelect.appendChild(alphaGradient);\n\n\t\t\t$.style(\n\t\t\t\talphaGradient,\n\t\t\t\t{\n\t\t\t\t\t'float': 'left',\n\t\t\t\t\twidth: '20px',\n\t\t\t\t\theight: '100px',\n\t\t\t\t\tmargin: '8px 0 0 12px',\n\t\t\t\t\tborder: '1px solid #000',\n\t\t\t\t\tborderColor: 'ThreeDShadow ThreeDHighlight ThreeDHighlight ThreeDShadow',\n\t\t\t\t\tbackgroundColor: 'red'\n\t\t\t\t}\n\t\t\t);\n\t\t\t$.onEvent(alphaGradient, 'mousedown', this, '_onMouseDown');\n\t\t\t$.onEvent(alphaGradient, 'mousemove', this, '_onMouseMove');\n\t\t\t$.onEvent(alphaGradient, 'mouseup', this, '_onMouseUp');\n\t\t\t$.onEvent(alphaGradient, 'mouseout', this, '_onMouseOut');\n\n\t\t\talphaIndicator = document.createElement('img');\n\t\t\talphaIndicator.src = 'img/colorpicker/arrow.gif';\n\t\t\talphaSelect.appendChild(alphaIndicator);\n\n\t\t\t$.style(\n\t\t\t\talphaIndicator,\n\t\t\t\t{\n\t\t\t\t\tposition: 'absolute',\n\t\t\t\t\tleft: '4px',\n\t\t\t\t\ttop: '2px',\n\t\t\t\t\tborder: '0px hidden'\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tctx = alphaGradient.getContext('2d');\n\t\t\tlinearGradient = ctx.createLinearGradient(0, 0, 0, 100);\n\t\t\tlinearGradient.addColorStop(0, '#FFFFFF');\n\t\t\tlinearGradient.addColorStop(1, '#000000');\n\t\t\tctx.fillStyle = linearGradient;\n\t\t\tctx.fillRect(0, 0, 20, 100);\n\t\t}\n\t};\n\n\tthis._showIndicator = function(alpha) {\n\t\tif (alpha < 0) {\n\t\t\talpha = 0;\n\t\t}\n\t\tif (alpha > 100) {\n\t\t\talpha = 100;\n\t\t}\n\n\t\t$.style(\n\t\t\talphaIndicator,\n\t\t\t{\n\t\t\t\tposition: 'absolute',\n\t\t\t\tleft: '4px',\n\t\t\t\ttop: (2 + alpha) + 'px',\n\t\t\t\tborder: '0px hidden'\n\t\t\t}\n\t\t);\n\n\t\treturn alpha;\n\t};\n\n\tthis._showMouseAlpha = function(evt) {\n\t\talphaSelect.target.value = 100 - this._showIndicator(evt.offsetY);\n\t\talphaSelect.widget.publish('Change', parseInt(alphaSelect.target.value, 10));\n\t};\n\n\tthis._onChange = function(evt) {\n\t\tvar value = this._el.value;\n\t\tif (!isNaN(value)) {\n\t\t\tvalue = parseInt(value, 10);\n\t\t\tif ((value >= 0) && (value <= 100)) {\n\t\t\t\talphaSelect.widget.publish('Change', value);\n\t\t\t}\n\t\t}\n\t};\n\n\tthis._onFocus = function(evt) {\n\t\tvar alpha,\n\t\t\tstyle = alphaSelect.style,\n\t\t\trect = this._el.getBoundingClientRect(),\n\t\t\tx = rect.right + 4,\n\t\t\ty = rect.top;\n\n\t\tif (y + 122 > window.innerHeight) {\n\t\t\ty = rect.bottom - 122;\n\t\t}\n\t\tif (x + 44 > window.innerWidth) {\n\t\t\tx = rect.left - 48;\n\t\t}\n\n\t\t$.style(\n\t\t\talphaSelect,\n\t\t\t{\n\t\t\t\tposition: 'absolute',\n\t\t\t\twidth: '44px',\n\t\t\t\theight: '122px',\n\t\t\t\tzIndex: '1000000',\n\t\t\t\tleft: x + 'px',\n\t\t\t\ttop: y + 'px',\n\t\t\t\tdisplay: 'block'\n\t\t\t}\n\t\t);\n\n\t\talphaSelect.widget = evt.target.widget;\n\t\talphaSelect.target = evt.target;\n\n\t\tif (isNaN(alphaSelect.target.value)) {\n\t\t\talpha = 0;\n\t\t} else {\n\t\t\talpha = parseInt(alphaSelect.target.value, 10);\n\t\t}\n\t\tthis._showIndicator(100 - alpha);\n\t};\n\n\tthis._onBlur = function(evt) {\n\t\talphaSelect.style.display = 'none';\n\t};\n\n\tthis._onSelect = function(evt) {\n\t\t$.stopEvent(evt);\n\t};\n\n\tthis._onMouseDown = function(evt) {\n\t\t$.stopEvent(evt);\n\t\tthis._showMouseAlpha(evt);\n\t\tthis._mouseDown = true;\n\t};\n\n\tthis._onMouseMove = function(evt) {\n\t\tif (this._mouseDown) {\n\t\t\tthis._showMouseAlpha(evt);\n\t\t}\n\t\t$.stopEvent(evt);\n\t};\n\n\tthis._onMouseOut = function(evt) {\n\t\tthis._mouseDown = false;\n\t\t$.stopEvent(evt);\n\t};\n\n\tthis._onMouseUp = function(evt) {\n\t\tthis._mouseDown = false;\n\t\t$.stopEvent(evt);\n\t};\n\n\tthis.setValue = function(value) {\n\t\tthis._el.value = value;\n\t};\n\n\tthis.getValue = function() {\n\t\treturn this._el.value;\n\t};\n});\n\n");
jsio.setCachedSrc('../node_modules/squill/Widget.js',"jsio('from util.browser import $');\njsio('import .Element, .Events, .global');\njsio('import .i18n');\njsio('import .Delegate');\njsio('import .models.Model as Model');\njsio('import .models.bindings as bindings');\n\njsio('from .__imports__ import classes as WIDGET_CLASSES');\n\nvar uid = 0;\n\nfunction shallowCopy(p) {\n\tvar o = {};\n\tfor(var i in p) {\n\t\tif(p.hasOwnProperty(i)) {\n\t\t\to[i] = p[i];\n\t\t}\n\t}\n\treturn o;\n}\n\nvar WidgetSet = Class(function () {\n\tthis.init = function (target) {\n\t\tthis._target = target;\n\t\tthis.events = [];\n\t}\n\n\tthis.getTarget = function () { return this._target; }\n\n\tthis.hasWidget = function (id) { return !!this._target[id]; };\n\n\tthis.addWidget = function (id, widget) {\n\t\tthis._target[id] = widget;\n\t};\n\n\tthis.addSubscription  = function(widget, signal /* ... args */) {\n\t\tif (this._target.dispatchEvent) {\n\t\t\twidget.subscribe.apply(widget, [signal, this._target,\n\t\t\t\t'dispatchEvent', widget.getId()]\n\t\t\t\t\t.concat(Array.prototype.slice.call(arguments, 2)));\n\t\t}\n\t}\n});\n\nvar Widget = exports = Class([Element, Events], function() {\n\tthis._css = 'widget';\n\tthis._name = '';\n\n\tthis.__getDef__ = function () {\n\t\tvar cls = this.constructor;\n\t\tvar def = {};\n\n\t\tdo {\n\t\t\tif (cls.prototype.hasOwnProperty('_def')) {\n\t\t\t\tcopyDef(cls.prototype._def);\n\t\t\t}\n\t\t} while ((cls = cls.prototype.__parentClass__));\n\n\t\t// handle base _def\n\t\tif (this.hasOwnProperty('_def')) {\n\t\t\tcopyDef(this._def);\n\t\t}\n\n\t\tfunction copyDef (src) {\n\t\t\tfor (var key in src) {\n\t\t\t\tif (key == 'attrs' || key == 'style') {\n\t\t\t\t\tdef[key] = merge(def[key], src[key]);\n\t\t\t\t} else if (key == 'className' && def.className) {\n\t\t\t\t\tdef.className = src.className + ' ' + def.className;\n\t\t\t\t} else if (key == 'children') {\n\t\t\t\t\tif (!def.children) {\n\t\t\t\t\t\tdef.children = [src.children];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdef.children.push(src.children);\n\t\t\t\t\t}\n\t\t\t\t} else if (!def.hasOwnProperty(key)) {\n\t\t\t\t\tdef[key] = src[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn def;\n\t}\n\n\tthis.init = function(opts) {\n\t\topts = opts || {};\n\n\t\tthis._children = [];\n\n\t\t// ===\n\t\t// merge this._def and opts\n\n\t\tvar def = this._def = this.__getDef__();\n\n\t\tthis._id = def.id;\n\n\t\tthis.__model = new Model(opts.model || def.model);\n\n\t\t// className merges\n\t\tif (def.className) {\n\t\t\topts.className = opts.className ? opts.className + \" \" + def.className : def.className;\n\t\t}\n\n\t\tif (def.attrs) {\n\t\t\topts.attrs = merge(opts.attrs, def.attrs);\n\t\t}\n\n\t\tif (def.style) {\n\t\t\topts.style = merge(opts.style, def.style);\n\t\t}\n\n\t\t// opts take precedence over def\n\t\tthis._opts = opts;\n\t\tfor (var name in def) {\n\t\t\tif (name != 'children' && !opts.hasOwnProperty(name) && def.hasOwnProperty(name)) {\n\t\t\t\topts[name] = def[name];\n\t\t\t}\n\t\t}\n\n\t\t// delete opts.children;\n\n\t\t// end merge\n\t\t// ===\n\n\t\tif (opts.name) { this._name = opts.name; }\n\t\tif (opts.delegate) { this.delegate = opts.delegate; }\n\n\t\tvar widgetParent;\n\t\tvar buildNow = false;\n\t\tif (opts.widgetParent) {\n\t\t\twidgetParent = opts.widgetParent;\n\t\t}\n\n\t\tthis.controller = opts.controller || widgetParent;\n\n\t\tif (opts.parent) {\n\t\t\tvar parent = opts.parent;\n\t\t\tvar isWidgetParent = parent instanceof Widget;\n\t\t\tif (isWidgetParent) {\n\t\t\t\tif (!widgetParent) {\n\t\t\t\t\twidgetParent = opts.parent;\n\t\t\t\t}\n\n\t\t\t\topts.parent = parent.getContainer();\n\t\t\t} else if (!parent.appendChild) {\n\t\t\t\tdelete opts.parent;\n\t\t\t}\n\t\t}\n\n\t\tif (widgetParent) {\n\t\t\twidgetParent.addWidget(this);\n\t\t} else if (opts.parent || opts.el) {\n\t\t\tthis.build(opts.el);\n\t\t}\n\t};\n\n\tthis.getOpts = function () { return this._opts; }\n\n\tthis.getId = function () {\n\t\treturn this._id || (this._el && this._el.id);\n\t}\n\n\tthis.build = function (el) {\n\t\tif (!this._el || this._el != el) {\n\t\t\tvar opts = this._opts;\n\t\t\tvar children = opts.children;\n\n\t\t\tif (children) { delete opts.children; }\n\t\t\tthis._el = $.create(this._opts);\n\t\t\tif (children) { opts.children = children; }\n\n\t\t\tthis.buildContent();\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tthis.getParent = function() { return this._el && this._el.parentNode; };\n\tthis.getWidgetParent = function () { return this._widgetParent; }\n\n\tthis.setWidgetParent = function (parent) {\n\t\tif (this._widgetParent != parent) {\n\t\t\tthis._widgetParent.removeWidget(this);\n\t\t\tparent.addWidget(this);\n\t\t\tthis._widgetParent = parent;\n\t\t}\n\t}\n\n\tthis.getChildren = function() {\n\t\treturn this._children;\n\t};\n\n\tthis.forEachDescend = function (cb, ctx) {\n\t\tvar n = this._children.length;\n\t\tfor (var i = 0; i < n; ++i) {\n\t\t\tvar child = this._children[i];\n\t\t\tcb.call(ctx, child);\n\t\t\tif (child.forEachDescend) {\n\t\t\t\tchild.forEachDescend(cb, ctx);\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.getFirstChild = function() {\n\t\treturn (this._children && this._children.length) ? this._children[0] : null;\n\t};\n\n\tthis.dispatchEvent = function (id, evt) {\n\t\tthis.delegate.apply(this, arguments);\n\t};\n\n\tthis.addElement = function (el) {\n\t\tthis._el.appendChild(el);\n\t}\n\n\tthis.addWidget = function(def, parent, result) {\n\t\tif (!this._el) { this.build(); }\n\n\t\tparent = def.parent || parent || this.getContainer() || this._el;\n\n\t\t// def is either a Widget or a definition for a Widget\n\t\tif (!(def instanceof Widget)) {\n\t\t\t// if it is not yet a widget, make it (or make a DOM node)\n\t\t\tvar opts = merge({}, def, {parent: parent, __result: result});\n\t\t\tif (opts.children) {\n\t\t\t\tvar children = opts.children;\n\t\t\t\tdelete opts.children;\n\t\t\t}\n\n\t\t\tvar el;\n\t\t\tif ('type' in opts && !opts.type) {\n\t\t\t\tlogger.warn('Did you forget to provide a type?', opts);\n\t\t\t}\n\n\t\t\tif (!opts.type || typeof opts.type == 'string') {\n\t\t\t\tif (WIDGET_CLASSES[opts.type]) {\n\t\t\t\t\tvar Constructor = jsio('import ' + WIDGET_CLASSES[opts.type]);\n\t\t\t\t\tel = new Constructor(opts);\n\t\t\t\t} else if (!result) {\n\t\t\t\t\tel = new Widget(opts);\n\t\t\t\t} else {\n\t\t\t\t\tif (opts.type == 'image') {\n\t\t\t\t\t\topts = merge({tag: 'img'}, opts);\n\t\t\t\t\t}\n\t\t\t\t\tel = $(opts);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tel = new opts.type(opts);\n\t\t\t}\n\n\t\t\tif (result && opts.id && !result.hasWidget(opts.id)) {\n\t\t\t\tresult.addWidget(opts.id, el);\n\t\t\t}\n\t\t} else {\n\t\t\tel = def;\n\t\t}\n\n\t\tif (el instanceof Widget) {\n\t\t\tif (el.getWidgetParent() != this) {\n\t\t\t\tvar prevParent = el.getWidgetParent();\n\t\t\t\tif (prevParent) {\n\t\t\t\t\tprevParent.removeWidget(this);\n\t\t\t\t}\n\n\t\t\t\tel._widgetParent = this;\n\t\t\t\tif (!el.controller) {\n\t\t\t\t\tel.controller = this;\n\t\t\t\t}\n\n\t\t\t\tthis._children.push(el);\n\t\t\t}\n\n\t\t\tif (el.getParent() != parent) {\n\t\t\t\tel.setParent(parent);\n\t\t\t}\n\t\t}\n\n\t\tif (children) {\n\t\t\tif (el.buildChildren) {\n\t\t\t\tif (!result) { result = new WidgetSet(el); }\n\t\t\t\tel.buildChildren(children, null, result);\n\t\t\t} else {\n\t\t\t\tfor (var i = 0, c; c = children[i]; ++i) {\n\t\t\t\t\tthis.addWidget(c, el, result);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn el;\n\t};\n\n\tthis.removeWidget = function (widget) {\n\t\tvar index = this._children.indexOf(widget);\n\t\tif (index >= 0) {\n\t\t\tthis._children.splice(index, 1);\n\t\t}\n\t}\n\n\tthis.getContainer = function () { return this._el; };\n\tthis.getName = function () { return this._name; };\n\tthis.setName = function (name) { this._name = name; };\n\n\tthis.buildContent = function() {\n\t\tvar opts = this._opts;\n\n\t\tif (global.getWidgetPrefix() !== null) {\n\t\t\t$.addClass(this._el, global.getWidgetPrefix() + this._css);\n\t\t}\n\n\t\tif (!this.delegate) { this.delegate = new Delegate(); }\n\n\t\t// TODO: what's this doing here?\n\t\tif (opts.errorLabel) {\n\t\t\tthis._errorLabel = $.create({html: opts.errorLabel, className: global.getWidgetPrefix() + 'textInputErrorLabel', parent: this._el});\n\t\t}\n\n\t\t// def items always go on the widget\n\t\tvar def = this._def;\n\n\t\t// build each set of children separately so the parent container can\n\t\t// be checked/recomputed after each set\n\t\tif (def.children) {\n\t\t\tvar localRes = new WidgetSet(this);\n\t\t\tfor (var i = def.children.length - 1; i >= 0; --i) {\n\t\t\t\tthis.buildChildren(def.children[i], null, localRes);\n\t\t\t}\n\t\t}\n\n\t\t// primary target for opts children is the result passed in\n\t\tvar result = opts.__result || localRes || new WidgetSet(this);\n\n\t\t// opts items sometimes go on the widget\n\t\tif (opts.children) {\n\t\t\tthis.buildChildren(opts.children, null, result);\n\t\t}\n\n\t\tif (opts.data && this.setData) { bindings.parseData(this, opts.data); }\n\n\t\tthis.buildWidget(this._el, result);\n\t};\n\n\tthis.buildChildren = function (children, parent, result) {\n\t\tif (!parent) { parent = this.getContainer() || this._el; }\n\n\t\tfor (var i = 0, n = children.length; i < n; ++i) {\n\t\t\tthis.addWidget(children[i], parent, result);\n\t\t}\n\t};\n\n\tthis.buildWidget = function() {};\n\n\t// TODO: what's this doing here?\n\tthis.errors = function() {\n\t\treturn this.validators.map(function(item){\n\t\t\tif (item.isValid == false){\n\t\t\t\treturn item.message;\n\t\t\t}\n\t\t});\n\t};\n\n\t// TODO: what's this doing here?\n\tthis.validate = function() {\n\t\tvar isValid = true;\n\t\tfor (var i = 0, len = this.validators.length; i < len; ++i) {\n\t\t\tvar v = this.validators[i];\n\t\t\tisValid = isValid && (v.isValid = v.call(this));\n\t\t}\n\t\treturn (this._isValid = isValid);\n\t};\n\n\t// TODO: what's this doing here?\n\tthis._isValid = true;\n\tthis.isValid = function() { return this._isValid; }\n\tthis.validators = [];\n\n\tthis.getI18n = function(key, id) {\n\t\tvar src = key in this._opts\n\t\t\t? this._opts\n\t\t\t: i18n.get(id || this._opts.id);\n\n\t\treturn src && src[key] || '';\n\t};\n\n\tthis.getElement = function() {\n\t\tif (!this._el) { this.build(); }\n\t\treturn this._el;\n\t};\n\n\tthis.addClass = function (cls) { $.addClass(this._el, cls); }\n\tthis.removeClass = function (cls) { $.removeClass(this._el, cls); }\n\tthis.hasClass = function (cls) {\n\t\treturn (' ' + this._el.className + ' ').indexOf(cls) >= 0;\n\t}\n\tthis.toggleClass = function (cls, isToggled) {\n\t\tif (isToggled === undefined) {\n\t\t\tisToggled = !this.hasClass(cls);\n\t\t}\n\n\t\tif (isToggled) {\n\t\t\tthis.addClass(cls);\n\t\t} else {\n\t\t\tthis.removeClass(cls);\n\t\t}\n\t}\n\n\tthis.onBeforeShow = function() {\n\t\tfor (var i = 0, child; child = this._children[i]; ++i) {\n\t\t\tchild.onBeforeShow.apply(child, arguments);\n\t\t}\n\t};\n\n\tthis.onShow = function() {\n\t\tthis._isShowing = true;\n\t\tfor (var i = 0, child; child = this._children[i]; ++i) {\n\t\t\tchild.onShow.apply(child, arguments);\n\t\t}\n\t};\n\n\tthis.onBeforeHide = function() {\n\t\tfor (var i = 0, child; child = this._children[i]; ++i) {\n\t\t\tchild.onBeforeHide.apply(child, arguments);\n\t\t}\n\t};\n\n\tthis.onHide = function() {\n\t\tthis._isShowing = false;\n\t\tfor (var i = 0, child; child = this._children[i]; ++i) {\n\t\t\tchild.onHide.apply(child, arguments);\n\t\t}\n\t};\n\n\tthis.isShowing = function() { return this._isShowing; }\n\n\tthis.show = function() {\n\t\tthis.onBeforeShow();\n\n\t\tvar style = this._opts && this._opts.style;\n\t\tvar display = style && style.display != 'none' && style.display || 'block';\n\t\tif (this._el) {\n\t\t\tthis._el.style.display = display;\n\t\t}\n\n\t\tthis.onShow();\n\t\treturn this;\n\t};\n\n\tthis.hide = function() {\n\t\tthis.onBeforeHide();\n\t\t$.hide(this.getElement());\n\t\tthis.onHide();\n\t\treturn this;\n\t};\n\n\tthis.removeChildren = function () {\n\t\tthis._children.forEach(function (child) { child.remove(); });\n\t}\n\n\tthis.remove = function() {\n\t\tthis.onBeforeHide();\n\t\t$.remove(this.getElement());\n\t\tthis.onHide();\n\t};\n\n\tthis.getModel = function () {\n\t\treturn this.__model;\n\t}\n\n\tthis.setModel = function (path, value) {\n\t\tif (arguments.length == 1) {\n\t\t\tthis.__model.setObject(path);\n\t\t} else {\n\t\t\tthis.__model.set(path, value);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tthis.putHere = function() {\n\t\tif(!this._el) { this.build(); }\n\n\t\tvar id = 'jsioWidgetId' + (++uid);\n\t\tglobal.getTargetDocument().write('<div id=\"'+id+'\"></div>');\n\t\tsetTimeout(bind(this, _replaceNode, id), 0);\n\n\t\treturn this;\n\t};\n\n\tfunction _replaceNode(id) {\n\t\tvar el = $.id(id);\n\t\tel.parentNode.insertBefore(this._el, el);\n\t\tel.parentNode.removeChild(el);\n\t};\n\n\tthis.appendTo =\n\tthis.setParent = function(parent) {\n\t\tvar el = parent\n\t\t\t&& (parent.getContainer && parent.getContainer()\n\t\t\t\t\t|| parent.appendChild && parent\n\t\t\t\t\t|| $.id(parent));\n\n\t\tif (el) {\n\t\t\tif (!this._el) {\n\t\t\t\tthis._opts.parent = el;\n\t\t\t\tthis.build();\n\t\t\t} else {\n\t\t\t\tel.appendChild(this._el);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n});\n\nvar map = {};\nvar lowerCaseMap = {}\nWidget.register = function(cls, name) {\n\tif (name in map) { throw Error(\"A widget with name '\" + name + \"' is already registered\"); }\n\tmap[name] = cls;\n\tlowerCaseMap[name.toLowerCase()] = cls;\n};\n\nWidget.get = function(name) {\n\treturn lowerCaseMap[name.toLowerCase()];\n}\n\nWidget.WidgetSet = WidgetSet;\n");
jsio.setCachedSrc('../node_modules/squill/Element.js',"jsio('import lib.PubSub');\njsio('from util.browser import $');\n\nvar Element = exports = Class(lib.PubSub, function(supr) {\n\tthis.init = function(opts) {\n\t\tthis._opts = JS.merge(opts, {\n\t\t\twin: window,\n\t\t\ttag: 'div'\n\t\t});\n\t}\n\n\tthis.build = function() {\n\t\tif (!this._el) {\n\t\t\tif (this._opts.el) {\n\t\t\t\tthis._el = this._opts.el;\n\t\t\t\t$.apply(this._el, this._opts);\n\t\t\t} else {\n\t\t\t\tthis._el = $.create(this._opts);\n\t\t\t}\n\n\t\t\tthis.buildContent();\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tthis.getId = function() { return this._el && this._el.id || this._opts && this._opts.id; }\n\n\tthis.buildContent = function() {}\n\n\tthis.destroy = function() {\n\t\tif (!this._el) { return; }\n\t}\n\n\tthis.getElement = function() { return this._el || this.build()._el; }\n\n\tthis.appendChild = function(el) {\n\t\tif (!this._el) { this.build(); }\n\t\tthis._el.appendChild(el instanceof Element ? el._el : el);\n\n\t\treturn this;\n\t}\n\n\tthis.appendTo = function(el) {\n\t\tif (!this._el) { this.build(); }\n\n\t\tif (el instanceof Element) {\n\t\t\tel.appendChild(this);\n\t\t} else {\n\t\t\tel.appendChild(this._el);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tthis.setPos = function(x, y) {\n\t\tthis._el.style.x = x + 'px';\n\t\tthis._el.style.y = y + 'px';\n\t}\n\n\tthis.center = function() {\n\t\tvar dim = $(window);\n\t\tthis.setPos(Math.max(0, dim.width - this._el.offsetWidth) / 2, Math.max(0, dim.height - this._el.offsetHeight) / 2);\n\t}\n\n\tthis.remove = function() { $.remove(this._el); }\n});\n");
jsio.setCachedSrc('../node_modules/jsio/packages/lib/PubSub.js',"/**\n * Summary: inherit from lib.PubSub if a class wants publish/subscribe ability\n * Methods:\n *  - publish(signal, args...) - all subscribers to signal will be called\n *     with the list of arguments provided.\n *  - subscribe(signal, ctx, method, args...) - register a bound method\n *     to a signal.  Any args that are passed in will be the first args\n *     when the method is invoked during a publish.\n *  Usage notes: There is one special signal '__any'.  Any subscribers to\n *     '__any' will be called on every publish with the first publish\n *     argument being the signal itself (after any args passed in during\n *     the corresponding subscribe).\n *     Calling the super constructor is not required for descendants of\n *     lib.PubSub.\n */\n\njsio('from ..std.uuid import uuid');\n\nvar ctx = jsio.__env.global,\n\tSLICE = Array.prototype.slice;\n\nexports = Class(function () {\n\n\tthis.init = function () {};\n\n\tthis.publish = function (signal) {\n\t\tif (this._subscribers) {\n\t\t\tvar args = SLICE.call(arguments, 1);\n\t\t\tif (this._subscribers.__any) {\n\t\t\t\tvar anyArgs = [signal].concat(args),\n\t\t\t\t\tsubs = this._subscribers.__any.slice(0);\n\t\t\t\tfor(var i = 0, sub; sub = subs[i]; ++i) {\n\t\t\t\t\tsub.apply(ctx, anyArgs);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!this._subscribers[signal]) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar subs = this._subscribers[signal].slice(0);\n\t\t\tfor (var i = 0, sub; sub = subs[i]; ++i) {\n\t\t\t\tsub.apply(ctx, args);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n\n\tthis.subscribe = function (signal, ctx, method) {\n\t\tvar cb;\n\t\tif (arguments.length == 2) {\n\t\t\tcb = ctx;\n\t\t} else {\n\t\t\tcb = bind.apply(GLOBAL, SLICE.call(arguments, 1));\n\t\t\tcb._ctx = ctx; // references for unsubscription\n\t\t\tcb._method = method;\n\t\t}\n\n\t\tvar s = this._subscribers || (this._subscribers = {});\n\t\t(s[signal] || (s[signal] = [])).push(cb);\n\t\treturn this;\n\t};\n\n\tthis.subscribeOnce = function (signal, ctx, method) {\n\t\tvar args = arguments,\n\t\t\tcb = bind(this, function () {\n\t\t\t\tthis.unsubscribe(signal, cb);\n\t\t\t\tif (args.length == 2) {\n\t\t\t\t\tctx.apply(GLOBAL, arguments);\n\t\t\t\t} else {\n\t\t\t\t\tbind.apply(GLOBAL, SLICE.call(args, 1))\n\t\t\t\t\t\t.apply(GLOBAL, arguments);\n\t\t\t\t}\n\t\t\t});\n\n\t\tif (args.length >= 3) {\n\t\t\tcb._ctx = ctx;\n\t\t\tcb._method = method;\n\t\t}\n\n\t\treturn this.subscribe(signal, cb);\n\t};\n\n\t// If no method is specified, all subscriptions with a callback context\n\t// of ctx will be removed.\n\n\tthis.unsubscribe = function (signal, ctx, method) {\n\t\tif (!this._subscribers || !this._subscribers[signal]) {\n\t\t\treturn this;\n\t\t}\n\t\tvar subs = this._subscribers[signal];\n\t\tfor (var i = 0, c; c = subs[i]; ++i) {\n\t\t\tif (c == ctx || c._ctx == ctx && (!method || c._method == method)) {\n\t\t\t\tsubs.splice(i--, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * EventEmitter-style API\n\t * http://nodejs.org/api/events.html\n\t */\n\n\tthis.listeners = function (type) {\n\t\tthis._subscribers = (this._subscribers ? this._subscribers : {});\n\t\treturn (this.hasOwnProperty.call(this._subscribers, type))\n\t\t\t? this._subscribers[type]\n\t\t\t: (this._subscribers[type] = []);\n\t};\n\n\tthis.addListener = this.on = function (type, f) {\n\t\tif (this.listeners(type).length + 1 > this._maxListeners && this._maxListeners !== 0) {\n\t\t\tif (typeof console !== \"undefined\") {\n\t\t\t\tconsole.warn(\"Possible EventEmitter memory leak detected. \" + this._subscribers[type].length + \" listeners added. Use emitter.setMaxListeners() to increase limit.\");\n\t\t\t}\n\t\t}\n\t\tthis.emit(\"newListener\", type, f);\n\t\treturn this.subscribe(type, this, f);\n\t};\n\n\tthis.once = function (type, f) {\n\t\treturn this.subscribeOnce(type, this, f);\n\t};\n\n\tthis.removeListener = function (type, f) {\n\t\tthis.unsubscribe(type, this, f);\n\t\treturn this;\n\t};\n\n\tthis.removeAllListeners = function (type) {\n\t\tif (this._subscribers) {\n\t\t\tfor (var k in this._subscribers) {\n\t\t\t\tif (type == null || type == k) {\n\t\t\t\t\tdelete this._subscribers[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n\n\tthis.emit = function (type) {\n\t\tthis.publish.apply(this, arguments);\n\t\treturn this.listeners(type).length > 0;\n\t};\n\n\tthis._maxListeners = 10;\n\n\tthis.setMaxListeners = function (_maxListeners) {\n\t\tthis._maxListeners = _maxListeners;\n\t};\n\n\tthis.hasListeners = function (type) {\n\t\treturn this._subscribers && this._subscribers[type] && this._subscribers[type].length;\n\t};\n\n\t/**\n\t * listenTo for inverting control of #subscribe, #on, etc.\n\t * @param {object} obj something extending js.io's lib.PubSub\n\t * @param {string} name the event name to listen to\n\t * @param {callback} function to run on event\n\t * @return {this}\n\t */\n\tthis.listenTo = function (obj, name, callback) {\n\t\tvar listeningTo = this._listeningTo || (this._listeningTo = {});\n\t\tvar id = obj._listenId || (obj._listenId = uuid(8, 16));\n\t\tlisteningTo[id] = obj;\n\t\tobj.subscribe(name, this, callback);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Stop listening to objects previously passed to `listenTo`.\n\t *\n\t * @example\n\t *     // Stop listening to all events on all objects\n\t *     this.stopListening();\n\t *\n\t *     // Stop listening to all events on `obj`\n\t *     this.stopListening(obj);\n\t *\n\t *     // Stop all of my callbacks for a given event\n\t *     this.stopListening(obj, name);\n\t *\n\t *     // Stop a single callback from firing\n\t *     this.stopListening(obj, name, callback);\n\t *\n\t * @param {object} [obj] object extending lib.PubSub and using listenTo\n\t * @param {string} [name] the event name to listen to\n\t * @param {callback} [callback] function to stop running\n\t * @return {this}\n\t */\n\tthis.stopListening = function (obj, name, callback) {\n\t\tvar events, names, retain, i, j, k, l, ev;\n\t\tvar listeningTo = this._listeningTo;\n\t\tif (!listeningTo) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlogger.log(obj);\n\t\tvar remove = !name && !callback;\n\t\tif (obj) {\n\t\t\t(listeningTo = {})[obj._listenId] = obj;\n\t\t}\n\n\t\tfor (var id in listeningTo) {\n\t\t\tobj = listeningTo[id];\n\n\t\t\tnames = name ? [name] : Object.keys(obj._subscribers);\n\t\t\tfor (i = 0, l = names.length; i < l; i++) {\n\t\t\t\tname = names[i];\n\t\t\t\tif (events = obj._subscribers[name]) {\n\t\t\t\t\tobj._subscribers[name] = retain = [];\n\t\t\t\t\tfor (j = 0, k = events.length; j < k; j++) {\n\t\t\t\t\t\tev = events[j];\n\t\t\t\t\t\tif ((callback && callback !== ev._method) ||\n\t\t\t\t\t\t\t\t(this && this !== ev._ctx)) {\n\t\t\t\t\t\t\tretain.push(ev);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!retain.length) delete obj._subscribers[name];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (remove) {\n\t\t\t\tdelete this._listeningTo[id];\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n});\n\n");
jsio.setCachedSrc('../node_modules/jsio/packages/std/uuid.js',"/*\nBased on Math.uuid.js 1.4 by Robert Kieffer\n\n----\nCopyright (c) 2008, Robert Kieffer\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice,\n\tthis list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright\n\tnotice, this list of conditions and the following disclaimer in the\n\tdocumentation and/or other materials provided with the distribution.\n  * Neither the name of Robert Kieffer nor the names of its contributors\n\tmay be used to endorse or promote products derived from this software\n\twithout specific prior written permission.\n  \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n\n\n/*\n * Generate a random uuid.\n *\n * USAGE: uuid.uuid(length, radix)\n *   length - the desired number of characters\n *   radix  - the number of allowable values for each character.\n *\n * EXAMPLES:\n *   // No arguments  - returns RFC4122, version 4 ID\n *   >>> std.uuid()\n *   \"92329D39-6F5C-4520-ABFC-AAB64544E172\"\n * \n *   // One argument - returns ID of the specified length\n *   >>> std.uuid(15)\t // 15 character ID (default base=62)\n *   \"VcydxgltxrVZSTV\"\n *\n *   // Two arguments - returns ID of the specified length, and radix. (Radix must be <= 62)\n *   >>> std.uuid(8, 2)  // 8 character ID (base=2)\n *   \"01001010\"\n *   >>> std.uuid(8, 10) // 8 character ID (base=10)\n *   \"47473046\"\n *   >>> std.uuid(8, 16) // 8 character ID (base=16)\n *   \"098F4D35\"\n */\n\n\nvar CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''); \nexports.uuid = function (len, radix) {\n\tvar chars = CHARS, uuid = [], rnd = Math.random;\n\tradix = radix || chars.length;\n\n\tif (len) {\n\t\t// Compact form\n\t\tfor (var i = 0; i < len; i++) uuid[i] = chars[0 | rnd()*radix];\n\t} else {\n\t\t// rfc4122, version 4 form\n\t\tvar r;\n\n\t\t// rfc4122 requires these characters\n\t\tuuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\n\t\tuuid[14] = '4';\n\n\t\t// Fill in random data.  At i==19 set the high bits of clock sequence as\n\t\t// per rfc4122, sec. 4.1.5\n\t\tfor (var i = 0; i < 36; i++) {\n\t\t\tif (!uuid[i]) {\n\t\t\t\tr = 0 | rnd()*16;\n\t\t\t\tuuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r & 0xf];\n\t\t\t}\n\t\t}\n\t}\n\treturn uuid.join('');\n};\n\n");
jsio.setCachedSrc('../node_modules/squill/Events.js',"jsio('from util.browser import $');\njsio('import .Drag');\njsio('import lib.PubSub');\n\nexports = Class(lib.PubSub, function() {\n\tvar SLICE = Array.prototype.slice;\n\n\tvar isMobile = /(iPod|iPhone|iPad|Android)/i.test(navigator.userAgent);\n\n\tthis.event = function(el, name, handler) {\n\t\tif (!this._eventEnabled) { this._eventEnabled = {}; }\n\t\tvar args = [this, handler].concat(SLICE.call(arguments, 3)),\n\t\t\thandler = bind.apply(this, args),\n\t\t\tevents = this._eventEnabled;\n\n\t\tevents[name] = true;\n\t\t$.onEvent(el, name, function() {\n\t\t\tif (events[name]) {\n\t\t\t\treturn handler.apply(this, arguments);\n\t\t\t}\n\t\t});\n\t};\n\n\tthis.isDragging = function() {\n\t\treturn this._isDragging || false;\n\t};\n\n\tthis.initDragEvents = function(el) {\n\t\tif (!this.__drag) {\n\t\t\tvar d = this.__drag = new Drag();\n\t\t\td.subscribe('DragStart', this, 'onDragStart');\n\t\t\td.subscribe('Drag', this, 'onDrag');\n\t\t\td.subscribe('DragStop', this, 'onDragStop');\n\t\t}\n\n\t\tvar startDrag = bind(this.__drag, 'startDrag');\n\t\tif (!el) { el = this._el; }\n\t\tif (el.addEventListener) { el.addEventListener('touchstart', startDrag, true); }\n\t\t$.onEvent(el, 'mousedown', startDrag);\n\t};\n\n\tthis.initMouseEvents = function(el) {\n\t\tel = el || this._el;\n\n\t\tif (isMobile) {\n\t\t\tthis.event(el, 'touchstart', '_onTouchStart');\n\t\t\tthis.event(el, 'touchend', '_onTouchEnd');\n\t\t} else {\n\t\t\tthis.event(el, 'mouseover', 'onMouseOver');\n\t\t\tthis.event(el, 'mousemove', 'onMouseMove');\n\t\t\tthis.event(el, 'mouseout', 'onMouseOut');\n\t\t\tthis.event(el, 'mousedown', 'onMouseDown');\n\t\t\tthis.event(el, 'mouseup', 'onMouseUp');\n\t\t\tthis.event(el, 'click', 'onClick');\n\t\t}\n\n\t\tvar opts = this._opts;\n\t\tif (opts && opts.__result) {\n\t\t\topts.__result.addSubscription(this, 'Select');\n\t\t}\n\n\t\treturn this;\n\t};\n\n\tthis.initFocusEvents = function(el) {\n\t\tel = el || this._el;\n\t\tthis.event(el, 'focus', 'onFocus');\n\t\tthis.event(el, 'blur', 'onBlur');\n\t\treturn this;\n\t};\n\n\tthis.initKeyEvents = function(el) {\n\t\tel = el || this._el;\n\t\tthis.event(el, 'keydown', 'onKeyDown');\n\t\tthis.event(el, 'keypress', 'onKeyPress');\n\t\tthis.event(el, 'keyup', 'onKeyUp');\n\t\treturn this;\n\t}\n\n\tthis._onTouchStart = function(e) {\n\t\tthis.onMouseOver(e);\n\t\tthis.onMouseDown(e);\n\t};\n\n\tthis._onTouchEnd = function(e) {\n\t\tthis.onMouseUp(e);\n\t\tthis.onClick(e);\n\t\tthis.onMouseOut(e);\n\t};\n\n\tthis.onMouseOver = function(e) {\n\t\tif (!this._enableMouseEvents)\n\t\tthis._isOver = true;\n\t\tthis.publish('Over', e);\n\t};\n\n\tthis.onMouseMove = function(e) {\n\t\tif (!this._enableMouseEvents)\n\t\tthis.publish('Move', e);\n\t};\n\n\tthis.onMouseOut = function(e) {\n\t\tthis._isOver = false;\n\t\tthis.publish('Out', e);\n\t};\n\n\tthis.onMouseDown = function(e) {\n\t\tthis._isDown = true;\n\t\tthis.publish('Down', e);\n\t\treturn false;\n\t};\n\n\tthis.onMouseUp = function(e) {\n\t\tthis._isDown = false;\n\t\tthis.publish('Up', e);\n\t\treturn false;\n\t};\n\n\tthis.onClick = function(e) {\n\t\tthis.publish('Select', e);\n\t\tthis.emit('click', e);\n\t\treturn false;\n\t};\n\n\tthis.onFocus = function(e) {\n\t\tthis._isFocused = true;\n\t\tthis.publish('Focus', e);\n\t};\n\n\tthis.onBlur = function(e) {\n\t\tthis._isFocused = false;\n\t\tthis.publish('Blur', e);\n\t};\n\n\tthis.onKeyUp = function(e) {\n\t\tthis.publish('KeyUp', e);\n\t};\n\n\tthis.onKeyPress = function(e) {\n\t\tthis.publish('KeyPress', e);\n\t};\n\n\tthis.onKeyDown = function(e) {\n\t\tthis.publish('KeyDown', e);\n\t};\n\n\tthis.onDragStart = function(dragEvt) {};\n\tthis.onDrag = function(dragEvt, moveEvt) {};\n\tthis.onDragStop = function(dragEvt, upEvt) {};\n});\n");
jsio.setCachedSrc('../node_modules/squill/Drag.js',"jsio('import lib.PubSub');\njsio('import math.geom.Point as Point');\njsio('from util.browser import $');\n\nvar gCurrentDrag = [],\n\tgCurrentMouse = {x: 0, y: 0};\n\nfunction resolveMouse(e) {\n\tif (e.touches) { return resolveMouse(e.touches[0]); }\n\t\n\tif ('pageX' in e) {\n\t\tgCurrentMouse.x = e.pageX;\n\t\tgCurrentMouse.y = e.pageY;\n\t} else { // looks like IE\n\t\tvar doc = document.documentElement,\n\t\t\tbody = document.body;\n\t\t\n\t\tgCurrentMouse.x = e.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n\t\tgCurrentMouse.y = e.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop  || body && body.clientTop  || 0);\n\t}\n}\n\nvar _active = false;\n\nfunction gAddItem(item) {\n\tgRemoveItem(item);\n\tgCurrentDrag.push(item);\n\t_active = true;\n}\n\nfunction gRemoveItem(item) {\n\tfor (var i = 0; i < gCurrentDrag.length; ++i) {\n\t\tif (gCurrentDrag[i] == item) {\n\t\t\tgCurrentDrag.splice(i, 1);\n\t\t\t--i;\n\t\t}\n\t}\n\n\tif (!gCurrentDrag[0]) { _active = false; }\n}\n\nfunction onMove(e) {\n\tif (!_active) { return; }\n\n\tresolveMouse(e);\n\tfor (var i = 0; i < gCurrentDrag.length; ++i) {\n\t\tgCurrentDrag[i].onMouseMove(e);\n\t}\n\n}\n\nfunction onUp(e) {\n\tif (!_active) { return; }\n\n\tfor (var i = 0; i < gCurrentDrag.length; ++i) {\n\t\tgCurrentDrag[i].onMouseUp(e);\n\t}\n}\n\nfunction registerWindow(win) {\n\tvar doc = win.document;\n\tif ('ontouchstart' in win) {\n\t\tdoc.addEventListener('touchstart', resolveMouse, true);\n\t\tdoc.addEventListener('touchmove', onMove, true);\n\t\tdoc.addEventListener('touchend', onUp, true);\n\t} else {\n\t\tdoc.addEventListener('mousedown', resolveMouse, true);\n\t\tdoc.addEventListener('mousemove', onMove, true);\n\t\tdoc.addEventListener('mouseup', onUp, true);\n\t}\n}\n\nexports = Class(lib.PubSub, function(supr) {\n\n\tthis.init = function(params) {\n\t\tthis._isActive = false;\n\t}\n\t\n\tthis.isDragging = function () { return this._isActive; }\n\n\t// data is an optional object that will be added to dragEvt.data.\n\t// This allows the caller of startDrag to pass along arbitrary objects\n\t// to the DragStart, Drag, and DragStop events, since the receiver\n\t// can just read data off of the event object (first argument).\n\tthis.startDrag = function(params, data) {\n\t\tvar e = this._evt = new exports.DragEvent();\n\t\tthis._evt.data = data;\n\t\tthis._evt.params = merge(params, {\n\t\t\t/* addInScroll: true, */ // TODO?\n\t\t\tthreshold: 5\n\t\t});\n\n\t\te.srcPt = new Point(gCurrentMouse);\n\t\te.currPt = new Point(gCurrentMouse);\n\t\tgAddItem(this);\n\t}\n\n\tthis.onMouseMove = function (moveEvt) {\n\n\t\tvar dragEvt = this._evt;\n\t\tvar absDelta = Point.subtract(gCurrentMouse, dragEvt.srcPt);\n\n\t\tif (!this._isActive && absDelta.getMagnitude() > dragEvt.params.threshold) {\n\t\t\tthis._isActive = true;\n\n\t\t\tvar doc = moveEvt.target && (moveEvt.target.ownerDocument || moveEvt.target.nodeType == 9 && moveEvt.target);\n\t\t\tthis.disableIframes(doc);\n\t\t\tthis.publish('DragStart', dragEvt);\n\t\t}\n\n\t\tif (this._isActive) {\n\t\t\t$.stopEvent(moveEvt);\n\n\t\t\tdragEvt.prevPt = dragEvt.currPt;\n\t\t\tdragEvt.currPt = new Point(gCurrentMouse);\n\t\t\tthis.publish('Drag', dragEvt, moveEvt, Point.subtract(dragEvt.currPt, dragEvt.prevPt));\n\t\t}\n\t}\n\n\tthis.onMouseUp = function(upEvt) {\n\t\tgRemoveItem(this);\n\t\tif (this._isActive) {\n\n\t\t\t$.stopEvent(upEvt);\n\t\t\tthis._isActive = false;\n\t\t\tthis.enableIframes();\n\t\t\tthis.publish('DragStop', this._evt, upEvt);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tthis.disableIframes = function (doc) {\n\t\tif (!this._disabledFrames) {\n\t\t\tthis._disabledFrames = [];\n\t\t}\n\n\t\t$(\"iframe\", doc).forEach(function (iframe) {\n\t\t\ttry {\n\t\t\t\tthis._disabledFrames.push({\n\t\t\t\t\tframe: iframe,\n\t\t\t\t\tpointerEvents: iframe.style.pointerEvents\n\t\t\t\t});\n\n\t\t\t\tiframe.style.pointerEvents = 'none';\n\t\t\t} catch (e) {}\n\t\t}, this);\n\t}\n\n\tthis.enableIframes = function () {\n\t\tthis._disabledFrames.splice(0, this._disabledFrames.length).forEach(function (item) {\n\t\t\titem.frame.style.pointerEvents = item.pointerEvents;\n\t\t});\n\t}\n});\n\nexports.registerWindow = registerWindow;\n\nexports.DragEvent = Class(function() {});\n\nvar win = window;\nregisterWindow(win);\nwhile (win.parent != win) {\n\twin = win.parent;\n\ttry {\n\t\tregisterWindow(win);\n\t} catch (e) {}\n}\n");
jsio.setCachedSrc('../node_modules/squill/global.js',"var gWidgetPrefix = 'squill-';\nvar gWin = window;\nvar gDoc = document;\n\nexports.setTargetWindow = function(w) { gWin = w; gDoc = w.document; }\nexports.getTargetWindow = function() { return gWin; }\nexports.getTargetDocument = function() { return gDoc; }\n\nexports.setWidgetPrefix = function(p) { gWidgetPrefix = p; }\nexports.getWidgetPrefix = function() { return gWidgetPrefix; }\n");
jsio.setCachedSrc('../node_modules/squill/i18n.js',"var gLang = null;\n\nexports.setLang = function(lang) { gLang = lang; }\nexports.get = function(key) {\n\treturn gLang && gLang.get(key);\n}\n\nexports.Language = Class(function() {\n\tthis.init = function(dict) { this._dict = dict; }\n\tthis.add = function(key, value) { this._dict[key] = value; }\n\tthis.get = function(key) { return this._dict[key]; }\n});\n");
jsio.setCachedSrc('../node_modules/squill/Delegate.js',"var SLICE = Array.prototype.slice;\n\nvar Delegate = exports = Class(function() {\n\tthis.init = function(def) {\n\t\tdef && def(this);\n\t}\n\n\tthis.extend = function(def) {\n\t\tvar delegate = new Delegate(def);\n\t\tdelegate.parent = this;\n\t\treturn delegate;\n\t}\n\n\tthis.call = function(ctx, name) {\n\t\tif (this[name]) {\n\t\t\treturn this[name].apply(ctx, SLICE.call(arguments, 2));\n\t\t} else if (this.parent) {\n\t\t\treturn this.parent.apply(ctx, SLICE.call(arguments, 1));\n\t\t}\n\t}\n\n\tthis.apply = function (ctx, args) {\n\t\tthis.call.apply(this, [ctx].concat(SLICE.call(args)));\n\t}\n});\n");
jsio.setCachedSrc('../node_modules/squill/models/Model.js',"jsio('import lib.PubSub');\n\nvar Model = exports = Class(lib.PubSub, function (supr) {\n\n  this.init = function (opts) {\n    var obj;\n\n    if (opts instanceof Model) {\n      var cloneFrom = opts;\n      opts = {\n        localStorage: cloneFrom._storageKey\n      };\n\n      obj = cloneFrom._data;\n    }\n\n    this._data = {};\n\n    if (opts && opts.localStorage) {\n      this._storageKey = opts.localStorage;\n\n      if (obj === undefined) {\n        var raw = localStorage.getItem(this._storageKey);\n        if (raw) {\n          try {\n            obj = JSON.parse(raw);\n          } catch (e) {}\n        }\n      }\n    }\n\n    this.setObject(obj || {});\n\n    if (opts) {\n      // initial values\n      if (opts.values) {\n        Object.keys(opts.values).forEach(function (key) {\n          this.set(key, opts.values[key]);\n        }, this);\n      }\n\n      // default values\n      if (opts.defaults) {\n        Object.keys(opts.defaults).forEach(function (key) {\n          if (!this.has(key)) {\n            this.set(key, opts.defaults[key]);\n          }\n        }, this);\n      }\n    }\n  }\n\n  this.setObject = function (obj) {\n    this._data = obj;\n    this.emit();\n    this.persist();\n    return this;\n  }\n\n  this.toObject = function () {\n    return copy(this._data);\n  }\n\n  function copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n\n  this.clone = function () {\n    return new Model(this.getObject());\n  }\n\n  var PATH_SEP = /[\\[.,]/;\n  function parsePath(path) {\n    return path.split(PATH_SEP).map(function (piece) {\n      return piece[piece.length - 1] == ']' ? parseInt(piece) : piece;\n    });\n  }\n\n  function matchPath(p1, p2) {\n    return p1.indexOf(p2) == 0 || p2.indexOf(p1) == 0;\n  }\n\n  this.has = function (path) { return this.get(path) !== undefined; }\n\n  this.get = function (path) {\n    var segments = parsePath(path);\n    var n = segments.length;\n    var i = 0;\n    var o = this._data;\n    while (o && i < n) {\n      o = o[segments[i++]];\n    }\n\n    return o;\n  }\n\n  this.getObject = function (path) {\n    return copy(this.get(path) || {});\n  }\n\n  this.set = function (path, value) {\n    var segments = parsePath(path);\n    var n = segments.length - 1;\n    var i = 0;\n    var o = this._data;\n    while (o && i < n) {\n      var s = segments[i++];\n      if (!o[s]) {\n        o[s] = typeof segments[i] == 'number' ? [] : {};\n      }\n\n      o = o[s];\n    }\n\n    var prevValue = o[segments[n]];\n    if (value != prevValue) {\n      o[segments[n]] = value;\n      this.emit(path, value);\n    }\n\n    this.persist();\n    return this;\n  }\n\n  this.emit = function (path, value) {\n    if (path) {\n      supr(this, 'emit', arguments);\n    }\n\n    if (this._subscribers) {\n      Object.keys(this._subscribers).forEach(function (key) {\n        if (!path || key != path && matchPath(key, path)) {\n          supr(this, 'emit', [key, this.get(key)]);\n        }\n      }, this);\n    }\n    return this;\n  }\n\n  this.persist = function () {\n    if (this._storageKey) {\n      localStorage.setItem(this._storageKey, JSON.stringify(this._data));\n    }\n    return this;\n  }\n});\n");
jsio.setCachedSrc('../node_modules/squill/models/bindings.js',"var RE_BINDING = /(^|[^%])%\\((.*?)\\)([ +0-]?)(\\d*)(\\.?\\d*)([dfcs])/g;\n\nexports.parseFormat = function (widget, format) {\n  var subs = [];\n  format.replace(RE_BINDING, function (match, prefix, key, pad, minLength, decimal, type, index) {\n    subs.push({\n      index: index + prefix.length,\n      endIndex: index + match.length,\n      key: key,\n      pad: pad || ' ',\n      minLength: parseInt(minLength),\n      decimal: parseInt(decimal.substring(1)),\n      type: type,\n      value: ''\n    });\n  });\n\n  subs.reverse();\n  new Binding(widget, null, format, subs);\n}\n\nexports.parseData = function (widget, data) {\n  new Binding(widget, data);\n}\n\nvar Binding = Class(function () {\n  this.init = function (widget, key, src, subs) {\n\n    var res = widget.getOpts().__result;\n    var baseWidget = res && res.getTarget() || widget;\n\n    this._widget = widget;\n    this._key = key;\n    this._src = src;\n    this._subs = subs;\n\n    this._connect(baseWidget.getModel());\n\n    //  else if (widget.setEnabled && widget.isEnabled && widget.isEnabled()) {\n    //   // disable input until the model is backing it\n    //   this._isDisabled = true;\n    //   widget.setEnabled(false);\n    // }\n\n    widget.on('change', bind(this, '_updateModel'));\n    baseWidget.on('model', bind(this, '_connect'));\n  }\n\n  this._connect = function (model) {\n    if (this._model) { this._disconnect(); }\n    this._model = model;\n\n    // this._widget.setEnabled(true);\n\n    if (this._subs) {\n      this._subs.forEach(function (sub) {\n        sub.value = model.get(sub.key);\n        model.subscribe(sub.key, this, '_update', sub.key);\n      }, this);\n\n      this._update();\n    } else if (this._key) {\n      model.subscribe(this._key, this, '_updateKey');\n      this._updateKey(model.get(this._key));\n    }\n  }\n\n  this._disconnect = function () {\n    var model = this._model;\n    this._subs && this._subs.forEach(function (sub) {\n      model.unsubscribe(sub.key, this);\n    }, this);\n\n    this._key && model.unsubscribe(this._key, this);\n  }\n\n  this._update = function (key, value) {\n    var str = this._src;\n    this._subs.forEach(function (sub) {\n      if (key && sub.key == key) { sub.value = value; }\n      str = str.substring(0, sub.index) + sub.value + str.substring(sub.endIndex);\n    }, this);\n\n    this._widget.setData(str);\n  }\n\n  this._updateKey = function (value) {\n    this._widget.setData(value);\n  }\n\n  this._updateModel = function (value) {\n    if (this._model && this._key) {\n      this._model.set(this._key, value);\n    }\n  }\n});\n\n/*\n\nvar bindings = require('./bindings');\nbindings.parseFormat({}, \"Hello world %(format.this) 4d %(format.that)06.2f\")\n\n*/\n");
jsio.setCachedSrc('../node_modules/squill/__imports__.js',"exports.classes = {\n\talpha: '.Alpha',\n\tlabel: '.Label',\n\tlist: '.List',\n\tbutton: '.TextButton',\n\ttext: '.TextInput',\n\ttextarea: '.TextArea',\n\tpassword: '.TextInput',\n\tscroller: '.Scroller',\n\tcanvas: '.Canvas',\n\tcheckbox: '.CheckBox',\n\tmenu: '.Menu',\n\tslider: '.Slider',\n\tcolor: '.Color',\n\tvcenter: '.VerticalCenter',\n\ttreelist: '.TreeList',\n\tgraph: '.Graph',\n\tselect: '.SelectBox',\n\twidget: '.Widget'\n};\n\n\nexports.resolve = function(env, opts) {\n\tvar imports = [];\n\n\tif (env == 'browser') {\n\t\tfor (var key in exports.classes) {\n\t\t\timports.push(exports.classes[key]);\n\t\t}\n\t}\n\n\treturn imports;\n}\n");
jsio.setCachedSrc('../node_modules/squill/jscolor/jscolor.js',"/**\n * jscolor, JavaScript Color Picker\n *\n * @version 1.3.11\n * @license GNU Lesser General Public License, http://www.gnu.org/copyleft/lesser.html\n * @author  Jan Odvarko, http://odvarko.cz\n * @created 2008-06-15\n * @updated 2011-11-07\n * @link    http://jscolor.com\n */\n\n\nvar jscolor = {\n\n\n\tdir : '', // location of jscolor directory (leave empty to autodetect)\n\tbindClass : 'color', // class name\n\tbinding : true, // automatic binding via <input class=\"...\">\n\tpreloading : true, // use image preloading?\n\n\n\tinstall : function() {\n\t\tjscolor.addEvent(window, 'load', jscolor.init);\n\t},\n\n\n\tinit : function() {\n\t\tif(jscolor.binding) {\n\t\t\tjscolor.bind();\n\t\t}\n\t\tif(jscolor.preloading) {\n\t\t\tjscolor.preload();\n\t\t}\n\t},\n\n\n\tgetDir : function() {\n\t\t/*\n\t\tif(!jscolor.dir) {\n\t\t\tvar detected = jscolor.detectDir();\n\t\t\tjscolor.dir = detected!==false ? detected : 'jscolor/';\n\t\t}\n\t\t*/\n\t\tjscolor.dir = 'images/colorpicker/'\n\t\treturn jscolor.dir;\n\t},\n\n\n\tdetectDir : function() {\n\t\tvar base = location.href;\n\n\t\tvar e = document.getElementsByTagName('base');\n\t\tfor(var i=0; i<e.length; i+=1) {\n\t\t\tif(e[i].href) { base = e[i].href; }\n\t\t}\n\n\t\tvar e = document.getElementsByTagName('script');\n\t\tfor(var i=0; i<e.length; i+=1) {\n\t\t\tif(e[i].src && /(^|\\/)jscolor\\.js([?#].*)?$/i.test(e[i].src)) {\n\t\t\t\tvar src = new jscolor.URI(e[i].src);\n\t\t\t\tvar srcAbs = src.toAbsolute(base);\n\t\t\t\tsrcAbs.path = srcAbs.path.replace(/[^\\/]+$/, ''); // remove filename\n\t\t\t\tsrcAbs.query = null;\n\t\t\t\tsrcAbs.fragment = null;\n\t\t\t\treturn srcAbs.toString();\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\n\tbind : function(element) {\n\t\t/*\n\t\tvar matchClass = new RegExp('(^|\\\\s)('+jscolor.bindClass+')\\\\s*(\\\\{[^}]*\\\\})?', 'i');\n\t\tvar e = document.getElementsByTagName('input');\n\t\tfor(var i=0; i<e.length; i+=1) {\n\t\t\tvar m;\n\t\t\tif(!e[i].color && e[i].className && (m = e[i].className.match(matchClass))) {\n\t\t\t\tvar prop = {};\n\t\t\t\tif(m[3]) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\teval('prop='+m[3]);\n\t\t\t\t\t} catch(eInvalidProp) {}\n\t\t\t\t}\n\t\t\t\te[i].color = new jscolor.color(e[i], prop);\n\t\t\t}\n\t\t}\n\t\t*/\n\t\telement.color = new jscolor.color(element, {});\n\t},\n\n\n\tpreload : function() {\n\t\tfor(var fn in jscolor.imgRequire) {\n\t\t\tif(jscolor.imgRequire.hasOwnProperty(fn)) {\n\t\t\t\tjscolor.loadImage(fn);\n\t\t\t}\n\t\t}\n\t},\n\n\n\timages : {\n\t\tpad : [ 181, 101 ],\n\t\tsld : [ 16, 101 ],\n\t\tcross : [ 15, 15 ],\n\t\tarrow : [ 7, 11 ]\n\t},\n\n\n\timgRequire : {},\n\timgLoaded : {},\n\n\n\trequireImage : function(filename) {\n\t\tjscolor.imgRequire[filename] = true;\n\t},\n\n\n\tloadImage : function(filename) {\n\t\tif(!jscolor.imgLoaded[filename]) {\n\t\t\tjscolor.imgLoaded[filename] = new Image();\n\t\t\tjscolor.imgLoaded[filename].src = jscolor.getDir()+filename;\n\t\t}\n\t},\n\n\n\tfetchElement : function(mixed) {\n\t\treturn typeof mixed === 'string' ? document.getElementById(mixed) : mixed;\n\t},\n\n\n\taddEvent : function(el, evnt, func) {\n\t\tif(el.addEventListener) {\n\t\t\tel.addEventListener(evnt, func, false);\n\t\t} else if(el.attachEvent) {\n\t\t\tel.attachEvent('on'+evnt, func);\n\t\t}\n\t},\n\n\n\tfireEvent : function(el, evnt) {\n\t\tif(!el) {\n\t\t\treturn;\n\t\t}\n\t\tif(document.createEvent) {\n\t\t\tvar ev = document.createEvent('HTMLEvents');\n\t\t\tev.initEvent(evnt, true, true);\n\t\t\tel.dispatchEvent(ev);\n\t\t} else if(document.createEventObject) {\n\t\t\tvar ev = document.createEventObject();\n\t\t\tel.fireEvent('on'+evnt, ev);\n\t\t} else if(el['on'+evnt]) { // alternatively use the traditional event model (IE5)\n\t\t\tel['on'+evnt]();\n\t\t}\n\t},\n\n\n\tgetElementPos : function(e) {\n\t\tvar e1=e, e2=e;\n\t\tvar x=0, y=0;\n\t\tif(e1.offsetParent) {\n\t\t\tdo {\n\t\t\t\tx += e1.offsetLeft;\n\t\t\t\ty += e1.offsetTop;\n\t\t\t} while(e1 = e1.offsetParent);\n\t\t}\n\t\twhile((e2 = e2.parentNode) && e2.nodeName.toUpperCase() !== 'BODY') {\n\t\t\tx -= e2.scrollLeft;\n\t\t\ty -= e2.scrollTop;\n\t\t}\n\t\treturn [x, y];\n\t},\n\n\n\tgetElementSize : function(e) {\n\t\treturn [e.offsetWidth, e.offsetHeight];\n\t},\n\n\n\tgetRelMousePos : function(e) {\n\t\tvar x = 0, y = 0;\n\t\tif (!e) { e = window.event; }\n\t\tif (typeof e.offsetX === 'number') {\n\t\t\tx = e.offsetX;\n\t\t\ty = e.offsetY;\n\t\t} else if (typeof e.layerX === 'number') {\n\t\t\tx = e.layerX;\n\t\t\ty = e.layerY;\n\t\t}\n\t\treturn { x: x, y: y };\n\t},\n\n\n\tgetViewPos : function() {\n\t\tif(typeof window.pageYOffset === 'number') {\n\t\t\treturn [window.pageXOffset, window.pageYOffset];\n\t\t} else if(document.body && (document.body.scrollLeft || document.body.scrollTop)) {\n\t\t\treturn [document.body.scrollLeft, document.body.scrollTop];\n\t\t} else if(document.documentElement && (document.documentElement.scrollLeft || document.documentElement.scrollTop)) {\n\t\t\treturn [document.documentElement.scrollLeft, document.documentElement.scrollTop];\n\t\t} else {\n\t\t\treturn [0, 0];\n\t\t}\n\t},\n\n\n\tgetViewSize : function() {\n\t\tif(typeof window.innerWidth === 'number') {\n\t\t\treturn [window.innerWidth, window.innerHeight];\n\t\t} else if(document.body && (document.body.clientWidth || document.body.clientHeight)) {\n\t\t\treturn [document.body.clientWidth, document.body.clientHeight];\n\t\t} else if(document.documentElement && (document.documentElement.clientWidth || document.documentElement.clientHeight)) {\n\t\t\treturn [document.documentElement.clientWidth, document.documentElement.clientHeight];\n\t\t} else {\n\t\t\treturn [0, 0];\n\t\t}\n\t},\n\n\n\tURI : function(uri) { // See RFC3986\n\n\t\tthis.scheme = null;\n\t\tthis.authority = null;\n\t\tthis.path = '';\n\t\tthis.query = null;\n\t\tthis.fragment = null;\n\n\t\tthis.parse = function(uri) {\n\t\t\tvar m = uri.match(/^(([A-Za-z][0-9A-Za-z+.-]*)(:))?((\\/\\/)([^\\/?#]*))?([^?#]*)((\\?)([^#]*))?((#)(.*))?/);\n\t\t\tthis.scheme = m[3] ? m[2] : null;\n\t\t\tthis.authority = m[5] ? m[6] : null;\n\t\t\tthis.path = m[7];\n\t\t\tthis.query = m[9] ? m[10] : null;\n\t\t\tthis.fragment = m[12] ? m[13] : null;\n\t\t\treturn this;\n\t\t};\n\n\t\tthis.toString = function() {\n\t\t\tvar result = '';\n\t\t\tif(this.scheme !== null) { result = result + this.scheme + ':'; }\n\t\t\tif(this.authority !== null) { result = result + '//' + this.authority; }\n\t\t\tif(this.path !== null) { result = result + this.path; }\n\t\t\tif(this.query !== null) { result = result + '?' + this.query; }\n\t\t\tif(this.fragment !== null) { result = result + '#' + this.fragment; }\n\t\t\treturn result;\n\t\t};\n\n\t\tthis.toAbsolute = function(base) {\n\t\t\tvar base = new jscolor.URI(base);\n\t\t\tvar r = this;\n\t\t\tvar t = new jscolor.URI;\n\n\t\t\tif(base.scheme === null) { return false; }\n\n\t\t\tif(r.scheme !== null && r.scheme.toLowerCase() === base.scheme.toLowerCase()) {\n\t\t\t\tr.scheme = null;\n\t\t\t}\n\n\t\t\tif(r.scheme !== null) {\n\t\t\t\tt.scheme = r.scheme;\n\t\t\t\tt.authority = r.authority;\n\t\t\t\tt.path = removeDotSegments(r.path);\n\t\t\t\tt.query = r.query;\n\t\t\t} else {\n\t\t\t\tif(r.authority !== null) {\n\t\t\t\t\tt.authority = r.authority;\n\t\t\t\t\tt.path = removeDotSegments(r.path);\n\t\t\t\t\tt.query = r.query;\n\t\t\t\t} else {\n\t\t\t\t\tif(r.path === '') { // TODO: == or === ?\n\t\t\t\t\t\tt.path = base.path;\n\t\t\t\t\t\tif(r.query !== null) {\n\t\t\t\t\t\t\tt.query = r.query;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tt.query = base.query;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(r.path.substr(0,1) === '/') {\n\t\t\t\t\t\t\tt.path = removeDotSegments(r.path);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(base.authority !== null && base.path === '') { // TODO: == or === ?\n\t\t\t\t\t\t\t\tt.path = '/'+r.path;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tt.path = base.path.replace(/[^\\/]+$/,'')+r.path;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tt.path = removeDotSegments(t.path);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt.query = r.query;\n\t\t\t\t\t}\n\t\t\t\t\tt.authority = base.authority;\n\t\t\t\t}\n\t\t\t\tt.scheme = base.scheme;\n\t\t\t}\n\t\t\tt.fragment = r.fragment;\n\n\t\t\treturn t;\n\t\t};\n\n\t\tfunction removeDotSegments(path) {\n\t\t\tvar out = '';\n\t\t\twhile(path) {\n\t\t\t\tif(path.substr(0,3)==='../' || path.substr(0,2)==='./') {\n\t\t\t\t\tpath = path.replace(/^\\.+/,'').substr(1);\n\t\t\t\t} else if(path.substr(0,3)==='/./' || path==='/.') {\n\t\t\t\t\tpath = '/'+path.substr(3);\n\t\t\t\t} else if(path.substr(0,4)==='/../' || path==='/..') {\n\t\t\t\t\tpath = '/'+path.substr(4);\n\t\t\t\t\tout = out.replace(/\\/?[^\\/]*$/, '');\n\t\t\t\t} else if(path==='.' || path==='..') {\n\t\t\t\t\tpath = '';\n\t\t\t\t} else {\n\t\t\t\t\tvar rm = path.match(/^\\/?[^\\/]*/)[0];\n\t\t\t\t\tpath = path.substr(rm.length);\n\t\t\t\t\tout = out + rm;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t}\n\n\t\tif(uri) {\n\t\t\tthis.parse(uri);\n\t\t}\n\n\t},\n\n\n\t/*\n\t * Usage example:\n\t * var myColor = new jscolor.color(myInputElement)\n\t */\n\n\tcolor : function(target, prop) {\n\n\n\t\tthis.required = true; // refuse empty values?\n\t\tthis.adjust = true; // adjust value to uniform notation?\n\t\tthis.hash = false; // prefix color with # symbol?\n\t\tthis.caps = true; // uppercase?\n\t\tthis.slider = true; // show the value/saturation slider?\n\t\tthis.valueElement = target; // value holder\n\t\tthis.styleElement = target; // where to reflect current color\n\t\tthis.onImmediateChange = null; // onchange callback (can be either string or function)\n\t\tthis.hsv = [0, 0, 1]; // read-only  0-6, 0-1, 0-1\n\t\tthis.rgb = [1, 1, 1]; // read-only  0-1, 0-1, 0-1\n\n\t\tthis.pickerOnfocus = true; // display picker on focus?\n\t\tthis.pickerMode = 'HSV'; // HSV | HVS\n\t\tthis.pickerPosition = 'bottom'; // left | right | top | bottom\n\t\tthis.pickerSmartPosition = true; // automatically adjust picker position when necessary\n\t\tthis.pickerButtonHeight = 20; // px\n\t\tthis.pickerClosable = false;\n\t\tthis.pickerCloseText = 'Close';\n\t\tthis.pickerButtonColor = 'ButtonText'; // px\n\t\tthis.pickerFace = 10; // px\n\t\tthis.pickerFaceColor = 'ThreeDFace'; // CSS color\n\t\tthis.pickerBorder = 1; // px\n\t\tthis.pickerBorderColor = 'ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight'; // CSS color\n\t\tthis.pickerInset = 1; // px\n\t\tthis.pickerInsetColor = 'ThreeDShadow ThreeDHighlight ThreeDHighlight ThreeDShadow'; // CSS color\n\t\tthis.pickerZIndex = 10000;\n\n\n\t\tfor(var p in prop) {\n\t\t\tif(prop.hasOwnProperty(p)) {\n\t\t\t\tthis[p] = prop[p];\n\t\t\t}\n\t\t}\n\n\n\t\tthis.hidePicker = function() {\n\t\t\tif(isPickerOwner()) {\n\t\t\t\tremovePicker();\n\t\t\t}\n\t\t};\n\n\n\t\tthis.showPicker = function() {\n\t\t\tif(!isPickerOwner()) {\n\t\t\t\tvar tp = jscolor.getElementPos(target); // target pos\n\t\t\t\tvar ts = jscolor.getElementSize(target); // target size\n\t\t\t\tvar vp = jscolor.getViewPos(); // view pos\n\t\t\t\tvar vs = jscolor.getViewSize(); // view size\n\t\t\t\tvar ps = getPickerDims(this); // picker size\n\t\t\t\tvar a, b, c;\n\t\t\t\tswitch(this.pickerPosition.toLowerCase()) {\n\t\t\t\t\tcase 'left': a=1; b=0; c=-1; break;\n\t\t\t\t\tcase 'right':a=1; b=0; c=1; break;\n\t\t\t\t\tcase 'top':  a=0; b=1; c=-1; break;\n\t\t\t\t\tdefault:     a=0; b=1; c=1; break;\n\t\t\t\t}\n\t\t\t\tvar l = (ts[b]+ps[b])/2;\n\n\t\t\t\t// picker pos\n\t\t\t\tif (!this.pickerSmartPosition) {\n\t\t\t\t\tvar pp = [\n\t\t\t\t\t\ttp[a],\n\t\t\t\t\t\ttp[b]+ts[b]-l+l*c\n\t\t\t\t\t];\n\t\t\t\t} else {\n\t\t\t\t\tvar pp = [\n\t\t\t\t\t\t-vp[a]+tp[a]+ps[a] > vs[a] ?\n\t\t\t\t\t\t\t(-vp[a]+tp[a]+ts[a]/2 > vs[a]/2 && tp[a]+ts[a]-ps[a] >= 0 ? tp[a]+ts[a]-ps[a] : tp[a]) :\n\t\t\t\t\t\t\ttp[a],\n\t\t\t\t\t\t-vp[b]+tp[b]+ts[b]+ps[b]-l+l*c > vs[b] ?\n\t\t\t\t\t\t\t(-vp[b]+tp[b]+ts[b]/2 > vs[b]/2 && tp[b]+ts[b]-l-l*c >= 0 ? tp[b]+ts[b]-l-l*c : tp[b]+ts[b]-l+l*c) :\n\t\t\t\t\t\t\t(tp[b]+ts[b]-l+l*c >= 0 ? tp[b]+ts[b]-l+l*c : tp[b]+ts[b]-l-l*c)\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t\tdrawPicker(pp[a], pp[b]);\n\t\t\t}\n\t\t};\n\n\n\t\tthis.importColor = function() {\n\t\t\tif(!valueElement) {\n\t\t\t\tthis.exportColor();\n\t\t\t} else {\n\t\t\t\tif(!this.adjust) {\n\t\t\t\t\tif(!this.fromString(valueElement.value, leaveValue)) {\n\t\t\t\t\t\tstyleElement.style.backgroundColor = styleElement.jscStyle.backgroundColor;\n\t\t\t\t\t\tstyleElement.style.color = styleElement.jscStyle.color;\n\t\t\t\t\t\tthis.exportColor(leaveValue | leaveStyle);\n\t\t\t\t\t}\n\t\t\t\t} else if(!this.required && /^\\s*$/.test(valueElement.value)) {\n\t\t\t\t\tvalueElement.value = '';\n\t\t\t\t\tstyleElement.style.backgroundColor = styleElement.jscStyle.backgroundColor;\n\t\t\t\t\tstyleElement.style.color = styleElement.jscStyle.color;\n\t\t\t\t\tthis.exportColor(leaveValue | leaveStyle);\n\n\t\t\t\t} else if(this.fromString(valueElement.value)) {\n\t\t\t\t\t// OK\n\t\t\t\t} else {\n\t\t\t\t\tthis.exportColor();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\t\tthis.exportColor = function(flags) {\n\t\t\tif(!(flags & leaveValue) && valueElement) {\n\t\t\t\tvar value = this.toString();\n\t\t\t\tif(this.caps) { value = value.toUpperCase(); }\n\t\t\t\tif(this.hash) { value = '#'+value; }\n\t\t\t\tvalueElement.value = value;\n\t\t\t}\n\t\t\tif(!(flags & leaveStyle) && styleElement) {\n\t\t\t\tstyleElement.style.backgroundColor =\n\t\t\t\t\t'#'+this.toString();\n\t\t\t\tstyleElement.style.color =\n\t\t\t\t\t0.213 * this.rgb[0] +\n\t\t\t\t\t0.715 * this.rgb[1] +\n\t\t\t\t\t0.072 * this.rgb[2]\n\t\t\t\t\t< 0.5 ? '#FFF' : '#000';\n\t\t\t}\n\t\t\tif(!(flags & leavePad) && isPickerOwner()) {\n\t\t\t\tredrawPad();\n\t\t\t}\n\t\t\tif(!(flags & leaveSld) && isPickerOwner()) {\n\t\t\t\tredrawSld();\n\t\t\t}\n\t\t};\n\n\n\t\tthis.fromHSV = function(h, s, v, flags) { // null = don't change\n\t\t\th<0 && (h=0) || h>6 && (h=6);\n\t\t\ts<0 && (s=0) || s>1 && (s=1);\n\t\t\tv<0 && (v=0) || v>1 && (v=1);\n\t\t\tthis.rgb = HSV_RGB(\n\t\t\t\th===null ? this.hsv[0] : (this.hsv[0]=h),\n\t\t\t\ts===null ? this.hsv[1] : (this.hsv[1]=s),\n\t\t\t\tv===null ? this.hsv[2] : (this.hsv[2]=v)\n\t\t\t);\n\t\t\tthis.exportColor(flags);\n\t\t};\n\n\n\t\tthis.fromRGB = function(r, g, b, flags) { // null = don't change\n\t\t\tr<0 && (r=0) || r>1 && (r=1);\n\t\t\tg<0 && (g=0) || g>1 && (g=1);\n\t\t\tb<0 && (b=0) || b>1 && (b=1);\n\t\t\tvar hsv = RGB_HSV(\n\t\t\t\tr===null ? this.rgb[0] : (this.rgb[0]=r),\n\t\t\t\tg===null ? this.rgb[1] : (this.rgb[1]=g),\n\t\t\t\tb===null ? this.rgb[2] : (this.rgb[2]=b)\n\t\t\t);\n\t\t\tif(hsv[0] !== null) {\n\t\t\t\tthis.hsv[0] = hsv[0];\n\t\t\t}\n\t\t\tif(hsv[2] !== 0) {\n\t\t\t\tthis.hsv[1] = hsv[1];\n\t\t\t}\n\t\t\tthis.hsv[2] = hsv[2];\n\t\t\tthis.exportColor(flags);\n\t\t};\n\n\n\t\tthis.fromString = function(hex, flags) {\n\t\t\tvar m = hex.match(/^\\W*([0-9A-F]{3}([0-9A-F]{3})?)\\W*$/i);\n\t\t\tif(!m) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tif(m[1].length === 6) { // 6-char notation\n\t\t\t\t\tthis.fromRGB(\n\t\t\t\t\t\tparseInt(m[1].substr(0,2),16) / 255,\n\t\t\t\t\t\tparseInt(m[1].substr(2,2),16) / 255,\n\t\t\t\t\t\tparseInt(m[1].substr(4,2),16) / 255,\n\t\t\t\t\t\tflags\n\t\t\t\t\t);\n\t\t\t\t} else { // 3-char notation\n\t\t\t\t\tthis.fromRGB(\n\t\t\t\t\t\tparseInt(m[1].charAt(0)+m[1].charAt(0),16) / 255,\n\t\t\t\t\t\tparseInt(m[1].charAt(1)+m[1].charAt(1),16) / 255,\n\t\t\t\t\t\tparseInt(m[1].charAt(2)+m[1].charAt(2),16) / 255,\n\t\t\t\t\t\tflags\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\n\n\t\tthis.toString = function() {\n\t\t\treturn (\n\t\t\t\t(0x100 | Math.round(255*this.rgb[0])).toString(16).substr(1) +\n\t\t\t\t(0x100 | Math.round(255*this.rgb[1])).toString(16).substr(1) +\n\t\t\t\t(0x100 | Math.round(255*this.rgb[2])).toString(16).substr(1)\n\t\t\t);\n\t\t};\n\n\n\t\tfunction RGB_HSV(r, g, b) {\n\t\t\tvar n = Math.min(Math.min(r,g),b);\n\t\t\tvar v = Math.max(Math.max(r,g),b);\n\t\t\tvar m = v - n;\n\t\t\tif(m === 0) { return [ null, 0, v ]; }\n\t\t\tvar h = r===n ? 3+(b-g)/m : (g===n ? 5+(r-b)/m : 1+(g-r)/m);\n\t\t\treturn [ h===6?0:h, m/v, v ];\n\t\t}\n\n\n\t\tfunction HSV_RGB(h, s, v) {\n\t\t\tif(h === null) { return [ v, v, v ]; }\n\t\t\tvar i = Math.floor(h);\n\t\t\tvar f = i%2 ? h-i : 1-(h-i);\n\t\t\tvar m = v * (1 - s);\n\t\t\tvar n = v * (1 - s*f);\n\t\t\tswitch(i) {\n\t\t\t\tcase 6:\n\t\t\t\tcase 0: return [v,n,m];\n\t\t\t\tcase 1: return [n,v,m];\n\t\t\t\tcase 2: return [m,v,n];\n\t\t\t\tcase 3: return [m,n,v];\n\t\t\t\tcase 4: return [n,m,v];\n\t\t\t\tcase 5: return [v,m,n];\n\t\t\t}\n\t\t}\n\n\n\t\tfunction removePicker() {\n\t\t\tdelete jscolor.picker.owner;\n\t\t\tdocument.getElementsByTagName('body')[0].removeChild(jscolor.picker.boxB);\n\t\t}\n\n\n\t\tfunction drawPicker(x, y) {\n\t\t\tif(!jscolor.picker) {\n\t\t\t\tjscolor.picker = {\n\t\t\t\t\tbox : document.createElement('div'),\n\t\t\t\t\tboxB : document.createElement('div'),\n\t\t\t\t\tpad : document.createElement('div'),\n\t\t\t\t\tpadB : document.createElement('div'),\n\t\t\t\t\tpadM : document.createElement('div'),\n\t\t\t\t\tsld : document.createElement('div'),\n\t\t\t\t\tsldB : document.createElement('div'),\n\t\t\t\t\tsldM : document.createElement('div'),\n\t\t\t\t\tbtn : document.createElement('div'),\n\t\t\t\t\tbtnS : document.createElement('span'),\n\t\t\t\t\tbtnT : document.createTextNode(THIS.pickerCloseText)\n\t\t\t\t};\n\t\t\t\tfor(var i=0,segSize=4; i<jscolor.images.sld[1]; i+=segSize) {\n\t\t\t\t\tvar seg = document.createElement('div');\n\t\t\t\t\tseg.style.height = segSize+'px';\n\t\t\t\t\tseg.style.fontSize = '1px';\n\t\t\t\t\tseg.style.lineHeight = '0';\n\t\t\t\t\tjscolor.picker.sld.appendChild(seg);\n\t\t\t\t}\n\t\t\t\tjscolor.picker.sldB.appendChild(jscolor.picker.sld);\n\t\t\t\tjscolor.picker.box.appendChild(jscolor.picker.sldB);\n\t\t\t\tjscolor.picker.box.appendChild(jscolor.picker.sldM);\n\t\t\t\tjscolor.picker.padB.appendChild(jscolor.picker.pad);\n\t\t\t\tjscolor.picker.box.appendChild(jscolor.picker.padB);\n\t\t\t\tjscolor.picker.box.appendChild(jscolor.picker.padM);\n\t\t\t\tjscolor.picker.btnS.appendChild(jscolor.picker.btnT);\n\t\t\t\tjscolor.picker.btn.appendChild(jscolor.picker.btnS);\n\t\t\t\tjscolor.picker.box.appendChild(jscolor.picker.btn);\n\t\t\t\tjscolor.picker.boxB.appendChild(jscolor.picker.box);\n\t\t\t}\n\n\t\t\tvar p = jscolor.picker;\n\n\t\t\t// controls interaction\n\t\t\tp.box.onmouseup =\n\t\t\tp.box.onmouseout = function() { target.focus(); };\n\t\t\tp.box.onmousedown = function() { abortBlur=true; };\n\t\t\tp.box.onmousemove = function(e) {\n\t\t\t\tif (holdPad || holdSld) {\n\t\t\t\t\tholdPad && setPad(e);\n\t\t\t\t\tholdSld && setSld(e);\n\t\t\t\t\tif (document.selection) {\n\t\t\t\t\t\tdocument.selection.empty();\n\t\t\t\t\t} else if (window.getSelection) {\n\t\t\t\t\t\twindow.getSelection().removeAllRanges();\n\t\t\t\t\t}\n\t\t\t\t\tdispatchImmediateChange();\n\t\t\t\t}\n\t\t\t};\n\t\t\tp.padM.onmouseup =\n\t\t\tp.padM.onmouseout = function() { if(holdPad) { holdPad=false; jscolor.fireEvent(valueElement,'change'); } };\n\t\t\tp.padM.onmousedown = function(e) {\n\t\t\t\tholdPad=true;\n\t\t\t\tsetPad(e);\n\t\t\t\tdispatchImmediateChange();\n\t\t\t};\n\t\t\tp.sldM.onmouseup =\n\t\t\tp.sldM.onmouseout = function() { if(holdSld) { holdSld=false; jscolor.fireEvent(valueElement,'change'); } };\n\t\t\tp.sldM.onmousedown = function(e) {\n\t\t\t\tholdSld=true;\n\t\t\t\tsetSld(e);\n\t\t\t\tdispatchImmediateChange();\n\t\t\t};\n\n\t\t\t// picker\n\t\t\tvar dims = getPickerDims(THIS);\n\t\t\tp.box.style.width = dims[0] + 'px';\n\t\t\tp.box.style.height = dims[1] + 'px';\n\n\t\t\t// picker border\n\t\t\tp.boxB.style.position = 'absolute';\n\t\t\tp.boxB.style.clear = 'both';\n\t\t\tp.boxB.style.left = x+'px';\n\t\t\tp.boxB.style.top = y+'px';\n\t\t\tp.boxB.style.zIndex = THIS.pickerZIndex;\n\t\t\t//p.boxB.style.border = THIS.pickerBorder+'px solid';\n\t\t\t//p.boxB.style.borderColor = THIS.pickerBorderColor;\n\t\t\t//p.boxB.style.background = THIS.pickerFaceColor;\n\t\t\tp.boxB.className = 'colorMenu';\n\n\t\t\t// pad image\n\t\t\tp.pad.style.width = jscolor.images.pad[0]+'px';\n\t\t\tp.pad.style.height = jscolor.images.pad[1]+'px';\n\n\t\t\t// pad border\n\t\t\tp.padB.style.position = 'absolute';\n\t\t\tp.padB.style.left = THIS.pickerFace+'px';\n\t\t\tp.padB.style.top = THIS.pickerFace+'px';\n\t\t\tp.padB.style.border = THIS.pickerInset+'px solid';\n\t\t\tp.padB.style.borderColor = THIS.pickerInsetColor;\n\n\t\t\t// pad mouse area\n\t\t\tp.padM.style.position = 'absolute';\n\t\t\tp.padM.style.left = '0';\n\t\t\tp.padM.style.top = '0';\n\t\t\tp.padM.style.width = THIS.pickerFace + 2*THIS.pickerInset + jscolor.images.pad[0] + jscolor.images.arrow[0] + 'px';\n\t\t\tp.padM.style.height = p.box.style.height;\n\t\t\tp.padM.style.cursor = 'crosshair';\n\n\t\t\t// slider image\n\t\t\tp.sld.style.overflow = 'hidden';\n\t\t\tp.sld.style.width = jscolor.images.sld[0]+'px';\n\t\t\tp.sld.style.height = jscolor.images.sld[1]+'px';\n\n\t\t\t// slider border\n\t\t\tp.sldB.style.display = THIS.slider ? 'block' : 'none';\n\t\t\tp.sldB.style.position = 'absolute';\n\t\t\tp.sldB.style.right = THIS.pickerFace+'px';\n\t\t\tp.sldB.style.top = THIS.pickerFace+'px';\n\t\t\tp.sldB.style.border = THIS.pickerInset+'px solid';\n\t\t\tp.sldB.style.borderColor = THIS.pickerInsetColor;\n\n\t\t\t// slider mouse area\n\t\t\tp.sldM.style.display = THIS.slider ? 'block' : 'none';\n\t\t\tp.sldM.style.position = 'absolute';\n\t\t\tp.sldM.style.right = '0';\n\t\t\tp.sldM.style.top = '0';\n\t\t\tp.sldM.style.width = jscolor.images.sld[0] + jscolor.images.arrow[0] + THIS.pickerFace + 2*THIS.pickerInset + 'px';\n\t\t\tp.sldM.style.height = p.box.style.height;\n\t\t\ttry {\n\t\t\t\tp.sldM.style.cursor = 'pointer';\n\t\t\t} catch(eOldIE) {\n\t\t\t\tp.sldM.style.cursor = 'hand';\n\t\t\t}\n\n\t\t\t// \"close\" button\n\t\t\tfunction setBtnBorder() {\n\t\t\t\tvar insetColors = THIS.pickerInsetColor.split(/\\s+/);\n\t\t\t\tvar pickerOutsetColor = insetColors.length < 2 ? insetColors[0] : insetColors[1] + ' ' + insetColors[0] + ' ' + insetColors[0] + ' ' + insetColors[1];\n\t\t\t\tp.btn.style.borderColor = pickerOutsetColor;\n\t\t\t}\n\t\t\tp.btn.style.display = THIS.pickerClosable ? 'block' : 'none';\n\t\t\tp.btn.style.position = 'absolute';\n\t\t\tp.btn.style.left = THIS.pickerFace + 'px';\n\t\t\tp.btn.style.bottom = THIS.pickerFace + 'px';\n\t\t\tp.btn.style.padding = '0 15px';\n\t\t\tp.btn.style.height = '18px';\n\t\t\tp.btn.style.border = THIS.pickerInset + 'px solid';\n\t\t\tsetBtnBorder();\n\t\t\tp.btn.style.color = THIS.pickerButtonColor;\n\t\t\tp.btn.style.font = '12px sans-serif';\n\t\t\tp.btn.style.textAlign = 'center';\n\t\t\ttry {\n\t\t\t\tp.btn.style.cursor = 'pointer';\n\t\t\t} catch(eOldIE) {\n\t\t\t\tp.btn.style.cursor = 'hand';\n\t\t\t}\n\t\t\tp.btn.onmousedown = function () {\n\t\t\t\tTHIS.hidePicker();\n\t\t\t};\n\t\t\tp.btnS.style.lineHeight = p.btn.style.height;\n\n\t\t\t// load images in optimal order\n\t\t\tswitch(modeID) {\n\t\t\t\tcase 0: var padImg = 'hs.png'; break;\n\t\t\t\tcase 1: var padImg = 'hv.png'; break;\n\t\t\t}\n\t\t\tp.padM.style.backgroundImage = \"url('\"+jscolor.getDir()+\"cross.gif')\";\n\t\t\tp.padM.style.backgroundRepeat = \"no-repeat\";\n\t\t\tp.sldM.style.backgroundImage = \"url('\"+jscolor.getDir()+\"arrow.gif')\";\n\t\t\tp.sldM.style.backgroundRepeat = \"no-repeat\";\n\t\t\tp.pad.style.backgroundImage = \"url('\"+jscolor.getDir()+padImg+\"')\";\n\t\t\tp.pad.style.backgroundRepeat = \"no-repeat\";\n\t\t\tp.pad.style.backgroundPosition = \"0 0\";\n\n\t\t\t// place pointers\n\t\t\tredrawPad();\n\t\t\tredrawSld();\n\n\t\t\tjscolor.picker.owner = THIS;\n\t\t\tdocument.getElementsByTagName('body')[0].appendChild(p.boxB);\n\t\t}\n\n\n\t\tfunction getPickerDims(o) {\n\t\t\tvar dims = [\n\t\t\t\t2*o.pickerInset + 2*o.pickerFace + jscolor.images.pad[0] +\n\t\t\t\t\t(o.slider ? 2*o.pickerInset + 2*jscolor.images.arrow[0] + jscolor.images.sld[0] : 0),\n\t\t\t\to.pickerClosable ?\n\t\t\t\t\t4*o.pickerInset + 3*o.pickerFace + jscolor.images.pad[1] + o.pickerButtonHeight :\n\t\t\t\t\t2*o.pickerInset + 2*o.pickerFace + jscolor.images.pad[1]\n\t\t\t];\n\t\t\treturn dims;\n\t\t}\n\n\n\t\tfunction redrawPad() {\n\t\t\t// redraw the pad pointer\n\t\t\tswitch(modeID) {\n\t\t\t\tcase 0: var yComponent = 1; break;\n\t\t\t\tcase 1: var yComponent = 2; break;\n\t\t\t}\n\t\t\tvar x = Math.round((THIS.hsv[0]/6) * (jscolor.images.pad[0]-1));\n\t\t\tvar y = Math.round((1-THIS.hsv[yComponent]) * (jscolor.images.pad[1]-1));\n\t\t\tjscolor.picker.padM.style.backgroundPosition =\n\t\t\t\t(THIS.pickerFace+THIS.pickerInset+x - Math.floor(jscolor.images.cross[0]/2)) + 'px ' +\n\t\t\t\t(THIS.pickerFace+THIS.pickerInset+y - Math.floor(jscolor.images.cross[1]/2)) + 'px';\n\n\t\t\t// redraw the slider image\n\t\t\tvar seg = jscolor.picker.sld.childNodes;\n\n\t\t\tswitch(modeID) {\n\t\t\t\tcase 0:\n\t\t\t\t\tvar rgb = HSV_RGB(THIS.hsv[0], THIS.hsv[1], 1);\n\t\t\t\t\tfor(var i=0; i<seg.length; i+=1) {\n\t\t\t\t\t\tseg[i].style.backgroundColor = 'rgb('+\n\t\t\t\t\t\t\t(rgb[0]*(1-i/seg.length)*100)+'%,'+\n\t\t\t\t\t\t\t(rgb[1]*(1-i/seg.length)*100)+'%,'+\n\t\t\t\t\t\t\t(rgb[2]*(1-i/seg.length)*100)+'%)';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tvar rgb, s, c = [ THIS.hsv[2], 0, 0 ];\n\t\t\t\t\tvar i = Math.floor(THIS.hsv[0]);\n\t\t\t\t\tvar f = i%2 ? THIS.hsv[0]-i : 1-(THIS.hsv[0]-i);\n\t\t\t\t\tswitch(i) {\n\t\t\t\t\t\tcase 6:\n\t\t\t\t\t\tcase 0: rgb=[0,1,2]; break;\n\t\t\t\t\t\tcase 1: rgb=[1,0,2]; break;\n\t\t\t\t\t\tcase 2: rgb=[2,0,1]; break;\n\t\t\t\t\t\tcase 3: rgb=[2,1,0]; break;\n\t\t\t\t\t\tcase 4: rgb=[1,2,0]; break;\n\t\t\t\t\t\tcase 5: rgb=[0,2,1]; break;\n\t\t\t\t\t}\n\t\t\t\t\tfor(var i=0; i<seg.length; i+=1) {\n\t\t\t\t\t\ts = 1 - 1/(seg.length-1)*i;\n\t\t\t\t\t\tc[1] = c[0] * (1 - s*f);\n\t\t\t\t\t\tc[2] = c[0] * (1 - s);\n\t\t\t\t\t\tseg[i].style.backgroundColor = 'rgb('+\n\t\t\t\t\t\t\t(c[rgb[0]]*100)+'%,'+\n\t\t\t\t\t\t\t(c[rgb[1]]*100)+'%,'+\n\t\t\t\t\t\t\t(c[rgb[2]]*100)+'%)';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t\tfunction redrawSld() {\n\t\t\t// redraw the slider pointer\n\t\t\tswitch(modeID) {\n\t\t\t\tcase 0: var yComponent = 2; break;\n\t\t\t\tcase 1: var yComponent = 1; break;\n\t\t\t}\n\t\t\tvar y = Math.round((1-THIS.hsv[yComponent]) * (jscolor.images.sld[1]-1));\n\t\t\tjscolor.picker.sldM.style.backgroundPosition =\n\t\t\t\t'0 ' + (THIS.pickerFace+THIS.pickerInset+y - Math.floor(jscolor.images.arrow[1]/2)) + 'px';\n\t\t}\n\n\n\t\tfunction isPickerOwner() {\n\t\t\treturn jscolor.picker && jscolor.picker.owner === THIS;\n\t\t}\n\n\n\t\tfunction blurTarget() {\n\t\t\tif(valueElement === target) {\n\t\t\t\tTHIS.importColor();\n\t\t\t}\n\t\t\tif(THIS.pickerOnfocus) {\n\t\t\t\tTHIS.hidePicker();\n\t\t\t}\n\t\t}\n\n\n\t\tfunction blurValue() {\n\t\t\tif(valueElement !== target) {\n\t\t\t\tTHIS.importColor();\n\t\t\t}\n\t\t}\n\n\n\t\tfunction setPad(e) {\n\t\t\tvar mpos = jscolor.getRelMousePos(e);\n\t\t\tvar x = mpos.x - THIS.pickerFace - THIS.pickerInset;\n\t\t\tvar y = mpos.y - THIS.pickerFace - THIS.pickerInset;\n\t\t\tswitch(modeID) {\n\t\t\t\tcase 0: THIS.fromHSV(x*(6/(jscolor.images.pad[0]-1)), 1 - y/(jscolor.images.pad[1]-1), null, leaveSld); break;\n\t\t\t\tcase 1: THIS.fromHSV(x*(6/(jscolor.images.pad[0]-1)), null, 1 - y/(jscolor.images.pad[1]-1), leaveSld); break;\n\t\t\t}\n\t\t}\n\n\n\t\tfunction setSld(e) {\n\t\t\tvar mpos = jscolor.getRelMousePos(e);\n\t\t\tvar y = mpos.y - THIS.pickerFace - THIS.pickerInset;\n\t\t\tswitch(modeID) {\n\t\t\t\tcase 0: THIS.fromHSV(null, null, 1 - y/(jscolor.images.sld[1]-1), leavePad); break;\n\t\t\t\tcase 1: THIS.fromHSV(null, 1 - y/(jscolor.images.sld[1]-1), null, leavePad); break;\n\t\t\t}\n\t\t}\n\n\n\t\tfunction dispatchImmediateChange() {\n\t\t\tif (THIS.onImmediateChange) {\n\t\t\t\tif (typeof THIS.onImmediateChange === 'string') {\n\t\t\t\t\teval(THIS.onImmediateChange);\n\t\t\t\t} else {\n\t\t\t\t\tTHIS.onImmediateChange(THIS);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tvar THIS = this;\n\t\tvar modeID = this.pickerMode.toLowerCase()==='hvs' ? 1 : 0;\n\t\tvar abortBlur = false;\n\t\tvar\n\t\t\tvalueElement = jscolor.fetchElement(this.valueElement),\n\t\t\tstyleElement = jscolor.fetchElement(this.styleElement);\n\t\tvar\n\t\t\tholdPad = false,\n\t\t\tholdSld = false;\n\t\tvar\n\t\t\tleaveValue = 1<<0,\n\t\t\tleaveStyle = 1<<1,\n\t\t\tleavePad = 1<<2,\n\t\t\tleaveSld = 1<<3;\n\n\t\t// target\n\t\tjscolor.addEvent(target, 'focus', function() {\n\t\t\tif(THIS.pickerOnfocus) { THIS.showPicker(); }\n\t\t});\n\t\tjscolor.addEvent(target, 'blur', function() {\n\t\t\tif(!abortBlur) {\n\t\t\t\twindow.setTimeout(function(){ abortBlur || blurTarget(); abortBlur=false; }, 0);\n\t\t\t} else {\n\t\t\t\tabortBlur = false;\n\t\t\t}\n\t\t});\n\n\t\t// valueElement\n\t\tif(valueElement) {\n\t\t\tvar updateField = function() {\n\t\t\t\tTHIS.fromString(valueElement.value, leaveValue);\n\t\t\t\tdispatchImmediateChange();\n\t\t\t};\n\t\t\tjscolor.addEvent(valueElement, 'keyup', updateField);\n\t\t\tjscolor.addEvent(valueElement, 'input', updateField);\n\t\t\tjscolor.addEvent(valueElement, 'blur', blurValue);\n\t\t\tvalueElement.setAttribute('autocomplete', 'off');\n\t\t}\n\n\t\t// styleElement\n\t\tif(styleElement) {\n\t\t\tstyleElement.jscStyle = {\n\t\t\t\tbackgroundColor : styleElement.style.backgroundColor,\n\t\t\t\tcolor : styleElement.style.color\n\t\t\t};\n\t\t}\n\n\t\t// require images\n\t\tswitch(modeID) {\n\t\t\tcase 0: jscolor.requireImage('hs.png'); break;\n\t\t\tcase 1: jscolor.requireImage('hv.png'); break;\n\t\t}\n\t\tjscolor.requireImage('cross.gif');\n\t\tjscolor.requireImage('arrow.gif');\n\n\t\tthis.importColor();\n\t}\n\n};\n\n//jscolor.install();\nexports = jscolor;\n");
jsio.setCachedSrc('../node_modules/squill/Label.js',"jsio('from util.browser import $');\njsio('import squill.Widget');\njsio('import squill.models.bindings as bindings');\n\nexports = Class(squill.Widget, function() {\n\tthis._css = 'label';\n\tthis._def = {\n\t\tchildren: [{\n\t\t\tid: '_labelSpan',\n\t\t\ttag: 'span'\n\t\t}]\n\t}\n\n\tthis.buildWidget = function() {\n\t\tthis.setLabel(this.getI18n('label'));\n\n\t\tvar opts = this._opts;\n\t\tif (opts.format) {\n\t\t\tbindings.parseFormat(this, opts.format);\n\t\t}\n\t}\n\n\tthis.setData =\n\tthis.setValue =\n\tthis.setLabel =\n\tthis.setText = function(text) { if (/object/i.test(text)) debugger; $.setText(this._labelSpan, text); }\n\tthis.setHTML = function(html) { this._labelSpan.innerHTML = html; }\n});\n");
jsio.setCachedSrc('../node_modules/squill/List.js',"jsio('import .Window');\njsio('import .Widget');\njsio('from util.browser import $');\njsio('import .models.DataSource as DataSource');\njsio('import .Selection');\n\nvar List = exports = Class(Widget, function(supr) {\n\n\tthis._css = 'list';\n\n\tthis.init = function(opts) {\n\t\topts = merge(opts, {\n\t\t\tcontainSelf: true,\n\t\t\tcellSpacing: 0,\n\t\t\tisTiled: false,\n\t\t\tpreserveCells: false,\n\t\t\trenderAll: true,\n\t\t\tisFixedHeight: true,\n\t\t\tabsolutePosition: true,\n\t\t\tfilter: null\n\t\t});\n\n\t\tthis.needsRender = delay(this.render);\n\n\t\tif (opts.cellCtor) { this.setCellCtor(opts.cellCtor); }\n\t\tif (opts.dataSource) { this.setDataSource(opts.dataSource); }\n\t\tif (opts.sorter) { this.setSorter(opts.sorter); }\n\n\t\tthis._lastFilter = null;\n\n\t\tthis._filter = opts.filter;\n\t\tthis._cellsByID = {};\n\t\tthis._removed = {};\n\t\tthis._containSelf = opts.containSelf;\n\t\tthis._containerTag = opts.containerTag;\n\t\tthis._applyNodeOrder = opts.applyNodeOrder;\n\n\t\tthis._renderOpts = {\n\t\t\tcellSpacing: opts.cellSpacing || 0\n\t\t};\n\n\t\tthis.updateFilter = delay(function() {\n\t\t\tthis._lastFilter = null;\n\t\t\tthis.needsRender();\n\t\t}, 100);\n\n\t\tsupr(this, 'init', [opts]);\n\n\t\tif (opts.__result) {\n\t\t\topts.__result.addSubscription(this, 'select');\n\t\t}\n\n\t\tWindow.get().on('ViewportChange', bind(this, 'needsRender'));\n\t};\n\n\t// cells go in _container\n\tthis.getContainer = function() {\n\t\treturn this._container;\n\t};\n\n\tthis.getDataSource = function() {\n\t\treturn this._dataSource;\n\t};\n\n\tthis.setModel = function (path, value) {\n\t\tif (arguments.length == 1) {\n\t\t\tthis.setDataSource(arguments[0]);\n\t\t} else {\n\t\t\treturn supr(this, 'setModel', arguments);\n\t\t}\n\t};\n\n\tthis.setData = function (data) {\n\t\tif (!this._dataSource) {\n\t\t\tthis.setDataSource(new DataSource({sorter: this._sorter}));\n\t\t} else {\n\t\t\tthis._dataSource.clear();\n\t\t}\n\n\t\tif (data) {\n\t\t\tvar items;\n\t\t\tif (Array.isArray(data)) {\n\t\t\t\titems = data.map(function (data, index) { return {id: index, data: data}; });\n\t\t\t} else {\n\t\t\t\titems = Object.keys(data).map(function (key) {\n\t\t\t\t\treturn {id: key, data: data[key]};\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis._dataSource.add(items);\n\t\t}\n\n\t\tthis.needsRender();\n\t};\n\n\tthis.setDataSource = function(dataSource) {\n\t\tif (this._dataSource == dataSource) { return; }\n\n\t\tif (this._dataSource) {\n\t\t\tthis._dataSource.unsubscribe('Update', this);\n\t\t\tthis._dataSource.unsubscribe('Remove', this);\n\t\t\tthis.clear();\n\t\t}\n\n\t\tthis._dataSource = dataSource;\n\t\tthis._dataSource.subscribe('Update', this, 'onUpdateItem');\n\t\tthis._dataSource.subscribe('Remove', this, 'onRemoveItem');\n\n\t\tthis.needsRender();\n\t};\n\n\tthis.onUpdateItem = function(id, item) {\n\t\tvar cell = this._cellsByID[id];\n\t\tif (cell && cell.getItem() != item) { cell.setItem(item); }\n\t\tthis.updateFilter();\n\t};\n\n\tthis.onRemoveItem = function(id) {\n\t\tthis._removed[id] = true;\n\t\tthis.updateFilter();\n\t};\n\n\tthis.buildWidget = function() {\n\n\t\tthis._container = $({parent: this._el, className: this._opts.containerClassName, tag: this._containerTag || 'div'});\n\t\tif (this._containSelf && !this._applyNodeOrder) {\n\t\t\tthis._container.style.position = 'relative';\n\t\t}\n\n\t\tif (this._opts.selection || this._opts.selectable) {\n\t\t\tthis.setSelectable(this._opts.selection || this._opts.selectable);\n\t\t}\n\n\t\tthis.render();\n\t};\n\n\tthis.setValue = function (value) {\n\t\tif (this.selection) {\n\t\t\tthis.selection.select(value);\n\t\t}\n\t}\n\n\tthis.getValue = function () {\n\t\tif (this.selection) {\n\t\t\treturn this.selection.get();\n\t\t}\n\t}\n\n\tthis.setSelectable = function(selectable) {\n\t\tthis.selection = new Selection({\n\t\t\tparent: this,\n\t\t\ttype: selectable\n\t\t})\n\t\t\t.subscribe('Select', this, '_onSelected', true)\n\t\t\t.subscribe('Deselect', this, '_onSelected', false)\n\n\t\tthis.selection;\n\t};\n\n\tthis._onSelected = function(isSelected, item, id) {\n\t\tif (this._cellsByID[id] !== undefined) {\n\t\t\tthis._cellsByID[id].updateSelected();\n\n\t\t\tif (isSelected) {\n\t\t\t\tthis.publish('select', id, item);\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.setCellCtor = function(cellCtor) {\n\t\tif (cellCtor == this._cellCtor) { return; }\n\n\t\tthis._cellCtor = cellCtor;\n\t\tthis.clear();\n\t}\n\n\tthis.clear = function() {\n\t\tfor (var id in this._cellsByID) {\n\t\t\tvar cell = this._cellsByID[id];\n\t\t\tcell.remove();\n\t\t}\n\n\t\tthis._cellsByID = {};\n\t\tthis._renderedDataSource = null;\n\t\tthis._cellDim = null;\n\t};\n\n\tthis.getCell =\n\tthis.getCellById = function(id) {\n\t\treturn this._cellsByID[id];\n\t};\n\n\tthis.setCell =\n\tthis.setCellForId = function (id, cell) {\n\t\tthis._cellsByID[id] = cell;\n\t}\n\n\tthis.getCells = function() {\n\t\treturn this._cellsByID;\n\t};\n\n\tthis.setSorter = function(sorter) {\n\t\tthis._sorter = sorter;\n\t\tif (this._renderedDataSource) {\n\t\t\tthis._renderedDataSource.setSorter(sorter);\n\t\t}\n\t};\n\n\t// Filter moved to DataSource...\n\tthis.setFilter = function(filter) {\n\t\tthis._filter = filter;\n\t\tthis.needsRender();\n\t};\n\n\tthis.setFixedHeight = function(isFixedHeight) {\n\t\tthis._opts.isFixedHeight = isFixedHeight;\n\t};\n\n\tthis._applyDataSource = function() {\n\t\tif (this._filter != this._lastFilter) {\n\t\t\tthis._lastFilter = this._filter;\n\t\t\tthis._renderedDataSource = this._dataSource.getFilteredDataSource(bind(this, this._filter));\n\n\t\t\tthis._lastSorter = this._sorter;\n\t\t\tthis._renderedDataSource.setSorter(this._sorter);\n\t\t} else if (this._sorter != this._lastSorter) {\n\t\t\tif (!this._renderedDataSource || this._renderedDataSource == this._dataSource) {\n\t\t\t\tthis._filter = function () { return true; };\n\t\t\t\treturn this._applyDataSource();\n\t\t\t} else {\n\t\t\t\tthis._lastSorter = this._sorter;\n\t\t\t\tthis._renderedDataSource.setSorter(this._sorter);\n\t\t\t}\n\t\t}\n\n\t\tif (!this._renderedDataSource) {\n\t\t\tthis._renderedDataSource = this._dataSource;\n\t\t}\n\t};\n\n\tthis.onShow = function() { supr(this, 'onShow', arguments); this.needsRender(); }\n\n\t// just render all cells for now\n\tthis.render = function() {\n\t\tif (!this._dataSource) { return; }\n\t\tthis._applyDataSource();\n\t\tthis._renderedDataSource.sort();\n\n\t\tif (this._opts.renderAll) {\n\t\t\tthis.renderAllDelayed();\n\t\t} else if (this._opts.isFixedHeight) {\n\t\t\tthis.renderFixedHeight();\n\t\t} else {\n\t\t\tthis.renderDynamicHeight();\n\t\t}\n\n\t\tthis._removed = {};\n\t};\n\n\tthis.setCellDim = function(cellDim) {\n\t\tthis._cellDim = cellDim;\n\t};\n\n\tthis.getCellDim = function() {\n\t\tif (this._cellDim) { return this._cellDim; }\n\n\t\tif (this._opts.isFixedHeight) {\n\t\t\tvar item = this._renderedDataSource.getItemForIndex(0);\n\t\t\tif (!item) { return false; }\n\t\t\tvar key = item[this._renderedDataSource.getKey()],\n\t\t\t\tcell = this._cellsByID[key] || (this._cellsByID[key] = this._createCell(item)),\n\t\t\t\tdim = $.size(cell.getElement());\n\t\t\tif (dim.width == 0 || dim.height == 0) { return null; }\n\n\t\t\tvar cellSpacing = this._opts.cellSpacing;\n\t\t\tif (cellSpacing) {\n\t\t\t\tdim.width += cellSpacing;\n\t\t\t\tdim.height += cellSpacing;\n\t\t\t}\n\n\t\t\tthis._cellDim = dim;\n\t\t\treturn dim;\n\t\t} else {\n\t\t\tthrow 'unimplemented'\n\t\t}\n\t};\n\n\tthis._createCell = function(item) {\n\t\tvar key = this._dataSource.getKey(),\n\t\t\tcell = new this._cellCtor({\n\t\t\t\tparent: this,\n\t\t\t\tcontroller: this,\n\t\t\t\tkey: key,\n\t\t\t\titem: item\n\t\t\t});\n\n\t\tcell.getElement().setAttribute('squill-data-id', item[key]);\n\t\tcell.render();\n\t\treturn cell;\n\t};\n\n\tthis._nodeOrder = function() {\n\t\tvar container = this._container;\n\t\tvar src = this._renderedDataSource;\n\t\tvar key = src.key;\n\t\tvar dummy;\n\t\tvar cell;\n\t\tvar element;\n\t\tvar item;\n\t\tvar i;\n\n\t\tif (!container.childNodes.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tdummy = document.createElement('div');\n\n\t\tcontainer.insertBefore(dummy, container.childNodes[0]);\n\t\tfor (i = 0; i < src.length; i++) {\n\t\t\titem = src.getItemForIndex(i);\n\t\t\tcell = this._cellsByID[item[key]];\n\t\t\telement = cell.getElement();\n\t\t\tif (cell && element.parentNode) {\n\t\t\t\tcontainer.insertBefore(container.removeChild(element), dummy);\n\t\t\t}\n\t\t}\n\n\t\tcontainer.removeChild(dummy);\n\t};\n\n\tthis.renderAllDelayed = function() {\n\t\tvar src = this._renderedDataSource;\n\t\tif (!src) { return; }\n\n\t\tthis.updateRenderOpts();\n\t\tvar i = 0;\n\t\tfunction renderOne() {\n\t\t\tvar item = src.getItemForIndex(i);\n\t\t\tif (!item) { return false; }\n\n\t\t\tvar id = item[src.getKey()];\n\t\t\tvar cell = this._cellsByID[id];\n\t\t\tif (!cell) {\n\t\t\t\tcell = this._cellsByID[id] = this._createCell(item);\n\t\t\t} else {\n\t\t\t\tcell.render();\n\t\t\t}\n\t\t\t!this._applyNodeOrder && this.positionCell(cell, i);\n\t\t\t++i;\n\t\t\treturn true;\n\t\t}\n\n\t\tfunction renderMany() {\n\t\t\tif (this._renderManyTimeout) {\n\t\t\t\tclearTimeout(this._renderManyTimeout);\n\t\t\t\tthis._renderManyTimeout = void 0;\n\t\t\t}\n\n\t\t\tvar THRESHOLD = 50; // ms to render\n\t\t\tvar n = 0, t = +new Date();\n\t\t\twhile (n++ < 10 || +new Date() - t < THRESHOLD) {\n\t\t\t\tif (!renderOne.call(this)) {\n\t\t\t\t\tthis._applyNodeOrder && this._nodeOrder();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._renderManyTimeout = setTimeout(bind(this, renderMany), 100);\n\t\t}\n\n\t\tvar removed = this._removed;\n\t\tfor (var id in removed) {\n\t\t\tif (!src.getItemForID(id)) {\n\t\t\t\tvar cell = this._cellsByID[id];\n\t\t\t\tif (cell) {\n\t\t\t\t\tcell.remove();\n\t\t\t\t\tdelete this._cellsByID[id];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\trenderMany.call(this);\n\t}\n\n\tthis.setOffsetParent = function(offsetParent) {\n\t\tthis._opts.offsetParent = offsetParent;\n\t};\n\n\tthis.setTiled = function(tiled) {\n\t\tthis._opts.isTiled = tiled;\n\t\tthis._isTiled = tiled;\n\t};\n\n\tthis.updateRenderOpts = function() {\n\t\tvar r = this._renderOpts;\n\n\t\tr.offsetTop = this._containSelf ? 0 : this._container.offsetTop;\n\t\tr.offsetLeft = this._containSelf ? 0 : this._container.offsetLeft;\n\n\t\tvar parent = this._offsetParent || this.getOffsetParent();\n\t\tr.top = (parent.getAttribute('squill-scroller-top') || parent.scrollTop) - r.offsetTop;\n\t\tr.height = parent.offsetHeight;\n\t\tr.bottom = r.top + r.height;\n\n\t\tif (this._opts.isFixedHeight) {\n\t\t\tvar cellDim = this.getCellDim();\n\t\t\tif (!cellDim) { return false; }\n\t\t\tr.cellWidth = cellDim.width;\n\t\t\tr.cellHeight = cellDim.height;\n\t\t}\n\n\t\tvar n = r.numRows = this._renderedDataSource.length;\n\t\tif (this._opts.isFixedHeight) {\n\t\t\tif (this._opts.isTiled) {\n\t\t\t\tr.maxWidth = parent.offsetWidth - r.offsetLeft;\n\t\t\t\tr.numPerRow = Math.max(1, r.maxWidth / r.cellWidth | 0);\n\t\t\t\tr.numRows = Math.ceil(n / r.numPerRow);\n\t\t\t\tr.start = Math.max(0, (r.top / r.cellHeight | 0) * r.numPerRow);\n\t\t\t\tr.end = Math.ceil(r.bottom / r.cellHeight) * r.numPerRow;\n\t\t\t} else {\n\t\t\t\tr.start = Math.max(0, r.top / r.cellHeight | 0);\n\t\t\t\tr.end = (r.bottom / r.cellHeight + 1) | 0;\n\t\t\t}\n\t\t}\n\n\t\tif (!this._applyNodeOrder) {\n\t\t\tif (this._opts.absolutePosition) {\n\t\t\t\tthis._container.style.height = r.numRows * r.cellHeight + 'px';\n\t\t\t} else {\n\t\t\t\tthis._container.style.height = 'auto';\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tthis.positionCell = function(cell, i) {\n\t\tif (!this._opts.absolutePosition) { return; }\n\n\t\tvar r = this._renderOpts;\n\t\tvar el = cell.getElement();\n\t\tvar x, y;\n\n\t\tif (this._opts.isTiled) {\n\t\t\tx = i % r.numPerRow;\n\t\t\ty = (i / r.numPerRow) | 0;\n\t\t\tel.style.left = x * r.cellWidth + r.offsetLeft + 'px';\n\t\t\tel.style.top = y * r.cellHeight + r.offsetTop + 'px';\n\t\t} else {\n\t\t\tel.style.top = (i * r.cellHeight || 0) + r.offsetTop + 'px';\n\t\t}\n\t};\n\n\tthis.getOffsetParent = function() {\n\t\t// the list might be contained in some other scrolling div\n\t\treturn this._opts.offsetParent || (this._containSelf ? this._container : this._container.offsetParent) || document.body;\n\t};\n\n\tthis.renderFixedHeight = function() {\n\t\tvar parent = this.getOffsetParent();\n\t\tif (!parent) { return; }\n\t\tif (parent != this._offsetParent) {\n\t\t\tif (this._removeScrollEvt) { this._removeScrollEvt(); }\n\t\t\tthis._offsetParent = parent;\n\t\t\tthis._removeScrollEvt = $.onEvent(parent, 'scroll', this, 'needsRender');\n\t\t}\n\n\t\t// render data\n\t\tvar src = this._renderedDataSource,\n\t\t\tkey = src.getKey(),\n\t\t\tn = src.length;\n\n\t\tif (n && !this.updateRenderOpts()) { return; }\n\n\t\t// swap lists\n\t\tvar oldCellsByID = this._cellsByID;\n\t\tthis._cellsByID = {};\n\n\t\t// render new items\n\t\tif (n) {\n\t\t\tvar isTiled = this._isTiled;\n\t\t\tvar r = this._renderOpts;\n\t\t\tfor (var i = r.start; i < r.end; ++i) {\n\t\t\t\tvar item = src.getItemForIndex(i);\n\t\t\t\tif (!item) { break; }\n\n\t\t\t\tvar id = item[key];\n\t\t\t\tvar cell = oldCellsByID[id];\n\t\t\t\tif (!cell) {\n\t\t\t\t\tcell = this._createCell(item);\n\t\t\t\t} else {\n\t\t\t\t\tdelete(oldCellsByID[id]);\n\t\t\t\t\tcell.render();\n\t\t\t\t}\n\n\t\t\t\tthis.positionCell(cell, i);\n\t\t\t\tthis._cellsByID[id] = cell;\n\t\t\t}\n\t\t};\n\n\t\t// remove old items\n\t\tif (!this._opts.preserveCells) {\n\t\t\tfor (var id in oldCellsByID) {\n\t\t\t\toldCellsByID[id].remove();\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var id in oldCellsByID) {\n\t\t\t\tvar cell = oldCellsByID[id];\n\t\t\t\tif (!src.getItemForID(id)) {\n\t\t\t\t\tcell.remove();\n\t\t\t\t} else {\n\t\t\t\t\tthis._cellsByID[id] = cell;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n});\n");
jsio.setCachedSrc('../node_modules/squill/Window.js',"jsio('import lib.PubSub');\njsio('import std.uri');\njsio('from util.browser import $');\n\nvar UNIQUE_ID = '__squill__window_id';\n\nvar Window = exports = Class(lib.PubSub, function() {\n\tthis.init = function(win) {\n\t\tthis._win = win || window;\n\t\tthis._location = new std.uri(this._win.location);\n\t\tthis._dim = $(this._win);\n\t\t$.onEvent(this._win, 'resize', this, 'onViewportChange');\n\t\t$.onEvent(this._win, 'scroll', this, 'onViewportChange');\n\t}\n\n\tthis.onViewportChange = function(e) {\n\t\tthis._dim = $(this._win);\n\t\tthis.publish('ViewportChange', e, this._dim);\n\t}\n\n\tthis.getDim =\n\tthis.getViewport = function() { return this._dim; }\n\n\tthis.query = function(key) {\n\t\treturn this._location.query(key);\n\t}\n\n\tthis.hash = function(key) {\n\t\treturn this._location.query(key);\n\t}\n\n\tthis.center = function(el, opts) {\n\t\topts = merge(opts, {subscribe: true});\n\n\t\tvar width = 'width' in opts ? opts.width : el.offsetWidth,\n\t\t\theight = 'height' in opts ? opts.height : el.offsetHeight;\n\n\t\tel.style.left = (this._dim.width - width) / 2 + 'px';\n\t\tel.style.top = (this._dim.height - height) / 2 + 'px';\n\n\t\tif (opts.subscribe) {\n\t\t\tthis.subscribe('ViewportChange', this, 'center', el, merge({subscribe: false}, opts));\n\t\t}\n\t}\n});\n\nvar gWin = {};\nexports.get = function(win) {\n\tif (!win) { win = window; }\n\n\tif (win[UNIQUE_ID]) {\n\t\treturn gWin[win[UNIQUE_ID]];\n\t} else {\n\t\treturn gWin[win[UNIQUE_ID]] = new Window(win);\n\t}\n}\n");
jsio.setCachedSrc('../node_modules/jsio/packages/std/uri.js',"jsio('import util.path');\n\nvar attrs = [\n\t\"source\",\n\t\"protocol\",\n\t\"authority\",\n\t\"userInfo\",\n\t\"user\",\n\t\"password\",\n\t\"host\",\n\t\"port\",\n\t\"relative\",\n\t\"path\",\n\t\"directory\",\n\t\"file\",\n\t\"query\",\n\t\"anchor\"\n];\n\nvar URI = module.exports = Class(function() {\n\tthis.init = function(url, isStrict) {\n\t\tif (url instanceof URI) {\n\t\t\tfor (var i = 0, attr; attr = attrs[i]; ++i) {\n\t\t\t\tthis['_' + attr] = url['_' + attr];\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isStrict = isStrict;\n\n\t\tvar uriData = URI.parse(url, isStrict);\n\t\tfor (var attr in uriData) {\n\t\t\tthis['_' + attr] = uriData[attr];\n\t\t}\n\t};\n\n\tfor (var i = 0, attr; attr = attrs[i]; ++i) {\n\t\t(function(attr) {\n\t\t\tvar fNameSuffix = attr.charAt(0).toUpperCase() + attr.slice(1);\n\t\t\tthis['get' + fNameSuffix] = function() {\n\t\t\t\treturn this['_' + attr];\n\t\t\t};\n\t\t\tthis['set' + fNameSuffix] = function(val) {\n\t\t\t\tthis['_' + attr] = val;\n\t\t\t\treturn this;\n\t\t\t};\n\t\t}).call(this, attr);\n\t}\n\n\tthis.query = function(key) { return URI.parseQuery(this._query)[key]; };\n\tthis.hash = function(key) { return URI.parseQuery(this._anchor)[key]; };\n\n\tthis.addHash = function(kvp) {\n\t\tvar hash = URI.parseQuery(this._anchor);\n\t\tfor (var i in kvp) { hash[i] = kvp[i]; }\n\t\tthis._anchor = URI.buildQuery(hash);\n\t\treturn this;\n\t};\n\n\tthis.setPath = function (path) {\n\t\tvar pieces = util.path.splitPath(path);\n\t\tthis._file = pieces.filename;\n\t\tthis._directory = pieces.directory;\n\t\tthis._path = path;\n\t\treturn this;\n\t};\n\n\tthis.setFile = function (file) {\n\t\treturn this.setPath(util.path.join(this._directory, file));\n\t};\n\n\tthis.setDirectory = function (directory) {\n\t\treturn this.setPath(util.path.join(directory, this._file));\n\t};\n\n\tthis.push = function(path) {\n\t\tif (path) {\n\t\t\tthis._path = (this._path + '/' + path).replace(/\\/\\/+/g, '/');\n\t\t}\n\t\treturn this;\n\t};\n\n\tthis.addQuery = function(kvp) {\n\t\tvar query = URI.parseQuery(this._query);\n\t\tfor (var i in kvp) { query[i] = kvp[i]; }\n\t\tthis._query = URI.buildQuery(query);\n\t\treturn this;\n\t};\n\n\tthis.removeQuery = function(keys) {\n\t\tvar query = URI.parseQuery(this._query);\n\t\tif (Array.isArray(keys)) {\n\t\t\tfor (var i = 0, n = keys.length; i < n; ++i) {\n\t\t\t\tdelete query[keys[i]];\n\t\t\t}\n\t\t} else {\n\t\t\tdelete query[keys];\n\t\t}\n\t\tthis._query = URI.buildQuery(query);\n\t\treturn this;\n\t};\n\n\tthis.toJSON = function() { return this.toString(false); };\n\n\tthis.toString = function(onlyBase) {\n\t\t// XXX TODO: This is vaguely reasonable, but not complete. fix it...\n\t\tvar a = this._protocol ? this._protocol + \"://\" : \"\";\n\t\tvar b = this._host ? this._host + ((this._port || 80) == 80 ? \"\" : \":\" + this._port) : \"\";\n\n\t\tif (onlyBase) {\n\t\t\treturn a + b;\n\t\t}\n\n\t\tvar c = this._path;\n\t\tvar d = this._query ? '?' + this._query : '';\n\t\tvar e = this._anchor ? '#' + this._anchor : '';\n\t\treturn a + b + c + d + e;\n\t};\n});\n\nURI.relativeTo = function(url, base) {\n\tvar url = String(url);\n\tif (base && !/^http(s?):\\/\\//.test(url)) {\n\t\tvar baseURI = new URI(base)\n\t\t\t.setAnchor('')\n\t\t\t.setQuery('')\n\t\t\t.setFile('')\n\t\t\t.toString(url.charAt(0) == '/');\n\n\t\turl = URI.resolveRelative(baseURI + url);\n\t}\n\n\treturn new URI(url);\n};\n\nURI.resolveRelative = function(url) {\n\tvar prevUrl;\n\n\t// remove ../ with preceeding folder\n\twhile((prevUrl = url) != (url = url.replace(/(^|\\/)([^\\/]+)\\/\\.\\.\\//g, '/'))) {};\n\n\t// remove ./ if it isn't preceeded by a .\n\treturn url.replace(/[^.]\\.\\//g, '');\n};\n\nURI.buildQuery = function(kvp) {\n\tvar pairs = [];\n\tfor (var key in kvp) {\n\t\tpairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(kvp[key]));\n\t}\n\treturn pairs.join('&');\n};\n\nURI.parseQuery = function(str) {\n\tvar pairs = str.split('&'),\n\t\tn = pairs.length,\n\t\tdata = {};\n\tfor (var i = 0; i < n; ++i) {\n\t\tvar pair = pairs[i].split('='),\n\t\t\tkey = decodeURIComponent(pair[0]);\n\t\tif (key) { data[key] = decodeURIComponent(pair[1]); }\n\t}\n\treturn data;\n};\n\n// Regexs are based on parseUri 1.2.2\n// Original: (c) Steven Levithan <stevenlevithan.com>\n// Original: MIT License\n\nvar strictRegex = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/;\nvar looseRegex = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\nvar queryStringRegex = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\nURI.parse = function(str, isStrict) {\n\tvar regex = isStrict ? strictRegex : looseRegex;\n\tvar result = {};\n\tvar match = regex.exec(str);\n\tfor (var i = 0, attr; attr = attrs[i]; ++i) {\n\t\tresult[attr] = match[i] || \"\";\n\t}\n\n\tvar qs = result['queryKey'] = {};\n\tresult['query'].replace(queryStringRegex, function(check, key, val) {\n\t\tif (check) {\n\t\t\tqs[key] = val;\n\t\t}\n\t});\n\n\treturn result;\n};\n\nURI.isSameDomain = function(urlA, urlB) {\n\tvar a = URI.parse(urlA);\n\tvar b = URI.parse(urlB);\n\treturn ((a.port == b.port ) && (a.host == b.host) && (a.protocol == b.protocol));\n};\n");
jsio.setCachedSrc('../node_modules/squill/models/DataSource.js',"jsio('import lib.Callback');\njsio('import .BasicDataSource as BasicDataSource');\n\nvar DataSource = exports = Class(BasicDataSource, function(supr) {\n\n\tvar defaults = {\n\t\tkey: 'id'\n\t};\n\n\tthis.init = function(opts) {\n\t\tthis._opts = opts = merge(opts, defaults);\n\n\t\tsupr(this, 'init', [opts]);\n\n\t\tthis._byIndex = [];\n\t\tthis._byID = {};\n\t\tthis._ctor = opts.ctor;\n\t\tthis._reverse = opts.reverse;\n\n\t\tthis.length = 0;\n\n\t\tthis.onLoad = new lib.Callback();\n\n\t\tthis.setSorter(opts.sorter);\n\t\tthis.setPersistence(opts.persistence);\n\n\t\tthis._changeDataSave = false;\n\t\tthis._changeData = {\n\t\t\tupdated: [],\n\t\t\tupdatedHash: {},\n\t\t\tremoved: [],\n\t\t\tremovedHash: {}\n\t\t};\n\t};\n\n\tthis.setPersistence = function(persistence) {\n\t\tthis._persistence = persistence;\n\t\tif (persistence) {\n\t\t\tthis.onLoad.clear();\n\t\t\tpersistence.load(this, this.onLoad.chain());\n\t\t}\n\t}\n\n\tthis._saveChanges = function(type, key) {\n\t\tif (this._changeDataSave && !this._changeData[type + 'Hash'][key]) {\n\t\t\tthis._changeData[type + 'Hash'][key] = true;\n\t\t\tthis._changeData[type].push(key);\n\t\t}\n\t};\n\n\tthis.getFilteredDataSource = function(filterFn) {\n\t\tvar ds = new DataSource(this._opts);\n\t\tthis.forEach(function (item) {\n\t\t\tif (filterFn(item)) {\n\t\t\t\tds.add(item);\n\t\t\t}\n\t\t});\n\n\t\tthis.subscribe('Update', function (id, item) {\n\t\t\tif (filterFn(item)) {\n\t\t\t\tds.add(item);\n\t\t\t} else {\n\t\t\t\tds.remove(item);\n\t\t\t}\n\t\t});\n\n\t\tthis.subscribe('Remove', function (id, item) { ds.remove(item); });\n\t\treturn ds;\n\t};\n\n\tthis.signalUpdate = function(type, item, id) {\n\t\tif (item[this.key] === undefined) {\n\t\t\treturn;\n\t\t}\n\t\tswitch (type) {\n\t\t\tcase 'UPDATE':\n\t\t\t\tthis._saveChanges('updated', item[this.key]);\n\t\t\t\tthis.publish('Update', item[this.key], item);\n\t\t\t\tbreak;\n\n\t\t\tcase 'REMOVE':\n\t\t\t\tthis._saveChanges('removed', item[this.key]);\n\t\t\t\tthis.publish('Remove', id, item);\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\tvar toStringSort = function() {\n\t\treturn this._sortKey;\n\t};\n\t// NEVER CHANGE THE ID OF AN ITEM WITHOUT REMOVING IT FROM THE DATASOURCE FIRST.\n\t// Love, Jeff Hubbard and Marcus Cavanaugh\n\n\tthis.updated =\n\tthis.add = function(item) {\n\t\tif (isArray(item)) {\n\t\t\tvar res = [];\n\t\t\tfor (var i = 0, len = item.length; i < len; ++i) {\n\t\t\t\tif (item[i]) {\n\t\t\t\t\tvar obj = this.add(item[i]);\n\t\t\t\t\tif (obj) {\n\t\t\t\t\t\tres.push(obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn res;\n\t\t} else {\n\t\t\tvar id = item[this.key];\n\n\t\t\t// note: not the same as `if (!id) { ... }`\n\t\t\tif (id == null) { return; }\n\n\t\t\tvar index = null;\n\t\t\tif (this._byID[id]) {\n\t\t\t\tfor (var i = 0, _item; _item = this._byIndex[i]; ++i) {\n\t\t\t\t\tif (_item[this.key] == id) {\n\t\t\t\t\t\tif (typeof _item.update == 'function') {\n\t\t\t\t\t\t\t_item.update(item);\n\t\t\t\t\t\t\titem = _item;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tindex = this.length++;\n\t\t\t}\n\n\t\t\t// if we're adding it to the array:\n\t\t\tif (index !== null) {\n\n\t\t\t\t// make sure it's an instance of the specified class\n\t\t\t\tif (this._ctor && !(item instanceof this._ctor)) {\n\t\t\t\t\titem = new this._ctor(item);\n\t\t\t\t}\n\n\t\t\t\tthis._byIndex[index] = item;\n\t\t\t}\n\n\t\t\tthis._byID[id] = item;\n\n\t\t\tthis.signalUpdate('UPDATE', item);\n\n\t\t\tif (this._sorter) {\n\t\t\t\titem._sortKey = this._sorter(item);\n\t\t\t\titem.toString = toStringSort;\n\t\t\t}\n\t\t}\n\n\t\treturn item;\n\t};\n\n\tthis.remove = function(id) {\n\t\tif (typeof id == 'object') { id = id[this.key]; }\n\t\tif (id == null) { return; }\n\n\t\tif (this._byID[id]) {\n\t\t\tthis.signalUpdate('REMOVE', this._byID[id], id);\n\t\t\tdelete this._byID[id];\n\t\t\tfor (var i = 0, item; item = this._byIndex[i]; ++i) {\n\t\t\t\tif (item[this.key] == id) {\n\t\t\t\t\t--this.length;\n\t\t\t\t\treturn this._byIndex.splice(i, 1)[0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.keepOnly = function(list) {\n\t\tthis.compare(list, function(dataSource, local, remote) {\n\t\t\tif (!remote) {\n\t\t\t\tdataSource.remove(local);\n\t\t\t}\n\t\t});\n\t};\n\n\tthis.clear = function() {\n\t\tvar index = this._byIndex;\n\n\t\tthis._byIndex = [];\n\t\tthis._byID = {};\n\t\tthis.length = 0;\n\n\t\tfor (var i = 0, item; item = index[i]; ++i) {\n\t\t\tthis.signalUpdate('REMOVE', item, item[this.key]);\n\t\t}\n\t};\n\n\tthis.getCount = function() {\n\t\treturn this.length;\n\t};\n\n\tthis.setSorter = function(sorter) {\n\t\tthis._sorter = sorter;\n\t\tif (sorter) {\n\t\t\tfor (var i = 0, item; item = this._byIndex[i]; ++i) {\n\t\t\t\titem._sortKey = sorter(item);\n\t\t\t\titem.toString = toStringSort;\n\t\t\t}\n\t\t}\n\t\tthis.sort();\n\t\treturn this;\n\t};\n\n\tthis.getIDs = function () {\n\t\treturn this._byIndex.map(function (item) {\n\t\t\treturn item[this.key];\n\t\t}, this);\n\t};\n\n\tthis.contains = function(id) {\n\t\treturn !!this._byID[id];\n\t};\n\n\tthis.getKey = function() {\n\t\treturn this.key;\n\t}\n\n\tthis.get = this.getItemForID = function(id) {\n\t\treturn this._byID[id] || null;\n\t};\n\n\tthis.indexOf = function (item) {\n\t\treturn this._byIndex.indexOf(item);\n\t};\n\n\tthis.getItemForIndex = function(index) {\n\t\treturn this._byIndex[index];\n\t};\n\n\tthis.sort = function() {\n\t\tthis._byIndex.sort();\n\t\tthis._reverse && this._byIndex.reverse();\n\t};\n\n\tthis.forEach = this.each = function(cb, context) {\n\t\tfor (var i = 0; i < this.length; ++i) {\n\t\t\tif (cb.call(context, this._byIndex[i], i)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.toJSON = function() {\n\t\treturn {\n\t\t\tkey: this.key,\n\t\t\titems: this._byIndex\n\t\t};\n\t};\n\n\tthis.fromJSON = function(data) {\n\t\tthis.clear();\n\t\tvar key = this.key = data.key;\n\t\tthis.add(data.items);\n\t};\n\n\tthis.toArray = function() { return this._byIndex.slice(0); }\n\n\tthis.beginChanges = function() {\n\t\tthis._changeDataSave = true;\n\t\tthis._changeData = {\n\t\t\tupdated: [],\n\t\t\tupdatedHash: {},\n\t\t\tremoved: [],\n\t\t\tremovedHash: {}\n\t\t};\n\t};\n\n\tthis.saveChanges = function() {\n\t\tthis._changeDataSave = false;\n\t\tif (this._persistence) {\n\t\t\tvar changeData = this._changeData,\n\t\t\t\ti, j;\n\n\t\t\tthis._persistence.remove(changeData.removed);\n\n\t\t\tif (changeData.updated.length) {\n\t\t\t\tvar updateList = [];\n\t\t\t\tfor (i = 0, j = changeData.updated.length; i < j; i++) {\n\t\t\t\t\tupdateList.push(this._byID[changeData.updated[i]]);\n\t\t\t\t}\n\t\t\t\tthis._persistence.update(updateList);\n\t\t\t}\n\n\t\t\tthis._persistence.commit();\n\t\t}\n\t};\n\n\tthis.load = function(cb) {\n\t\tif (this._persistence) {\n\t\t\tthis._persistence.load(this, function(err) {\n\t\t\t\tif (err) {\n\t\t\t\t\tlogger.log('error loading', JSON.stringify(err));\n\t\t\t\t}\n\t\t\t\tcb && cb(err);\n\t\t\t});\n\t\t}\n\t};\n\n\tthis.save = function() {\n\t\tif (this._persistence) {\n\t\t\tthis._persistence.save(this);\n\t\t}\n\t}\n\n\tthis.compare = function(dict, cb) {\n\t\tvar key = this.key;\n\n\t\t// create a key-indexed copy of dict to run the comparison against\n\t\tvar compareTo = {};\n\t\tif (isArray(dict)) {\n\t\t\tfor (var i = 0, n = dict.length; i < n; ++i) {\n\t\t\t\tcompareTo[dict[i][key]] = dict[i];\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var k in dict) {\n\t\t\t\tcompareTo[k] = dict[k];\n\t\t\t}\n\t\t}\n\n\t\t// first, compare all items in the index to the dict items\n\t\tvar items = this._byIndex.slice(0);\n\t\tfor (var i = 0, item; item = items[i]; ++i) {\n\t\t\tvar k = item[key];\n\t\t\tcb.call(this, this, item, compareTo[k]);\n\t\t\tdelete compareTo[k];\n\t\t}\n\n\t\t// then, for any remaining dict items, they don't exist in the local version\n\t\tfor (var k in compareTo) {\n\t\t\tcb.call(this, this, null, compareTo[k]);\n\t\t}\n\t}\n\n\tthis.filter = function(filter) {\n\t\tvar result = new DataSource({key: this.key});\n\t\tvar key;\n\t\tvar item;\n\t\tvar match;\n\t\tvar i;\n\t\tvar j = this.length;\n\n\t\tresult.key = this.key;\n\t\tfor (i = 0; i < j; ++i) {\n\t\t\titem = this._byIndex[i];\n\t\t\tmatch = true;\n\t\t\tfor (key in filter) {\n\t\t\t\tif ((typeof item[key] == 'string') && (item[key].toLowerCase().indexOf(filter[key]) == -1)) {\n\t\t\t\t\tmatch = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (match) {\n\t\t\t\tresult.add(item);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n});\n");
jsio.setCachedSrc('../node_modules/jsio/packages/lib/Callback.js',"exports = Class(function() {\n\n\tthis._fired = false;\n\tthis._id = 0;\n\tthis._pending = null;\n\n\tthis.init = function() { this._run = []; };\n\t\n\t/* fired is @deprecated in favor of hasFired*/\n\tthis.hasFired = this.fired = function() { return this._fired; } ;\n\n\t// preserve pending callbacks, but clear fired status\n\tthis.reset = function() { this._args = []; this._fired = false; };\n\n\t// clear fired status and remove any pending callbacks\n\tthis.clear = function() { this.reset(); this._run = []; this._pending = null; this._stat = null; };\n\n\t// a convenience function to proxy arguments to `this.run`: arguments passed as the first argument\n\tthis.forward = function(args) { this.run.apply(this, args); };\n\n\t// when the lib.Callback object fires, run a ctx, method, and\n\t// (optional) curried arguments or a single callback function\n\tthis.run = function(ctx, method) {\n\t\tvar f = method ? bind.apply(this, arguments) : ctx;\n\t\tif (f) {\n\t\t\tif (this._fired) {\n\t\t\t\tf.apply(this, this._args);\n\t\t\t} else {\n\t\t\t\tthis._run.push(f);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n\n\tthis.runOrTimeout = function(onFire, onTimeout, duration) {\n\t\tif (!onFire && !onTimeout) { return; }\n\n\t\tif (this._fired) {\n\t\t\tonFire.apply(this, this._args);\n\t\t} else {\n\t\t\tvar f = bind(this, function() {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\tonFire.apply(this, this._args);\n\t\t\t});\n\n\t\t\tthis.run(f);\n\n\t\t\tvar timeout = setTimeout(bind(this, function() {\n\t\t\t\tfor (var i = 0, n = this._run.length; i < n; ++i) {\n\t\t\t\t\tif (this._run[i] == f) {\n\t\t\t\t\t\tthis._run.splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tonTimeout();\n\t\t\t}), duration);\n\t\t}\n\t};\n\n\tthis.fire = function() {\n\t\tif (this._fired) { return; }\n\t\tthis._fired = true;\n\n\t\tvar cbs = this._run;\n\t\tthis._args = arguments;\n\t\tfor(var i = 0, len = cbs.length; i < len; ++i) {\n\t\t\tif (cbs[i]) { cbs[i].apply(this, arguments); }\n\t\t}\n\t};\n\n\tthis.chain = function(id) {\n\t\tif (!this._pending) { this._pending = {}; }\n\t\tif (id === undefined) { id = this._id++; }\n\t\tthis._pending[id] = true;\n\n\t\tthis.reset();\n\t\treturn bind(this, '_deferred', id);\n\t};\n\n\tthis._deferred = function(id) {\n\t\tif (!this._stat) { this._stat = {}; }\n\t\tif (this._stat.hasOwnProperty(id)) { return; }\n\n\t\tthis._stat[id] = Array.prototype.slice.call(arguments, 1);\n\t\tvar pending = this._pending;\n\t\tdelete pending[id];\n\t\tfor (var id in pending) {\n\t\t\tif (pending.hasOwnProperty(id)) { return; }\n\t\t}\n\n\t\tthis.fire(this._stat);\n\t};\n});\n");
jsio.setCachedSrc('../node_modules/squill/models/BasicDataSource.js',"jsio('import lib.PubSub as PubSub');\n\nvar BasicDataSource = exports = Class(PubSub, function(supr) {\n\tthis.init = function(opts) {\n\t\tsupr(this, 'init', arguments);\n\n\t\tthis.key = this._key = opts.key;\n\t\tthis._channel = opts.channel;\n\t\tthis._hasRemote = opts.hasRemote;\n\t};\n\n\tthis.getKey = function() {\n\t\treturn this._key;\n\t};\n});\n");
jsio.setCachedSrc('../node_modules/squill/Selection.js',"jsio('import lib.PubSub');\n\n/**\n * The Selection class connects a selection storage to a UI element.\n *\n * A selection storage is very simple class that maintains the data layer of\n * a selection. It is entirely based on item ID, exposing the methods:\n *   isSelected(id) -> bool\n *   select(id)\n *   deselect(id)\n * You may, for example, want to implement a selection store that persists\n * the current selection over a network. The base implementation of a selection\n * storage is exports.LocalStore, which simply wraps an in-memory object.\n *\n * The Selection class handles logic such as how many items can be selected\n * at once, and provides the API that UI widgets can interact with.  For example,\n * the squill.List class contains a public proprty .selection that is an\n * instance of a Selection instance.\n */\nexports = Class(lib.PubSub, function() {\n\n\tthis.init = function(opts) {\n\t\tthis._parent = opts.parent;\n\t\tthis._type = opts.type || false;\n\t\tthis._selection = opts.selectionStore || new exports.LocalStore();\n\t\tthis._maxSelections = opts.maxSelections || 1;\n\t\tthis._currentSelectionCount = 0;\n\t\tthis._lastSelected = null;\n\t};\n\n\tthis.getType = function() { return this._type; };\n\n\tthis.isSelected = function(id) {\n\t\tif (typeof id == 'object') {\n\t\t\tid = id[this._parent.getDataSource().key];\n\t\t}\n\t\treturn this._selection.isSelected(id);\n\t};\n\n\tthis.toggle = function(item) {\n\t\tthis._setSelected(item, !this.isSelected(item[this._parent.getDataSource().key]));\n\t};\n\n\tthis.select = function(item) {\n\t\tif((this._currentSelectionCount < this._maxSelections) || this._type == 'single') {\n\t\t\tthis._setSelected(item, true);\n\t\t}\n\t};\n\n\tthis.deselect = function(item) {\n\t\tthis._setSelected(item, false);\n\t};\n\n\tthis.clear =\n\tthis.deselectAll = function() {\n\t\tthis._selection.deselectAll();\n\t\tthis._currentSelectionCount = 0;\n\t};\n\n\tthis.get = function() {\n\t\tif (this._maxSelections == 1) {\n\t\t\treturn Object.keys(this._selection.get())[0];\n\t\t} else {\n\t\t\treturn Object.keys(this._selection.get());\n\t\t}\n\t};\n\n\tthis.getSelectionCount = function() {\n\t\treturn this._currentSelectionCount;\n\t};\n\n\tthis._setSelected = function(item, isSelected) {\n\t\tif (!item) { return; }\n\n\t\tvar dataSource = this._parent.getDataSource(),\n\t\t\tkey = dataSource.key;\n\t\tif (typeof item == 'string') {\n\t\t\titem = dataSource.get(item);\n\t\t\tif (!item) { return; }\n\t\t}\n\t\tvar id = item[key];\n\n\t\tif (this._selection.isSelected(id) != isSelected) {\n\t\t\tif (isSelected) {\n\t\t\t\tif (this._lastSelected && this._type == 'single') {\n\t\t\t\t\tvar lastID = this._lastSelected[key];\n\t\t\t\t\tthis._selection.deselect(lastID);\n\t\t\t\t\tthis._currentSelectionCount--;\n\t\t\t\t\tthis.publish('Deselect', this._lastSelected, lastID);\n\t\t\t\t}\n\n\t\t\t\tthis._lastSelected = item;\n\t\t\t\tthis._selection.select(id);\n\t\t\t\tthis._currentSelectionCount++;\n\t\t\t} else {\n\t\t\t\tthis._selection.deselect(id);\n\t\t\t\tthis._currentSelectionCount--;\n\t\t\t}\n\n\t\t\tthis.publish(isSelected ? 'Select' : 'Deselect', item, id);\n\t\t}\n\t};\n});\n\nexports.LocalStore = Class(function() {\n\tthis.init = function() {\n\t\tthis._store = {};\n\t}\n\n\tthis.get = function() {\n\t\treturn merge({}, this._store);\n\t}\n\n\tthis.select = function(id) {\n\t\tthis._store[id] = true;\n\t}\n\n\tthis.deselect = function(id) {\n\t\tdelete this._store[id];\n\t}\n\n\tthis.deselectAll = function(id) {\n\t\tthis._store = {};\n\t}\n\n\tthis.isSelected = function(id) {\n\t\tif (id !== undefined) {\n\t\t\treturn !!this._store[id];\n\t\t} else {\n\t\t\tfor (var key in this._store) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n});\n\n");
jsio.setCachedSrc('../node_modules/squill/TextButton.js',"jsio('import .Button, .Widget');\njsio('from util.browser import $');\n\nvar TextButton = exports = Class(Button, function(supr) {\n\tthis._type = 'text-button';\n\n\tthis.buildWidget = function() {\n\t\tvar el = this._el;\n\t\t$.setText(el, this.getI18n('label') || this.getI18n('text'));\n\n\t\tthis.initMouseEvents(el);\n\t\tthis.initKeyEvents(el);\n\t}\n\n\tthis.setLabel = function(label) {\n\t\tthis._opts.label = label;\n\t\tif(this._el) { $.setText(this._el, label); }\n\t}\n});\n\nWidget.register(TextButton, 'TextButton');\n");
jsio.setCachedSrc('../node_modules/squill/Button.js',"jsio('from util.browser import $');\njsio('import .Widget');\n\njsio('import .hint as hint');\n\nvar Button = exports = Class(Widget, function(supr) {\n\tthis._css = 'btn';\n\tthis._type = 'button';\n\n\tthis.init = function(params) {\n\t\tparams = merge(params, {tag: 'button', isEnabled: true});\n\t\tthis._isEnabled = params.isEnabled;\n\t\tsupr(this, 'init', [params]);\n\t\tthis._hint = params.hint;\n\t};\n\n\tthis.create = function() {\n\t\tthis._opts.style = JS.merge(this._opts.style, {\n\t\t\t\twhiteSpace: 'nowrap',\n\t\t\t\tdisplay: 'block'\n\t\t\t});\n\n\t\tsupr(this, 'create', arguments);\n\t};\n\n\tthis.buildWidget = function() {\n\t\tvar el = this._el;\n\n\t\tthis.initMouseEvents(el);\n\t\tthis.initKeyEvents(el);\n\n\t\tel.style.userSelect = 'none';\n\t\tel.style.MozUserSelect = 'none'; // Mozilla\n\t\tel.style.KhtmlUserSelect = 'none'; // Safari\n\t\tel.unselectable = 'on'; // IE\n\t};\n\n\tthis._setHintTimeout = function(e) {\n\t\tif (!this._hint) {\n\t\t\treturn;\n\t\t}\n\t\tthis._hintTimeout && clearTimeout(this._hintTimeout);\n\t\tthis._hintTimeout = setTimeout(\n\t\t\tbind(\n\t\t\t\tthis,\n\t\t\t\tfunction() {\n\t\t\t\t\thint.show(e.pageX + 12, e.pageY + 14, this._hint);\n\t\t\t\t}\n\t\t\t),\n\t\t\t300\n\t\t);\n\t};\n\n\tthis.onMouseOver = function(e) {\n\t\tthis._setHintTimeout(e);\n\t};\n\n\tthis.onMouseMove = function(e) {\n\t\tthis._setHintTimeout(e);\n\t};\n\n\tthis.onMouseOut = function(e) {\n\t\thint.hide();\n\t\tthis._hintTimeout && clearTimeout(this._hintTimeout);\n\t};\n\n\tthis.onClick = function(e) {\n\t\t$.stopEvent(e);\n\t\tif (!this._isEnabled) { return; }\n\n\t\tif (this._opts.onClick) {\n\t\t\tthis._opts.onClick(e, this);\n\t\t}\n\n\t\tsupr(this, 'onClick', arguments);\n\t};\n\n\tthis.captureOnEnter = function(widget) {\n\t\twidget.subscribe('KeyDown', this, 'onKeyDown');\n\t\twidget.subscribe('KeyUp', this, 'onKeyUp');\n\t};\n\n\tthis.onKeyDown = function(e) {\n\t\tif (e.keyCode == 13) { $.stopEvent(e); this.onMouseDown(); }\n\t};\n\n\tthis.onKeyUp = function(e) {\n\t\tif (e.keyCode == 13) { $.stopEvent(e); this.onMouseUp(); this.onClick(e); }\n\t};\n\n\tthis.show = function() {\n\t\tthis.onBeforeShow();\n\t\tthis.getElement().style.display = 'inline-block';\n\t\tthis.onShow();\n\t\treturn this;\n\t};\n\n\tthis.blur = function () { this._el && this._el.blur(); }\n\tthis.focus = function () { this._el && this._el.focus(); }\n\n\tthis.setEnabled = function(isEnabled) {\n\t\tif (this._isEnabled != isEnabled) {\n\t\t\tthis._isEnabled = isEnabled;\n\t\t\tif (!isEnabled) {\n\t\t\t\t$.addClass(this._el, 'disabled')\n\t\t\t} else {\n\t\t\t\t$.removeClass(this._el, 'disabled')\n\t\t\t}\n\t\t}\n\t};\n});\n\n");
jsio.setCachedSrc('../node_modules/squill/hint.js',"jsio('from util.browser import $');\n\nvar hint = $({parent: document.body, className: 'hint'});\n\nexports.show = function(x, y, text) {\n\thint.innerHTML = text;\n\thint.style.left = x + 'px';\n\thint.style.top = y + 'px';\n\thint.style.display = 'block';\n\n\tconsole.log(text);\n\tif (x + hint.offsetWidth >= document.width) {\n\t\thint.style.left = (x - hint.offsetWidth) + 'px';\n\t}\n};\n\nexports.hide = function() {\n\thint = hint || $({\n\t\tparent: document.body,\n\t\tclassName: 'graphHint'\n\t});\n\n\thint.style.display = 'none';\n};\n\nvar setHintTimeout = function(evt) {\n\tevt.target.hintTimeout && clearTimeout(evt.target.hintTimeout);\n\tevt.target.hintTimeout = setTimeout(\n\t\tbind(\n\t\t\tthis,\n\t\t\tfunction() {\n\t\t\t\texports.show(evt.pageX + 12, evt.pageY + 14, evt.target.hintText);\n\t\t\t}\n\t\t),\n\t\t300\n\t);\n};\n\nexports.add = function(el, text) {\n\tel.hintText = text;\n\n\t$.onEvent(el, 'mouseover', setHintTimeout);\n\t$.onEvent(el, 'mousemove', setHintTimeout);\n\t$.onEvent(\n\t\tel,\n\t\t'mouseout',\n\t\tfunction(evt) {\n\t\t\texports.hide();\n\t\t\tevt.target.hintTimeout && clearTimeout(evt.target.hintTimeout);\n\t\t}\n\t);\n}\n");
jsio.setCachedSrc('../node_modules/squill/TextInput.js',"jsio('from util.browser import $');\njsio('import .Widget');\njsio('import squill.models.bindings as bindings');\n\nvar TextInput = exports = Class(Widget, function(supr) {\n\tthis._type = 'text';\n\tthis._css = 'textInput';\n\n\tthis.init = function(opts) {\n\t\topts = merge(opts, {\n\t\t\tname: '',\n\t\t\tvalue: '',\n\t\t\tmultiline: false\n\t\t});\n\n\t\tthis._def = {\n\t\t\tchildren: [\n\t\t\t\t{tag: opts.multiline ? 'textarea' : 'input', id: '_input', attrs: {\n\t\t\t\t\ttype: 'text',\n\t\t\t\t\tvalue: opts.value,\n\t\t\t\t\tname: opts.name\n\t\t\t\t}, style: merge(opts.textStyle, {\n\t\t\t\t\tMozBoxSizing: 'border-box',\n\t\t\t\t\tWebkitBoxSizing: 'border-box',\n\t\t\t\t\tMsBoxSizing: 'border-box',\n\t\t\t\t\tboxSizing: 'border-box'\n\t\t\t\t})}\n\t\t\t],\n\t\t\tstyle: {position: 'relative'}\n\t\t};\n\n\t\tif (opts.prefixLabel) {\n\t\t\tthis._def.children.unshift({id: '_label', text: opts.label});\n\t\t}\n\n\t\tsupr(this, 'init', [opts]);\n\t}\n\n\tthis.buildWidget = function() {\n\t\tvar el = this._el;\n\t\tvar type = this._opts.type;\n\t\tif ('ontouchstart' in this._el) {\n\t\t\tthis._overlay = $({\n\t\t\t\tparent: this._el,\n\t\t\t\tattrs: {\n\t\t\t\t\tnoCapture: true\n\t\t\t\t},\n\t\t\t\tstyle: {\n\t\t\t\t\tposition: 'absolute',\n\t\t\t\t\ttop: '0px',\n\t\t\t\t\tleft: '0px',\n\t\t\t\t\twidth: '100%',\n\t\t\t\t\theight: '100%',\n\t\t\t\t\tzIndex: 1\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis._overlay.addEventListener('click', bind(this, function() {\n\t\t\t\t$.hide(this._overlay);\n\t\t\t\tthis._input.focus();\n\t\t\t}), true);\n\t\t}\n\n\t\tvar opts = this._opts\n\t\tif (!opts.prefixLabel || opts.placeholder) {\n\t\t\tvar label = this.getI18n('label');\n\t\t\tif (this._input.getAttribute('placeholder') === null) {\n\t\t\t\tthis._input.setAttribute('placeholder', opts.placeholder || label);\n\t\t\t} else {\n\t\t\t\tthis._placeholder = $.create({\n\t\t\t\t\ttag: 'button',\n\t\t\t\t\ttext: label,\n\t\t\t\t\tstyle: {position: 'absolute'},\n\t\t\t\t\tparent: el\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tthis.initMouseEvents(el);\n\t\tthis.initFocusEvents(this._input);\n\t\tthis.initKeyEvents(this._input);\n\t}\n\n\tthis.focus = function () { this._input.focus(); }\n\tthis.blur = function () { this._input.blur(); }\n\n\tthis.getInputElement = function () { return this._input; }\n\n\tthis.setName = function(name) {\n\t\tsupr(this, 'setName', arguments);\n\n\t\tif (this._input) { this._input.name = name; }\n\t}\n\n\tthis.setData =\n\tthis.setValue = function (value) {\n\t\tif (value === undefined) { value = \"\"; }\n\n\t\tthis.saveSelection();\n\t\tthis._value = this._input.value = value;\n\t\tthis.restoreSelection();\n\t}\n\n\tthis.getValue = function() { return this._input.value; }\n\n\tthis.onKeyDown = function() {\n\t\tsupr(this, 'onKeyDown', arguments);\n\t\tif (this._placeholder) { $.hide(this._placeholder); }\n\t}\n\n\tthis.onKeyUp = function() {\n\t\tsupr(this, 'onKeyUp', arguments);\n\t\tthis.checkLabel();\n\t\tthis.checkValue();\n\t}\n\n\tthis.onMouseDown = function(evt) {\n\t\tsupr(this, 'onMouseDown', arguments);\n\n\t\tevt.stopPropagation();\n//\t\t$.stopEvent(evt);\n\t}\n\n\tthis.onKeyPress = function(e) {\n\t\tsupr(this, 'onKeyPress', arguments);\n\t\tif (e.keyCode == 13) {\n\t\t\tthis.publish('EnterPressed');\n\t\t}\n\t\tthis.checkValue();\n\t}\n\n\tthis.onBlur = function() {\n\t\tsupr(this, 'onBlur');\n\t\tthis.checkLabel();\n\n\t\tif (this._overlay) {\n\t\t\t$.show(this._overlay);\n\t\t}\n\t}\n\n\tthis.isValid = function () { return this._isValid; }\n\n\tthis.checkValue = function() {\n\t\tvar value = this._input.value;\n\t\tvar formatter = this._opts.formatter;\n\t\tif (formatter) {\n\t\t\tvalue = formatter(value);\n\t\t}\n\n\t\tif (value == INVALID_VALUE) {\n\t\t\tthis._isValid = false;\n\t\t\t$.addClass(this._el, 'invalid');\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isValid = true;\n\t\t$.removeClass(this._el, 'invalid');\n\t\tif (this._value != value) {\n\t\t\tthis._value = value;\n\t\t\tvar input = this._input;\n\t\t\tif (value != input.value) {\n\t\t\t\tthis.saveSelection();\n\t\t\t\tinput.value = value;\n\t\t\t\tthis.restoreSelection();\n\t\t\t}\n\t\t\tthis.publish('change', this._value);\n\t\t\tthis.publish('ValueChange', this._value);\n\t\t}\n\t}\n\n\tthis.saveSelection = function () {\n\t\tthis._selection = {\n\t\t\tstart: this._input.selectionStart,\n\t\t\tend: this._input.selectionEnd\n\t\t};\n\t}\n\n\tthis.restoreSelection = function () {\n\t\tvar input = this._input;\n\t\tif (this._isFocused) {\n\t\t\tinput.selectionStart = this._selection.start;\n\t\t\tinput.selectionEnd = this._selection.end;\n\t\t}\n\t}\n\n\tthis.checkLabel = function() {\n\t\tif(this._placeholder && /^\\s*$/.test(this._input.value)) {\n\t\t\t$.show(this._placeholder);\n\t\t}\n\t}\n\n\tthis.onClick = function() {\n\t\tsupr(this, 'onClick');\n\n\t\t//setTimeout(bind(this._input, 'focus'), 100);\n\t}\n\n\tthis.setEnabled = function (isEnabled) {\n\t\tthis._isEnabled = isEnabled;\n\t\tif (isEnabled) {\n\t\t\tdelete this._input.disabled;\n\t\t\tthis.removeClass('disabled');\n\t\t} else {\n\t\t\tthis._input.disabled = true;\n\t\t\tthis.addClass('disabled');\n\t\t}\n\t}\n\n\tthis.isEnabled = function () { return this._isEnabled; }\n\n\tthis.disable = function () { this.setEnabled(false); }\n\tthis.enable = function () { this.setEnabled(true); }\n});\n\nvar INVALID_VALUE = exports.INVALID_VALUE = {};\n\nWidget.register(TextInput, 'TextInput');\n");
jsio.setCachedSrc('../node_modules/squill/TextArea.js',"jsio('from util.browser import $');\njsio('import .Widget');\njsio('import .TextInput');\n\nvar TextArea = exports = Class(TextInput, function(supr) {\n\tthis._tag = 'textarea';\n});\n\nWidget.register(TextArea, 'TextArea');\n");
jsio.setCachedSrc('../node_modules/squill/Scroller.js',"jsio('import .Drag');\njsio('import .Widget');\njsio('import .transforms');\njsio('from util.browser import $');\n\nexports = Class(Widget, function(supr) {\n\tthis._css = 'scroller';\n\n\tthis.init = function(opts) {\n\t\topts = merge(opts, {\n\t\t\tmomentum: true\n\t\t});\n\n\t\tthis._scrollTop = 0;\n\t\tthis._lastDelta = {\n\t\t\tdiff: 0,\n\t\t\twhen: 0,\n\t\t\tduration: 0\n\t\t};\n\n\t\tthis._hasMomentum = opts.momentum;\n\n\t\tsupr(this, 'init', [opts]);\n\t}\n\n\tthis.buildContent = function() {\n\t\tvar el = this._el;\n\n\t\t$.style(el, {height: '100%'});\n\n\t\tthis._scrollPane = $({\n\t\t\tparent: el,\n\t\t\tclassName: 'squill-scrollPane',\n\t\t\tminHeight: '100%'\n\t\t});\n\n\t\tif ('ontouchstart' in el) {\n\t\t\tel.addEventListener('touchstart', bind(this, 'onTouchStart'), true);\n\t\t\tel.addEventListener('mousedown', this, 'start')\n\t\t\tthis.initDragEvents();\n\t\t\tthis._el.style.overflow = 'hidden';\n\t\t\ttransforms.setTop(this._scrollPane, 0);\n\t\t} else {\n\t\t\tthis._el.style.overflow = 'auto';\n\t\t}\n\n\t\tif (this._def) {\n\t\t\tvar def = this._def;\n\t\t\tthis._def = null; // don't handle it in the supr call\n\n\t\t\t// build children into the scroll pane\n\t\t\tthis.buildChildren(merge({el: this._scrollPane}, def));\n\t\t}\n\n\t\treturn supr(this, 'buildContent', arguments);\n\t}\n\n\tthis.getScrollTop = function() { return this._scrollTop; }\n\tthis.getContainer =\n\tthis.getScrollPane = function() { return this._scrollPane; }\n\n\tthis.onTouchStart = function() {\n\t\tif (this._momentum) { clearInterval(this._momentum); }\n\t}\n\n\tthis.onDragStart = function(dragEvt, mouseEvt) {\n\t\tthis._height = this._scrollPane.offsetHeight - this._el.offsetHeight;\n\t\tthis._lastDelta.when = +new Date();\n\t\tif (this._momentum) { clearInterval(this._momentum); }\n\t}\n\n\tthis.onDrag = function(dragEvt, moveEvt, delta) {\n\t\tvar now = +new Date(),\n\t\t\td = this._lastDelta;\n\n\t\td.diff = delta.y;\n\t\td.duration = d.when && (now - d.when) || 0;\n\t\td.when = now;\n\n\t\tthis.scrollTo(this._scrollTop + delta.y);\n\t}\n\n\tthis.scrollTo = function(y, animate) {\n\t\tthis._scrollTop = y;\n\t\tif (this._scrollTop < -this._height) { this._scrollTop = -this._height; }\n\t\tif (this._scrollTop > 0) { this._scrollTop = 0; }\n\n\t\tthis._el.setAttribute('squill-scroller-top', -this._scrollTop);\n\n\t\tvar onFinish = bind(this, function() {\n\t\t\tif (document.createEvent) {\n\t\t\t\tvar e = document.createEvent('HTMLEvents');\n\t\t\t\te.initEvent('scroll', true, false);\n\t\t\t\tthis._el.dispatchEvent(e);\n\t\t\t}\n\t\t});\n\n\t\tif (animate) {\n\t\t\ttransforms.move(this._scrollPane, 0, this._scrollTop, '0.5s ease-in-out', onFinish);\n\t\t} else {\n\t\t\ttransforms.move(this._scrollPane, 0, this._scrollTop);\n\t\t\tonFinish();\n\t\t}\n\t}\n\n\tthis.onDragStop = function(dragEvt, selectEvt) {\n\t\t$.stopEvent(selectEvt);\n\t\tif (this._hasMomentum && this._lastDelta.duration != 0) {\n\t\t\tvar d = this._lastDelta,\n\t\t\t\tspeed = d.diff / d.duration,\n\t\t\t\tstart = d.when,\n\t\t\t\ttime = d.when,\n\t\t\t\tdir = speed > 0 ? 1 : -1,\n\t\t\t\tdur = 2;\n\n\t\t\tthis._momentum = setInterval(bind(this, function() {\n\t\t\t\tvar now = +new Date(),\n\t\t\t\t\tdt = now - time,\n\t\t\t\t\tdistance = speed * dt;\n\n\t\t\t\tthis.scrollTo(this._scrollTop + distance);\n\n\t\t\t\t// TODO: this isn't based on dt which is bad!!!\n\t\t\t\tspeed *= 0.95;\n\t\t\t\tif (Math.abs(speed) < 0.01) {\n\t\t\t\t\tclearTimeout(this._momentum);\n\t\t\t\t\tthis._momentum = null;\n\t\t\t\t}\n\t\t\t\ttime = now;\n\t\t\t}), 10);\n\t\t}\n\t}\n});\n");
jsio.setCachedSrc('../node_modules/squill/transforms.js',"jsio('from util.browser import $');\n\nvar vendor = (/webkit/i).test(navigator.appVersion) ? 'webkit' :\n\t(/firefox/i).test(navigator.userAgent) ? 'Moz' :\n\t'opera' in window ? 'O' : '',\n\thas3d = 'WebKitCSSMatrix' in window && 'm11' in new WebKitCSSMatrix(),\n\thasTransform = vendor + 'Transform' in document.documentElement.style,\n\ttranslateStart = 'translate' + (has3d ? '3d(' : '('),\n\ttranslateEnd = has3d ? ',0)' : ')';\n\nif (hasTransform) {\n\texports.setLeft = function(el, left) {\n\t\tel.style[vendor + 'Transform'] = translateStart + left + 'px,0' + translateEnd;\n\t}\n\n\texports.setTop = function(el, top) {\n\t\tel.style[vendor + 'Transform'] = translateStart + '0,' + top + 'px' + translateEnd;\n\t}\n} else {\n\texports.setLeft = function(el, left) {\n\t\tel.style.left = left + 'px';\n\t}\n\n\texports.setTop = function(el, top) {\n\t\tel.style.top = top + 'px';\n\t}\n}\n\nexports.onTransitionEnd = function(el, cb) {\n\tvar executed = false;\n\tvar finished = function() {\n\t\tif (executed) { return; }\n\t\texecuted = true;\n\t\tfor (var i = 0, remove; remove = evts[i]; ++i) {\n\t\t\tremove();\n\t\t}\n\t\tcb();\n\t}\n\n\tvar evts = [\n\t\t$.onEvent(el, 'webkitTransitionEnd', finished),\n\t\t$.onEvent(el, 'transitionend', finished),\n\t\t$.onEvent(el, 'oTransitionEnd', finished)\n\t];\n}\n\nexports.setTransition = function(el, transition, cb) {\n\tif (transition) {\n\t\tvar oldTransition = el.style[vendor + 'Transition'];\n\t\texports.onTransitionEnd(el, function() {\n\t\t\tel.style[vendor + 'Transition'] = oldTransition;\n\t\t\tcb && cb();\n\t\t});\n\t\tel.style[vendor + 'Transition'] = '-' + vendor + '-transform ' + transition;\n\t} else {\n\t\tel.style[vendor + 'Transition'] = 'none';\n\t}\n}\n\nexports.rotate = function(el, rotation, transition, cb) {\n\tif (!hasTransform) { cb && cb(); return; }\n\texports.setTransition(el, transition, cb);\n\n\tel.style[vendor + 'Transform'] = 'rotate(' + rotation + ')';\n\n\tif (cb && !transition) { cb(); }\n}\n\nexports.move = function(el, x, y, transition, cb) {\n\tif (!hasTransform) { cb && cb(); return; }\n\texports.setTransition(el, transition, cb);\n\tel.style[vendor + 'Transform'] = translateStart + x + 'px,' + y + 'px' + translateEnd;\n\tif (cb && !transition) { cb(); }\n}\n\nexports.hasTransform = hasTransform;\n");
jsio.setCachedSrc('../node_modules/squill/Canvas.js',"jsio('from util.browser import $');\njsio('import .Widget');\n\nvar Canvas = exports = Class(Widget, function(supr) {\n\tthis._css = 'cnvs';\n\tthis._type = 'canvas';\n\n\tthis.init = function(params) {\n\t\tparams = merge(params, {tag: 'canvas'});\n\t\tthis._isEnabled = params.isEnabled;\n\t\tsupr(this, 'init', [params]);\n\t}\n\n\tthis.create = function() {\n\t\tsupr(this, 'create', arguments);\n\t};\n\n\tthis.buildWidget = function() {\n\t\tvar el = this._el;\n\n\t\tel.width = this._opts.width;\n\t\tel.height = this._opts.height;\n\t\tif (this._opts.color) {\n\t\t\tel.style.backgroundColor = this._opts.color;\n\t\t}\n\n\t\tthis.initMouseEvents(el);\n\t\tthis.initKeyEvents(el);\n\t};\n});\n\n");
jsio.setCachedSrc('../node_modules/squill/CheckBox.js',"\njsio('import .Widget');\njsio('from util.browser import $');\n\nvar CheckBox = exports = Class(Widget, function(supr) {\n\n\tthis._css = 'checkbox';\n\n\tthis._def = {\n\t\ttag: 'label',\n\t\tchildren: [\n\t\t\t{id: 'checkbox', tag: 'input', attrs: {type: 'checkbox'}},\n\t\t\t{tag: 'span', id: 'label', text: ''}\n\t\t]\n\t};\n\n\tthis.buildWidget = function() {\n\t\tthis.setLabel(this._opts.label || '');\n\t\tif (this._opts.name) {\n\t\t\tthis.setName(this._opts.name);\n\t\t}\n\n\t\tif (this._opts.value) {\n\t\t\tthis.setValue(this._opts.value);\n\t\t}\n\n\t\tthis.initMouseEvents(this.checkbox);\n\t\t$.onEvent(this.checkbox, 'change', this, '_onCheck');\n\n\t\tif (this._opts.__result) {\n\t\t\tthis._opts.__result.addSubscription(this, 'Select', this._opts.id);\n\t\t}\n\t}\n\n\tthis._onCheck = function() {\n\t\tthis.publish('Check', this.isChecked());\n\t\tthis.emit('change', this.isChecked());\n\t}\n\n\tthis.setLabel = function (label) { $.setText(this.label, label); }\n\tthis.setName = function (name) { this.checkbox.name = name; }\n\n\tthis.setData =\n\tthis.setValue = function (value) { this.checkbox.checked = !!value; }\n\n\tthis.isChecked = function () { return this.checkbox.checked; }\n\tthis.setChecked = function (isChecked) { this.checkbox.checked = isChecked; }\n\n\tthis.getValue = function () { return this.isChecked() ? this.checkbox.value : null; }\n});\n");
jsio.setCachedSrc('../node_modules/squill/Menu.js',"jsio('import lib.PubSub');\njsio('import .Widget');\njsio('import .Delegate');\n\njsio('from util.browser import $');\n\nvar Menu = exports = Class(Widget, function(supr) {\n  // this.init = function(params) {\n  //  var params = JS.merge(params, {parent: $.id('wrapper')});\n  //  supr(this, 'init', [params]);\n  // }\n\n  this._css = 'menu';\n\n  this._def = {\n    children: [{id: 'container'}]\n  };\n\n  // the default menu delegate just forwards to the menu controller\n  this.delegate = new Delegate(function(on) {\n    on.call = function(ctx, name) {\n      var delegate = ctx.controller.delegate;\n      delegate.call.apply(delegate, [ctx.controller].concat(Array.prototype.slice.call(arguments, 1)));\n    }\n  });\n\n  this.getContainer = function () { return this.container; }\n\n  this.onBeforeShow = function() {}\n  this.onShow = function() {}\n  this.onBeforeHide = function() {}\n  this.onHide = function() {}\n\n  this.toggle = function () {\n    if (this._isShowing) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  }\n\n  this.show = function() {\n    this._isShowing = true;\n\n    var menuEl = this._el;\n    var eventHandler = bind(this, function (e) {\n      var el = e.target;\n      while (el) {\n        if (el == menuEl) {\n          return true;\n        }\n\n        if (/squill-checkbox/.test(el.className)) {\n          return false;\n        }\n\n        el = el.parentNode;\n      }\n\n      // close menu\n      e.preventDefault && e.preventDefault();\n      e.stopImmediatePropagation && e.stopImmediatePropagation();\n      e.stopPropagation && e.stopPropagation();\n      e.cancelBubble = true;\n      return true;\n    });\n\n    var clickHandler = bind(this, function (e) {\n      if (eventHandler(e)) {\n        this.hide();\n\n        untrapIframes();\n        document.body.removeEventListener('mousedown', eventHandler, true);\n        document.body.removeEventListener('mouseup', eventHandler, true);\n        document.body.removeEventListener('click', clickHandler, true);\n      }\n    });\n\n    trapIframes();\n    document.body.addEventListener('mousedown', eventHandler, true);\n    document.body.addEventListener('mouseup', eventHandler, true);\n    document.body.addEventListener('click', clickHandler, true);\n\n    $.show(menuEl);\n\n    this.emit('open');\n    Menu.emit('open', this);\n  }\n\n  this.hide = function() {\n    this._isShowing = false;\n\n    $.hide(this._el);\n\n    this.emit('close');\n    Menu.emit('close', this);\n  }\n});\n\nvar subs = new lib.PubSub();\nMenu.emit = bind(subs, 'emit');\nMenu.on = bind(subs, 'on');\nMenu.removeListener = bind(subs, 'removeListener');\n\nvar _trappedFrames = [];\nfunction trapIframes() {\n  if (_trappedFrames.length) {\n    untrapIframes();\n  }\n\n  _trappedFrames = Array.prototype.map.call(document.getElementsByTagName('iframe'), function (el) {\n    var retVal = {\n        el: el,\n        set: el.style.pointerEvents\n      };\n\n    el.style.pointerEvents = 'none';\n\n    return retVal;\n  });\n}\n\nfunction untrapIframes() {\n  _trappedFrames.forEach(function (item) {\n    item.el.style.pointerEvents = item.set;\n  });\n}\n");
jsio.setCachedSrc('../node_modules/squill/Slider.js',"jsio('from util.browser import $');\njsio('import .Widget');\n\nvar Slider = exports = Class(Widget, function(supr) {\n\tthis._css = 'rng';\n\tthis._type = 'range';\n\n\tthis.init = function(params) {\n\t\tthis._width = params.width || 100;\n\t\tthis._padding = 12;\n\t\tthis._hover = false;\n\t\tthis._fillColor = params.fillColor || '#000000';\n\t\tthis._lineColor = params.lineColor || '#FFFFFF';\n\n\t\tthis._def = {\n\t\t\tchildren: [\n\t\t\t\t{\n\t\t\t\t\tid: params.id + 'Canvas',\n\t\t\t\t\ttag: 'canvas',\n\t\t\t\t\tattrs: {width: this._width, height: this._padding * 2}\n\t\t\t\t}\n\t\t\t]\n\t\t};\n\n\t\tsupr(this, 'init', [params]);\n\t};\n\n\tthis._render = function() {\n\t\tvar width = this._width,\n\t\t\tpadding = this._padding,\n\t\t\tctx = this._ctx,\n\t\t\tradialGradient,\n\t\t\tv;\n\n\t\tctx.clearRect(0, 0, width, padding * 2);\n\n\t\tctx.lineCap = 'round';\n\n\t\tctx.beginPath();\n\t\tctx.arc(padding + 2, padding, 2, Math.PI * 0.5, Math.PI * 1.5, false);\n\t\tctx.arc(width - padding - 2, padding, 2, Math.PI * 1.5, Math.PI * 0.5, false);\n\t\tctx.closePath();\n\n\t\tctx.lineWidth = 1;\n\t\tctx.strokeStyle = this._lineColor;\n\t\tctx.stroke();\n\t\tctx.fillStyle = this._fillColor;\n\t\tctx.fill();\n\n\t\tctx.save();\n\n\t\tif (this._hover) {\n\t\t\tctx.shadowOffsetX = 0;\n\t\t\tctx.shadowOffsetY = 0;\n\t\t\tctx.shadowBlur = 10;\n\t\t\tctx.shadowColor = '#0099FF';\n\t\t}\n\n\t\tv = ~~((width - padding * 2) * (this.value - this.min) / (this.max - this.min));\n\n\t\tctx.beginPath();\n\t\tctx.arc(padding + v, padding, 5, 0, Math.PI * 2, false);\n\t\tctx.closePath();\n\n\t\tradialGradient = ctx.createRadialGradient(padding - 1 + v, padding - 1, 0, padding + v, padding, 4);\n\n\t\tradialGradient.addColorStop(0, '#FFFFFF');\n\t\tradialGradient.addColorStop(1, '#707070');\n\t\tctx.fillStyle = radialGradient;\n\t\tctx.fill();\n\n\t\tctx.restore();\n\t};\n\n\tthis.buildWidget = function() {\n\t\tvar el = this._el;\n\t\t\tcanvas = el.firstChild;\n\n\t\tel.slider = this;\n\n\t\t$.onEvent(canvas, 'mouseout', this, '_onMouseOut');\n\t\t$.onEvent(canvas, 'mousedown', this, '_onMouseDown');\n\t\t$.onEvent(canvas, 'mouseup', this, '_onMouseUp');\n\t\t$.onEvent(canvas, 'mousemove', this, '_onMouseMove');\n\n\t\tthis.min = this._opts.min || 0;\n\t\tthis.max = this._opts.max || 100;\n\t\tthis.step = this._opts.step || 1;\n\t\tthis.value = this._opts.value || 0;\n\n\t\tthis._mouseDown = false;\n\t\tthis._checkRange();\n\t\tthis._ctx = canvas.getContext('2d');\n\t\tthis._render();\n\t};\n\n\tthis.setValue = function(value) {\n\t\tthis.value = value;\n\t\tthis._render();\n\t};\n\n\tthis._onChange = function() {\n\t\tthis.publish('Change', this.value);\n\t};\n\n\tthis._checkRange = function() {\n\t\tif (this.value < this.min) {\n\t\t\tthis.value = this.min;\n\t\t}\n\t\tif (this.value > this.max) {\n\t\t\tthis.value = this.max;\n\t\t}\n\t};\n\n\tthis._checkMouse = function(evt) {\n\t\tvar mouseX = evt.offsetX,\n\t\t\tmouseY = evt.offsetY,\n\t\t\twidth = this._width,\n\t\t\tpadding = this._padding,\n\t\t\thover = this._hover,\n\t\t\tvalue;\n\n\t\tif (this._mouseDown) {\n\t\t\tif ((mouseX > padding) && (mouseY > padding - 5) && (mouseX < width - padding) && (mouseY < padding + 5)) {\n\t\t\t\tvalue = (evt.offsetX - padding) / (width - padding * 2) * (this.max - this.min);\n\t\t\t\tvalue = this.min + Math.round(value / this.step) * this.step;\n\t\t\t\tthis.value = value;\n\t\t\t\tthis._checkRange();\n\t\t\t\tthis._render();\n\t\t\t\tthis._onChange();\n\t\t\t}\n\t\t} else {\n\t\t\tif ((mouseY > padding - 5) && (mouseY < padding + 5)) {\n\t\t\t\tv = padding + ~~((width - padding * 2) * (this.value - this.min) / (this.max - this.min));\n\t\t\t\tthis._hover = (mouseX > v - 5) && (mouseY < v + 5);\n\t\t\t} else {\n\t\t\t\tthis._hover = false;\n\t\t\t}\n\n\t\t\tif (this._hover !== hover) {\n\t\t\t\tthis._render();\n\t\t\t}\n\t\t}\n\t};\n\n\tthis._onMouseOut = function(evt) {\n\t\tthis._mouseDown = false;\n\t\tthis._hover = false;\n\t\tthis._render();\n\t};\n\n\tthis._onMouseDown = function(evt) {\n\t\tthis._mouseDown = true;\n\t\tthis._checkMouse(evt);\n\t};\n\n\tthis._onMouseUp = function(evt) {\n\t\tthis._mouseDown = false;\n\t};\n\n\tthis._onMouseMove = function(evt) {\n\t\tthis._checkMouse(evt);\n\t};\n});\n\n");
jsio.setCachedSrc('../node_modules/squill/Color.js',"jsio('from util.browser import $');\njsio('import .Widget');\n\njsio('import .jscolor.jscolor as jscolor');\n\nvar Color = exports = Class(Widget, function(supr) {\n\tthis._css = 'clr';\n\tthis._type = 'text';\n\n\tthis.init = function(params) {\n\t\tparams = merge(params, {tag: 'input'});\n\t\tthis._isEnabled = params.isEnabled;\n\n\t\tsupr(this, 'init', [params]);\n\n\t};\n\n\tthis.buildWidget = function() {\n\t\tvar el = this._el;\n\n\t\t$.addClass(el, 'squill-color');\n\t\tel.min = this._opts.min || 0;\n\t\tel.max = this._opts.max || 100;\n\t\tel.step = this._opts.step || 1;\n\t\tel.value = this._opts.value || 0;\n\t\tel.onchange = bind(this, this._onChange);\n\n\t\tjscolor.bind(el);\n\t};\n\n\tthis.setValue = function(value) {\n\t\tif (value) {\n\t\t\tif (value[0] !== '#') {\n\t\t\t\tvalue = '#' + value;\n\t\t\t}\n\t\t\tthis._el.style.backgroundColor = value;\n\n\t\t\tvalue = value.substr(1, 6);\n\t\t}\n\t\tthis._el.value = value;\n\t};\n\n\tthis.getValue = function() {\n\t\treturn this._el.value;\n\t};\n\n\tthis._onChange = function() {\n\t\tthis.publish('Change', this._el.value);\n\t};\n});\n\n");
jsio.setCachedSrc('../node_modules/squill/VerticalCenter.js',"jsio('import .Widget');\njsio('from util.browser import $');\n\nexports = Class(Widget, function() {\n\tthis._def = {\n\t\ttag: 'table',\n\t\tstyle: merge({height: '100%', width: '100%'}, def.style),\n\t\tattrs: {cellpadding: 0, cellspacing: 0},\n\t\tchildren: [\n\t\t\t$({tag: 'tbody', children: [\n\t\t\t\t$({tag: 'tr', children: [\n\t\t\t\t\t$({id: 'contentPane', tag: 'td', attrs: {valign: 'middle'}, style: {verticalAlign: 'middle'}})\n\t\t\t\t]})\n\t\t\t]})\n\t\t]\n\t};\n\n\tthis.addElement = function() { this.contentPane.appendChild(el); }\n});\n");
jsio.setCachedSrc('../node_modules/squill/TreeList.js',"jsio('from util.browser import $');\n\njsio('import .Widget');\n\nvar elementIDPrefix = 0;\n\nvar TreeList = exports = Class(Widget, function(supr) {\n\tvar defaults = {\n\t\tkey: 'id',\n\t\tlabel: 'title',\n\t\twrapperId: 'browser',\n\t\tcontentId: 'contentWrapper'\n\t};\n\n\tthis.init = function(opts) {\n\t\topts = opts || {};\n\t\topts = merge(opts, defaults);\n\n\t\tthis._initClasses(opts);\n\n\t\tthis._key = opts.key;\n\t\tthis._label = opts.label;\n\t\tthis._wrapperId = opts.wrapperId;\n\t\tthis._contentId = opts.contentId;\n\t\tthis._leaveWidth = opts.leaveWidth || 600;\n\n\t\telementIDPrefix++;\n\t\tthis._elementIDPrefix = 'menuItem' + elementIDPrefix + '_';\n\n\t\tif (opts.dataSource) {\n\t\t\tthis.setDataSource(opts.dataSource);\n\t\t} else {\n\t\t\tthis._dataSource = null;\n\t\t}\n\n\t\tthis._def = {id: this._wrapperId, className: 'browser', children: [\n\t\t\t\t\t\t{id: this._contentId, className: 'contentWrapper', children: []}\n\t\t\t\t\t]};\n\n\t\tthis._root = null;\n\t\tthis._itemByKey = {};\n\n\t\tsupr(this, 'init', arguments);\n\t};\n\n\tthis._initClasses = function(opts) {\n\t\tthis._classNames = {\n\t\t\tnodeWrapper: opts.nodeWrapper || 'browserNodeWrapper',\n\t\t\tnodeWrapperHidden: opts.nodeWrapperHidden || 'browserNodeWrapperHidden',\n\t\t\tnode: opts.node || 'browserNode',\n\t\t\tnodeChildren: opts.nodeChildren || 'children', // Node has children...\n\t\t\tnodeActive: opts.nodeActive || 'active', // Selected node...\n\t\t\tnodeActiveChild: opts.nodeActiveChild || 'browserNodeActiveChild'\n\t\t};\n\t};\n\n\tthis._clearItem = function(item) {\n\t\tvar parent,\n\t\t\tchildren,\n\t\t\ti, j;\n\n\t\tif (item.children) {\n\t\t\tchildren = item.children;\n\t\t\twhile (children.length) {\n\t\t\t\tthis._clearItem(children.pop());\n\t\t\t}\n\t\t}\n\n\t\tif (item.parent) {\n\t\t\tparent = item.parent;\n\t\t\tchildren = parent.children;\n\t\t\tfor (i = 0, j = children.length; i < j; i++) {\n\t\t\t\tif (children[i] === item) {\n\t\t\t\t\tchildren.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!children.length && parent.group) {\n\t\t\t\t$.remove(parent.group.parentNode);\n\t\t\t\t$.remove(parent.group);\n\t\t\t\tdelete(parent.group);\n\t\t\t}\n\t\t}\n\n\t\t$.remove(item.node);\n\t\titem.group && $.remove(item.group);\n\t};\n\n\tthis._createMenuId = function(inc) {\n\t\tvar menuId = this._menuId;\n\t\tif (inc) {\n\t\t\tthis._menuId++;\n\t\t}\n\t\treturn this._elementIDPrefix + menuId;\n\t};\n\n\tthis._createGroup = function(visible) {\n\t\tvar menuId = this._createMenuId(true),\n\t\t\tnode = $({\n\t\t\t\t\tparent: $({\n\t\t\t\t\t\t\t\tparent: $.id(this._contentId),\n\t\t\t\t\t\t\t\tid: menuId,\n\t\t\t\t\t\t\t\tclassName: visible ? this._classNames.nodeWrapper : this._classNames.nodeWrapperHidden\n\t\t\t\t\t\t\t}),\n\t\t\t\t\tclassName: this._classNames.node\n\t\t\t\t});\n\n\t\tnode.menuId = menuId;\n\t\treturn node;\n\t};\n\n\tthis._createItem = function(item, group) {\n\t\tvar id = this._createMenuId(true);\n\n\t\titem.node = $({parent: group, id: id, tag: 'a', text: item[this._label]});\n\t\t$.onEvent(id, 'click', this, 'onClick', item);\n\t};\n\n\tthis.buildWidget = function() {\n\t\tthis._menuId = 0;\n\t\tthis._menuById = [];\n\t\tthis._menuStack = [];\n\t\tthis._menuActiveItem = false;\n\n\t\tif (this._dataSource !== null) {\n\t\t\tthis._dataSource.each(bind(this, this.onCreateItem));\n\t\t}\n\t};\n\n\tthis._removeFromStack = function(depth) {\n\t\tvar menuStack = this._menuStack,\n\t\t\tinfo = null;\n\n\t\twhile (menuStack.length && (menuStack[menuStack.length - 1].depth >= depth)) {\n\t\t\tinfo = menuStack.pop();\n\n\t\t\t$.removeClass(info.node.id, this._classNames.nodeActive);\n\t\t\t$.removeClass(info.node.id, this._classNames.nodeActiveChild);\n\n\t\t\tif (info.group) {\n\t\t\t\t$.addClass(info.group.menuId, this._classNames.nodeWrapperHidden);\n\t\t\t\t$.removeClass(info.group.menuId, this._classNames.nodeWrapper);\n\t\t\t}\n\t\t}\n\n\t\treturn info;\n\t};\n\n\tthis.applyNodeStyle = function(item) {\n\t\tif (item.children && item.children.length) {\n\t\t\t$.addClass(item.node, this._classNames.nodeChildren);\n\t\t} else {\n\t\t\t$.removeClass(item.node, this._classNames.nodeChildren)\n\t\t}\n\t\tif (item === this._menuActiveItem) {\n\t\t\t$.addClass(item.node, this._classNames.nodeActive);\n\t\t} else {\n\t\t\t$.removeClass(item.node, this._classNames.nodeActive);\n\t\t}\n\n\t\tif ((item.removeCustomClass !== undefined) && item.removeCustomClass) {\n\t\t\t$.removeClass(item.node, item.removeCustomClass);\n\t\t}\n\t\tif ((item.customClass !== undefined) && item.customClass) {\n\t\t\t$.removeClass(item.node, item.customClass);\n\t\t\t$.addClass(item.node, item.customClass);\n\t\t}\n\t};\n\n\tthis._addToStack = function(item) {\n\t\tthis._menuStack.push(item);\n\t\tthis.applyNodeStyle(item);\n\n\t\tif (item.children && item.children.length) {\n\t\t\tif (!item.group) {\n\t\t\t\tvar child,\n\t\t\t\t\ti, j;\n\n\t\t\t\titem.children.sort();\n\n\t\t\t\titem.group = this._createGroup(true);\n\t\t\t\tfor (i = 0, j = item.children.length; i < j; i++) {\n\t\t\t\t\tchild = item.children[i];\n\t\t\t\t\tthis._createItem(child, item.group);\n\n\t\t\t\t\t// DisplayItem might change the styling of the element!\n\t\t\t\t\tthis.publish('DisplayItem', child.data, child);\n\t\t\t\t\tthis.applyNodeStyle(child);\n\t\t\t\t}\n\t\t\t}\n\t\t\t$.addClass(item.group.menuId, this._classNames.nodeWrapper);\n\t\t\t$.removeClass(item.group.menuId, this._classNames.nodeWrapperHidden);\n\t\t}\n\t};\n\n\tthis.onClick = function(item) {\n\t\tvar menuStack = this._menuStack;\n\t\tvar lastItem = null;\n\t\tvar id;\n\t\tvar i;\n\n\t\tthis.publish('SelectItem', item.data, item);\n\n\t\tif (this._menuActiveItem) {\n\t\t\tlastItem = this._menuActiveItem;\n\t\t\tthis._menuActiveItem = null;\n\t\t\tthis.applyNodeStyle(lastItem);\n\t\t\tlastItem = null;\n\t\t}\n\n\t\tif (menuStack.length && (item.depth <= menuStack[menuStack.length - 1].depth)) {\n\t\t\tlastItem = this._removeFromStack(item.depth);\n\t\t}\n\t\tif (lastItem !== item) {\n\t\t\tthis._addToStack(item);\n\t\t}\n\n\t\tthis._menuActiveItem = item;\n\t\tthis.applyNodeStyle(item);\n\n\t\tif (menuStack.length) {\n\t\t\ti = menuStack.length;\n\t\t\tif (menuStack[menuStack.length - 1].children && menuStack[menuStack.length - 1].children.length) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t$.id(this._contentId).style.width = (i * 200 + this._leaveWidth) + 'px';\n\t\t}\n\t};\n\n\tthis.onUpdateItem = function(item, key) {\n\t\tvar treeItem = {\n\t\t\t\ttitle: item[this._label],\n\t\t\t\ttoString: function() { return this.title; }\n\t\t\t},\n\t\t\tparentItem,\n\t\t\tchildren,\n\t\t\tchild,\n\t\t\ti, j;\n\n\t\tif (this._itemByKey[key]) {\n\t\t\tif (this._itemByKey[key].node) {\n\t\t\t\tthis._itemByKey[key].node.innerHTML = item[this._label];\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif ((item.parent === null) || (item.parent === -1)) {\n\t\t\tif (this._root === null) {\n\t\t\t\tthis._rootGroup = this._createGroup(true);\n\t\t\t\tthis._createItem(treeItem, this._rootGroup);\n\t\t\t\tthis._root = treeItem;\n\n\t\t\t\ttreeItem.data = item;\n\t\t\t\ttreeItem.depth = 0;\n\t\t\t\ttreeItem.parent = null;\n\n\t\t\t\t// DisplayItem might change the styling of the element!\n\t\t\t\tthis.publish('DisplayItem', treeItem.data, treeItem);\n\t\t\t\tthis.applyNodeStyle(treeItem);\n\t\t\t}\n\t\t} else {\n\t\t\tparentItem = this._itemByKey[item.parent[this._key]];\n\t\t\tif (parentItem) {\n\t\t\t\tif (!parentItem.children) {\n\t\t\t\t\tparentItem.children = [];\n\t\t\t\t}\n\t\t\t\tchildren = parentItem.children;\n\n\t\t\t\tif (this._menuActiveItem && ((this._menuActiveItem === parentItem) || (this._menuActiveItem.parent === parentItem))) {\n\t\t\t\t\tfor (i = 0, j = children.length; i < j; i++) {\n\t\t\t\t\t\tif (children[i].node) {\n\t\t\t\t\t\t\t$.remove(children[i].node)\n\t\t\t\t\t\t\tchildren[i].node = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tchildren.push(treeItem);\n\t\t\t\t\tchildren.sort();\n\n\t\t\t\t\tif (!parentItem.group) {\n\t\t\t\t\t\tparentItem.group = this._createGroup(true);\n\t\t\t\t\t\t$.id(this._contentId).style.width = ((this._menuStack.length + 1) * 200 + 500) + 'px';\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 0, j = children.length; i < j; i++) {\n\t\t\t\t\t\tchild = children[i];\n\t\t\t\t\t\tthis._createItem(child, parentItem.group);\n\n\t\t\t\t\t\t// DisplayItem might change the styling of the element!\n\t\t\t\t\t\tthis.publish('DisplayItem', child.data, child);\n\t\t\t\t\t\tthis.applyNodeStyle(child);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tchildren.push(treeItem);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttreeItem.depth = parentItem.depth + 1;\n\t\t\ttreeItem.parent = parentItem;\n\t\t}\n\n\t\ttreeItem.data = item;\n\t\tthis._itemByKey[key] = treeItem;\n\t};\n\n\tthis.onCreateItem = function(item) {\n\t\tthis.onUpdateItem(item, item[this._key]);\n\t};\n\n\tthis.onRemoveItem = function(item, key) {\n\t\tvar treeItem = this._itemByKey[key];\n\t\tvar lastChild;\n\t\tvar treeParent;\n\n\t\tif (treeItem) {\n\t\t\tlastChild = (treeItem.parent.children.length <= 1);\n\t\t\ttreeParent = item[this._dataSource.parentKey];\n\n\t\t\tthis._removeFromStack(this._itemByKey[key].depth - 1);\n\t\t\tthis._clearItem(this._itemByKey[key]);\n\t\t\tthis._menuActiveItem = false;\n\n\t\t\tdelete(this._itemByKey[key]);\n\t\t\tthis.publish('UnSelectItem');\n\n\t\t\tif (lastChild && treeParent) {\n\t\t\t\ttreeItem = this._itemByKey[treeParent[this._dataSource.key]];\n\t\t\t\tthis.publish('DisplayItem', treeItem.data, treeItem);\n\t\t\t\tthis.applyNodeStyle(treeItem);\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.showItem = function(item) {\n\t\tvar treeItem = this.getTreeNode(item);\n\t\tthis.publish('DisplayItem', item, treeItem);\n\t\tthis.applyNodeStyle(treeItem);\n\t};\n\n\tthis.setDataSource = function(dataSource) {\n\t\tthis._dataSource = dataSource;\n\t\tthis._dataSource.subscribe('Update', this, this.onUpdateItem);\n\t\tthis._dataSource.subscribe('Remove', this, this.onRemoveItem);\n\t};\n\n\tthis.getPathString = function(separator) {\n\t\tvar result = '',\n\t\t\tmenuStack = this._menuStack,\n\t\t\ti, j;\n\n\t\tseparator = separator || ' ';\n\t\tfor (i = 0, j = menuStack.length; i < j; i++) {\n\t\t\tif (result !== '') {\n\t\t\t\tresult += separator;\n\t\t\t}\n\t\t\tresult += menuStack[i].data[this._label];\n\t\t}\n\n\t\treturn result;\n\t};\n\n\tthis.getTreeNode = function(item) {\n\t\treturn this._itemByKey[item[this._dataSource.key]];\n\t};\n});\n");
jsio.setCachedSrc('../node_modules/squill/Graph.js',"jsio('from util.browser import $');\njsio('import .Widget');\n\njsio('import .hint as hint');\n\nvar Graph = exports = Class(Widget, function(supr) {\n\tthis._css = 'cnvs';\n\tthis._type = 'canvas';\n\n\tthis.init = function(opts) {\n\t\tparams = merge(opts, {tag: 'canvas'});\n\t\tsupr(this, 'init', arguments);\n\n\t\tthis.setSettings(opts.settings || {});\n\n\t\tthis._width = opts.width || 400;\n\t\tthis._height = opts.height || 400;\n\n\t\tthis._rectangles = [];\n\t\tthis._data = false;\n\n\t\t$.onEvent(this._el, 'mousemove', this, this._onMouseMove);\n\t\t$.onEvent(this._el, 'mouseout', this, this._onMouseOut);\n\t};\n\n\tthis._onMouseMove = function(evt) {\n\t\tvar rectangles = this._rectangles,\n\t\t\trectangle,\n\t\t\tfound = false,\n\t\t\ti = rectangles.length;\n\n\t\twhile (i) {\n\t\t\trectangle = rectangles[--i];\n\t\t\tif ((evt.offsetX >= rectangle.x1) && (evt.offsetY >= rectangle.y1) &&\n\t\t\t\t(evt.offsetX <= rectangle.x2) && (evt.offsetY <= rectangle.y2)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (found) {\n\t\t\thint.show(evt.pageX + 15, evt.pageY + 15, rectangle.label);\n\t\t} else {\n\t\t\thint.hide();\n\t\t}\n\t};\n\n\tthis._onMouseOut = function(evt) {\n\t\thint.hide();\n\t};\n\n\tthis.buildWidget = function() {\n\t\tvar el = this._el;\n\n\t\tthis.initMouseEvents(el);\n\t\tthis.initKeyEvents(el);\n\t};\n\n\tthis._renderBackground = function(ctx) {\n\t\tvar el = this._el,\n\t\t\twidth = el.width,\n\t\t\theight = el.height;\n\n\t\tthis._currentWidth = width;\n\t\tthis._currentHeight = height;\n\n\t\tif (this._settings.fillColor) {\n\t\t\tctx.fillStyle = this._settings.fillColor;\n\t\t\tctx.fillRect(0, 0, width, height);\n\t\t} else {\n\t\t\tctx.clearRect(0, 0, width, height);\n\t\t}\n\t};\n\n\tthis._calculateSegments = function(ctx, data) {\n\t\tvar settings = this._settings,\n\t\t\tmax = 0,\n\t\t\tmaxLabel = 0,\n\t\t\ti, j = data.length,\n\t\t\tk, l;\n\n\t\tfor (i = 0; i < j; i++) {\n\t\t\titem = data[i];\n\t\t\tmaxLabel = Math.max(ctx.measureText(item.title).width, maxLabel);\n\t\t\tif (maxLabel > settings.maxLabelSize) {\n\t\t\t\tmaxLabel = settings.maxLabelSize;\n\t\t\t}\n\t\t\tfor (k = 0, l = item.points.length; k < l; k++) {\n\t\t\t\tmax = Math.max(item.points[k], max);\n\t\t\t}\n\t\t}\n\n\t\tvar steps = [0.5, 0.25, 0.2, 0.125, 0.1],\n\t\t\tstepIndex = 0,\n\t\t\tstepCount,\n\t\t\tfactor = 1;\n\n\t\twhile (max / (steps[stepIndex] * factor) > 10) {\n\t\t\tstepIndex++;\n\t\t\tif (stepIndex >= steps.length) {\n\t\t\t\tstepIndex = 0;\n\t\t\t\tfactor *= 10;\n\t\t\t}\n\t\t}\n\n\t\tstepCount = Math.ceil(max / (steps[stepIndex] * factor));\n\t\treturn {\n\t\t\tsteps: stepCount,\n\t\t\tstep: steps[stepIndex],\n\t\t\tmax: stepCount * steps[stepIndex] * factor,\n\t\t\tmaxLabel: maxLabel + 4,\n\t\t\tfactor: factor\n\t\t}\n\t};\n\n\tthis._trimLabel = function(segmentInfo, ctx, label) {\n\t\tif (ctx.measureText(label).width > segmentInfo.maxLabel) {\n\t\t\twhile (ctx.measureText(label + '...').width > segmentInfo.maxLabel) {\n\t\t\t\tlabel = label.substr(0, label.length - 1);\n\t\t\t}\n\t\t\tlabel += '...';\n\t\t}\n\t\treturn label;\n\t};\n\n\tthis._renderHorizontalAxis = function(segmentInfo, ctx, data) {\n\t\tvar settings = this._settings,\n\t\t\tvalueSpace = settings.valueSpace,\n\t\t\tmainPadding = settings.mainPadding,\n\t\t\twidth = this._currentWidth - mainPadding * 2 - valueSpace,\n\t\t\theight = this._currentHeight - mainPadding * 2 - segmentInfo.maxLabel,\n\t\t\tstep = width / data.length,\n\t\t\tlabel,\n\t\t\thasDecimal,\n\t\t\tx, y,\n\t\t\ti, j, k;\n\n\t\tctx.strokeStyle = settings.barBackground;\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tx = valueSpace + mainPadding + 0.5 + i * width;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, mainPadding);\n\t\t\tctx.lineTo(x, mainPadding + height);\n\t\t\tctx.stroke();\n\t\t}\n\n\t\tctx.textAlign = 'right';\n\t\tctx.textBaseline = 'top';\n\n\t\tfor (i = 0, j = data.length; i < j; i++) {\n\t\t\tx = valueSpace + mainPadding + i * step;\n\t\t\tctx.save();\n\t\t\tctx.rotate(Math.PI * -0.5);\n\t\t\tlabel = this._trimLabel(segmentInfo, ctx, data[i].title);\n\n\t\t\tctx.fillStyle = this._settings.textColor;\n\t\t\tctx.fillText(label, -(mainPadding + height + 4), x);\n\t\t\tctx.restore();\n\n\t\t\tif ((i & 1) === 0) {\n\t\t\t\tctx.fillStyle = settings.barBackground;\n\t\t\t\tctx.fillRect(x, mainPadding, step, height);\n\t\t\t}\n\t\t}\n\n\t\tctx.strokeStyle = this._settings.lineColor;\n\t\tctx.fillStyle = '#000000';\n\n\t\thasDecimal = 0;\n\t\ti = height;\n\t\tj = 0;\n\t\twhile (i >= 0) {\n\t\t\tlabel = (j * segmentInfo.step).toString(10);\n\t\t\tk = label.indexOf('.');\n\t\t\tif (k !== -1) {\n\t\t\t\tk = label.length - k - 1;\n\t\t\t\tif (k > hasDecimal) {\n\t\t\t\t\thasDecimal = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = Math.ceil(i - height / segmentInfo.steps);\n\t\t\tj++;\n\t\t}\n\n\t\ti = height;\n\t\tj = 0;\n\t\twhile (i >= 0) {\n\t\t\tx = mainPadding + valueSpace;\n\t\t\ty = mainPadding + ~~i + 0.5;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y);\n\t\t\tctx.lineTo(x + width, y);\n\t\t\tctx.stroke();\n\n\t\t\tlabel = (j * segmentInfo.step).toString(10);\n\t\t\tif (hasDecimal && (label.indexOf('.') === -1)) {\n\t\t\t\tlabel += '.';\n\t\t\t\tfor (k = 0; k < hasDecimal; k++) {\n\t\t\t\t\tlabel += '0';\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx.fillStyle = this._settings.textColor;\n\t\t\tctx.fillText(label, valueSpace + mainPadding - 2, mainPadding + i - 8);\n\n\t\t\ti = Math.ceil(i - height / segmentInfo.steps);\n\t\t\tj++;\n\t\t}\n\n\t\tctx.textAlign = 'left';\n\n\t\tlabel = settings.mainLabel + ' x' + segmentInfo.factor;\n\n\t\ti = mainPadding;\n\t\tj = mainPadding + height / 2 + (ctx.measureText(label).width + settings.itemSize) / 2;\n\t\tctx.save();\n\t\tctx.rotate(Math.PI * -0.5);\n\t\tctx.fillStyle = this._settings.textColor;\n\t\tctx.fillText(label, -j - settings.itemSize, i);\n\t\tctx.restore();\n\n\t\tj -= ctx.measureText(label).width;\n\t\tctx.beginPath();\n\t\tctx.moveTo(i + 7.5, j);\n\t\tctx.lineTo(i + 7.5, j + 26);\n\t\tctx.stroke();\n\n\t\tctx.beginPath();\n\t\tctx.moveTo(i + 3.5, j + 5.5);\n\t\tctx.lineTo(i + 7.5, j);\n\t\tctx.lineTo(i + 11.5, j + 5.5);\n\t\tctx.stroke();\n\t};\n\n\tthis._renderVerticalBars = function(segmentInfo, ctx, data) {\n\t\tvar settings = this._settings,\n\t\t\tvalueSpace = settings.valueSpace,\n\t\t\tmainPadding = settings.mainPadding,\n\t\t\twidth = this._currentWidth - mainPadding * 2 - valueSpace,\n\t\t\theight = this._currentHeight - mainPadding * 2 - segmentInfo.maxLabel,\n\t\t\tstep = width / data.length,\n\t\t\tbarWidth = step - settings.barPadding * 2,\n\t\t\tbarWidthSeg,\n\t\t\tbarHeight,\n\t\t\tbarX,\n\t\t\titem,\n\t\t\tpoints,\n\t\t\ti, j, k, l;\n\n\t\tctx.globalAlpha = 0.9;\n\t\tfor (i = 0, j = data.length; i < j; i++) {\n\t\t\titem = data[i];\n\t\t\tpoints = item.points;\n\n\t\t\tl = points.length;\n\t\t\tbarWidthSeg = ~~(barWidth / l);\n\t\t\tfor (k = 0; k < l; k++) {\n\t\t\t\tbarHeight = item.points[k] / segmentInfo.max * height;\n\t\t\t\tbarX = valueSpace + mainPadding + i * step + settings.barPadding;\n\t\t\t\tbarY = mainPadding + height - barHeight;\n\n\t\t\t\tctx.fillStyle = settings.dataColors[k % settings.dataColors.length];\n\t\t\t\tctx.fillRect(barX + k * barWidthSeg, barY, barWidthSeg - 1, barHeight);\n\t\t\t}\n\t\t}\n\t\tctx.globalAlpha = 1;\n\t};\n\n\tthis._renderVerticalPoints = function(segmentInfo, ctx, data) {\n\t\tvar settings = this._settings,\n\t\t\trenderPoints = (settings.types.indexOf('points') !== -1),\n\t\t\trenderLines = (settings.types.indexOf('lines') !== -1),\n\t\t\trenderArea = (settings.types.indexOf('area') !== -1),\n\t\t\tvalueSpace = settings.valueSpace,\n\t\t\tmainPadding = settings.mainPadding,\n\t\t\twidth = this._currentWidth - mainPadding * 2 - valueSpace,\n\t\t\theight = this._currentHeight - mainPadding * 2 - segmentInfo.maxLabel,\n\t\t\tstep = width / data.length,\n\t\t\tpointWidth = step - settings.barPadding * 2,\n\t\t\tpointX, pointY,\n\t\t\tpoints,\n\t\t\tpoint,\n\t\t\tpointList = [],\n\t\t\thasLast,\n\t\t\titem,\n\t\t\ti, j, k, l;\n\n\t\tpointYLast = null;\n\n\t\tfor (i = 0, j = data.length; i < j; i++) {\n\t\t\titem = data[i];\n\t\t\tpoints = item.points;\n\n\t\t\thasLast = pointYLast !== null;\n\t\t\tif (pointYLast === null) {\n\t\t\t\tpointYLast = [];\n\t\t\t}\n\t\t\tpointX = ~~(valueSpace + mainPadding + i * step + settings.barPadding + (pointWidth / 2));\n\t\t\tfor (k = 0, l = points.length; k < l; k++) {\n\t\t\t\tpointY = ~~(mainPadding + height - item.points[k] / segmentInfo.max * height);\n\n\t\t\t\tif (!pointList[k]) {\n\t\t\t\t\tpointList[k] = [];\n\t\t\t\t}\n\t\t\t\tpointList[k].push({x: pointX, y: pointY});\n\n\t\t\t\tctx.strokeStyle = settings.dataColors[k % settings.dataColors.length];\n\t\t\t\tif (renderPoints) {\n\t\t\t\t\tctx.strokeRect(pointX - 4.5, pointY - 4.5, 10, 10);\n\t\t\t\t}\n\n\t\t\t\tif (hasLast && renderLines) {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(pointXLast, pointYLast[k]);\n\t\t\t\t\tctx.lineTo(pointX, pointY);\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\n\t\t\t\tpointYLast[k] = pointY;\n\t\t\t}\n\t\t\tpointXLast = pointX;\n\t\t}\n\n\t\tif (renderArea) {\n\t\t\tctx.globalAlpha = 0.05;\n\t\t\tfor (i = 0, j = pointList.length; i < j; i++) {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.lineTo(pointList[i][0].x, mainPadding + height);\n\t\t\t\tfor (k = 0, l = pointList[i].length; k < l; k++) {\n\t\t\t\t\tpoint = pointList[i][k];\n\t\t\t\t\tctx.lineTo(point.x, point.y);\n\t\t\t\t}\n\t\t\t\tctx.lineTo(pointList[i][l - 1].x, mainPadding + height);\n\t\t\t\tctx.closePath();\n\t\t\t\tctx.fillStyle = settings.dataColors[i % settings.dataColors.length];\n\t\t\t\tctx.fill();\n\t\t\t}\n\t\t\tctx.globalAlpha = 1;\n\t\t}\n\t};\n\n\tthis._renderVerticalAxis = function(segmentInfo, ctx, data) {\n\t\tvar settings = this._settings,\n\t\t\tvalueSpace = settings.valueSpace,\n\t\t\tmainPadding = settings.mainPadding,\n\t\t\twidth = this._currentWidth - mainPadding * 2 - segmentInfo.maxLabel,\n\t\t\theight = this._currentHeight - mainPadding * 2 - valueSpace,\n\t\t\tstep = height / data.length,\n\t\t\tlabel,\n\t\t\thasDecimal,\n\t\t\tx, y,\n\t\t\ti, j, k;\n\n\t\tctx.strokeStyle = settings.barBackground;\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\ty = mainPadding + 0.5 + i * height;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(mainPadding + segmentInfo.maxLabel, y);\n\t\t\tctx.lineTo(mainPadding + segmentInfo.maxLabel + width, y);\n\t\t\tctx.stroke();\n\t\t}\n\n\t\tctx.textAlign = 'right';\n\t\tctx.textBaseline = 'top';\n\n\t\tfor (i = 0, j = data.length; i < j; i++) {\n\t\t\ty = mainPadding + i * step;\n\t\t\tlabel = this._trimLabel(segmentInfo, ctx, data[i].title);\n\n\t\t\tctx.fillStyle = this._settings.textColor;\n\t\t\tctx.fillText(label, mainPadding + segmentInfo.maxLabel - 4, y + 4);\n\t\t\tthis._rectangles.push({\n\t\t\t\tx1: mainPadding + segmentInfo.maxLabel - 4 - ctx.measureText(label).width,\n\t\t\t\ty1: y + 4,\n\t\t\t\tx2: mainPadding + segmentInfo.maxLabel - 4,\n\t\t\t\ty2: y + 20,\n\t\t\t\tlabel: data[i].title\n\t\t\t});\n\t\t\tif ((i & 1) === 0) {\n\t\t\t\tctx.fillStyle = settings.barBackground;\n\t\t\t\tctx.fillRect(mainPadding + segmentInfo.maxLabel, y, width, step);\n\t\t\t}\n\t\t}\n\n\t\tctx.textAlign = 'center';\n\n\t\tctx.strokeStyle = this._settings.lineColor;\n\t\tctx.fillStyle = '#000000';\n\n\t\thasDecimal = 0;\n\t\ti = 0;\n\t\tj = 0;\n\t\twhile (i <= width) {\n\t\t\tlabel = (j * segmentInfo.step).toString(10);\n\t\t\tk = label.indexOf('.');\n\t\t\tif (k !== -1) {\n\t\t\t\tk = label.length - k - 1;\n\t\t\t\tif (k > hasDecimal) {\n\t\t\t\t\thasDecimal = k;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = Math.floor(i + width / segmentInfo.steps);\n\t\t\tj++;\n\t\t}\n\n\t\ti = 0;\n\t\tj = 0;\n\t\twhile (i <= width) {\n\t\t\tx = mainPadding + segmentInfo.maxLabel + ~~i + 0.5;\n\t\t\ty = mainPadding;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y);\n\t\t\tctx.lineTo(x, y + height);\n\t\t\tctx.stroke();\n\n\t\t\tlabel = (j * segmentInfo.step).toString(10);\n\t\t\tif (hasDecimal && (label.indexOf('.') === -1)) {\n\t\t\t\tlabel += '.';\n\t\t\t\tfor (k = 0; k < hasDecimal; k++) {\n\t\t\t\t\tlabel += '0';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tctx.fillStyle = this._settings.textColor;\n\t\t\tctx.fillText(label, mainPadding + segmentInfo.maxLabel + i, mainPadding + height + 2);\n\n\t\t\ti = Math.floor(i + width / segmentInfo.steps);\n\t\t\tj++;\n\t\t}\n\n\t\tctx.textAlign = 'left';\n\n\t\tlabel = settings.mainLabel + ' x' + segmentInfo.factor;\n\n\t\ti = mainPadding + width / 2 - (ctx.measureText(label).width + settings.itemSize) / 2 + segmentInfo.maxLabel;\n\t\tj = mainPadding + height + 18;\n\n\t\tctx.fillStyle = this._settings.textColor;\n\t\tctx.fillText(label, i, j);\n\n\t\ti += ctx.measureText(label).width;\n\t\tctx.beginPath();\n\t\tctx.moveTo(i + 4, j + 7.5);\n\t\tctx.lineTo(i + settings.itemSize, j + 7.5);\n\t\tctx.stroke();\n\n\t\tctx.beginPath();\n\t\tctx.moveTo(i + settings.itemSize - 4, j + 3.5);\n\t\tctx.lineTo(i + settings.itemSize, j + 7.5);\n\t\tctx.lineTo(i + settings.itemSize - 4, j + 11.5);\n\t\tctx.stroke();\n\t}\n\n\tthis._renderHorizontalBars = function(segmentInfo, ctx, data) {\n\t\tvar settings = this._settings,\n\t\t\tvalueSpace = settings.valueSpace,\n\t\t\tmainPadding = settings.mainPadding,\n\t\t\twidth = this._currentWidth - mainPadding * 2 - segmentInfo.maxLabel,\n\t\t\theight = this._currentHeight - mainPadding * 2 - valueSpace,\n\t\t\tstep = height / data.length,\n\t\t\tbarWidth,\n\t\t\tbarHeight = step - settings.barPadding * 2,\n\t\t\tbarHeightSeg,\n\t\t\tbarX, barY,\n\t\t\titem,\n\t\t\tpoints,\n\t\t\ti, j, k, l;\n\n\t\tctx.globalAlpha = 0.9;\n\t\tfor (i = 0, j = data.length; i < j; i++) {\n\t\t\titem = data[i];\n\t\t\tpoints = item.points;\n\n\t\t\tl = points.length;\n\t\t\tbarHeightSeg = ~~(barHeight / l);\n\t\t\tfor (k = 0; k < l; k++) {\n\t\t\t\tbarWidth = ~~(item.points[k] / segmentInfo.max * width);\n\t\t\t\tbarX = segmentInfo.maxLabel + mainPadding;\n\t\t\t\tbarY = ~~mainPadding + i * step + settings.barPadding;\n\n\t\t\t\tctx.fillStyle = settings.dataColors[k % settings.dataColors.length];\n\t\t\t\tctx.fillRect(barX, barY + k * barHeightSeg, barWidth, barHeightSeg - 1);\n\t\t\t}\n\t\t}\n\t\tctx.globalAlpha = 1;\n\t};\n\n\tthis._renderHorizontalPoints = function(segmentInfo, ctx, data) {\n\t\tvar settings = this._settings,\n\t\t\trenderPoints = (settings.types.indexOf('points') !== -1),\n\t\t\trenderLines = (settings.types.indexOf('lines') !== -1),\n\t\t\trenderArea = (settings.types.indexOf('area') !== -1),\n\t\t\tvalueSpace = settings.valueSpace,\n\t\t\tmainPadding = settings.mainPadding,\n\t\t\twidth = this._currentWidth - mainPadding * 2 - segmentInfo.maxLabel,\n\t\t\theight = this._currentHeight - mainPadding * 2 - valueSpace,\n\t\t\tstep = height / data.length,\n\t\t\tpointHeight = step - settings.barPadding * 2,\n\t\t\tpointX, pointY,\n\t\t\tpoints,\n\t\t\tpoint,\n\t\t\tpointList = [],\n\t\t\thasLast,\n\t\t\titem,\n\t\t\ti, j, k, l;\n\n\t\tpointXLast = null;\n\n\t\tfor (i = 0, j = data.length; i < j; i++) {\n\t\t\titem = data[i];\n\t\t\tpoints = item.points;\n\n\t\t\thasLast = pointXLast !== null;\n\t\t\tif (pointXLast === null) {\n\t\t\t\tpointXLast = [];\n\t\t\t}\n\t\t\tpointY = ~~(mainPadding + i * step + settings.barPadding + pointHeight / 2);\n\t\t\tfor (k = 0, l = points.length; k < l; k++) {\n\t\t\t\tpointX = ~~(mainPadding + item.points[k] / segmentInfo.max * width + segmentInfo.maxLabel);\n\n\t\t\t\tif (!pointList[k]) {\n\t\t\t\t\tpointList[k] = [];\n\t\t\t\t}\n\t\t\t\tpointList[k].push({x: pointX, y: pointY});\n\n\t\t\t\tctx.strokeStyle = settings.dataColors[k % settings.dataColors.length];\n\t\t\t\tif (renderPoints) {\n\t\t\t\t\tctx.strokeRect(pointX - 4.5, pointY - 4.5, 10, 10);\n\t\t\t\t}\n\n\t\t\t\tif (hasLast && renderLines) {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(pointXLast[k], pointYLast);\n\t\t\t\t\tctx.lineTo(pointX, pointY);\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\n\t\t\t\tpointXLast[k] = pointX;\n\t\t\t}\n\t\t\tpointYLast = pointY;\n\t\t}\n\n\t\tif (renderArea) {\n\t\t\tctx.globalAlpha = 0.05;\n\t\t\tfor (i = 0, j = pointList.length; i < j; i++) {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(mainPadding + segmentInfo.maxLabel, pointList[i][0].y);\n\t\t\t\tfor (k = 0, l = pointList[i].length; k < l; k++) {\n\t\t\t\t\tpoint = pointList[i][k];\n\t\t\t\t\tctx.lineTo(point.x, point.y);\n\t\t\t\t}\n\t\t\t\tctx.lineTo(mainPadding + segmentInfo.maxLabel, pointList[i][l - 1].y);\n\t\t\t\tctx.closePath();\n\t\t\t\tctx.fillStyle = settings.dataColors[i % settings.dataColors.length];\n\t\t\t\tctx.fill();\n\t\t\t}\n\t\t\tctx.globalAlpha = 1;\n\t\t}\n\t};\n\n\tthis.setData = function(data) {\n\t\tvar el = this._el,\n\t\t\tctx = el.getContext('2d'),\n\t\t\tsettings = this._settings,\n\t\t\ttypes = settings.types,\n\t\t\taxisRenderMethod = function() {},\n\t\t\tbarsRenderMethod = function() {},\n\t\t\tpointsRenderMethod = function() {},\n\t\t\tsegmentInfo;\n\n\t\tswitch (settings.orientation) {\n\t\t\tcase 'horizontal':\n\t\t\t\tel.width = this._width;\n\t\t\t\tel.height = data.length * settings.itemSize + this._settings.valueSpace;\n\t\t\t\taxisRenderMethod = bind(this, this._renderVerticalAxis);\n\t\t\t\tbarsRenderMethod = bind(this, this._renderHorizontalBars);\n\t\t\t\tpointsRenderMethod = bind(this, this._renderHorizontalPoints);\n\t\t\t\tbreak;\n\n\t\t\tcase 'vertical':\n\t\t\t\tel.width = data.length * settings.itemSize + this._settings.valueSpace;\n\t\t\t\tel.height = this._height;\n\t\t\t\taxisRenderMethod = bind(this, this._renderHorizontalAxis);\n\t\t\t\tbarsRenderMethod = bind(this, this._renderVerticalBars);\n\t\t\t\tpointsRenderMethod = bind(this, this._renderVerticalPoints);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tctx.font = settings.font;\n\n\t\tthis._renderBackground(ctx);\n\n\t\tif (data.length) {\n\t\t\tsegmentInfo = this._calculateSegments(ctx, data);\n\n\t\t\taxisRenderMethod(segmentInfo, ctx, data);\n\n\t\t\tif ((types.indexOf('points') !== -1) || (types.indexOf('area') !== -1) || (types.indexOf('lines') !== -1)) {\n\t\t\t\tpointsRenderMethod(segmentInfo, ctx, data);\n\t\t\t}\n\t\t\tif (types.indexOf('bars') !== -1) {\n\t\t\t\tbarsRenderMethod(segmentInfo, ctx, data);\n\t\t\t}\n\t\t}\n\n\t\tthis._data = data;\n\t};\n\n\tthis.setSettings = function(settings) {\n\t\tsettings.mainLabel = settings.mainLabel || '';\n\t\tsettings.textColor = settings.textColor || '#000000';\n\t\tsettings.fillColor = (settings.fillColor === undefined) ? '#FFFFFF' : settings.fillColor;\n\t\tsettings.lineColor = settings.lineColor || '#000000';\n\t\tsettings.orientation = settings.oriantation || 'horizontal';\n\t\tsettings.types = settings.types || 'bars,lines,area,points';\n\t\tsettings.barPadding = settings.barPadding || 2;\n\t\tsettings.barBackground = settings.barBackground || '#F8F8F8';\n\t\tsettings.mainPadding = settings.mainPadding || 10;\n\t\tsettings.valueSpace = settings.valueSpace || 40;\n\t\tsettings.dataColors = settings.dataColors || ['#DD0000', '#00DD00', '#0000DD'];\n\t\tsettings.font = settings.font || '13px Verdana';\n\t\tsettings.maxLabelSize = settings.maxLabelSize || 200;\n\t\tsettings.itemSize = settings.itemSize || 50;\n\n\t\tthis._settings = settings;\n\t};\n\n\tthis.update = function() {\n\t\tthis._data && this.setData(this._data);\n\t};\n});\n");
jsio.setCachedSrc('../node_modules/squill/SelectBox.js',"jsio('import .Widget');\njsio('import squill.models.DataSource as DataSource');\n\njsio('from util.browser import $');\n\nvar SelectBox = exports = Class(Widget, function(supr) {\n\n\tthis._css = 'select';\n\n\tthis._def = {\n\t\ttag: 'label',\n\t\tstyle: {display: 'inline-block'},\n\t\tchildren: [{\n\t\t\tid: '_select',\n\t\t\ttag: 'select'\n\t\t}]\n\t};\n\n\tthis.init = function(opts) {\n\t\topts = merge(opts, {\n\t\t\trenderer: bind(this, 'defaultRenderer')\n\t\t});\n\n\t\tthis._items = {};\n\t\tif (opts.dataSource) { this.setDataSource(opts.dataSource); }\n\t\tsupr(this, 'init', arguments);\n\t}\n\n\tthis.buildWidget = function() {\n\t\tif (this._opts.name) {\n\t\t\tthis.setName(this._opts.name);\n\t\t}\n\n\t\tif (!this._dataSource) {\n\t\t\tthis.setDataSource(new DataSource());\n\t\t}\n\n\t\tif (this._opts.items) {\n\t\t\tvar uid = 1;\n\t\t\tvar items = this._opts.items.map(function (item) {\n\t\t\t\tif (typeof item != 'object') {\n\t\t\t\t\treturn {id: typeof item == 'string' ? item : uid++, value: item};\n\t\t\t\t} else {\n\t\t\t\t\tif (!item.id) {\n\t\t\t\t\t\titem.id =   'value' in item ? item.value :\n\t\t\t\t\t\t\t\t\t'title' in item ? item.title :\n\t\t\t\t\t\t\t\t\t(uid++);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn item;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis._dataSource.add(items);\n\t\t}\n\n\t\tif ('value' in this._opts) {\n\t\t\tthis.setValue(this._opts.value);\n\t\t}\n\n\t\tthis.initMouseEvents(this._el);\n\t\t$.onEvent(this._select, 'change', this, '_onSelect');\n\t}\n\n\tthis._onSelect = function() {\n\t\tvar item = this._dataSource.get(this.getValue());\n\t\tif (item) {\n\t\t\tthis.publish('change', item);\n\t\t}\n\t}\n\n\tthis.getDataSource = function () { return this._dataSource; }\n\n\tthis.setDataSource = function(dataSource) {\n\t\tif (this._dataSource) {\n\t\t\tthis._dataSource.unsubscribe('Update', this);\n\t\t\tthis._dataSource.unsubscribe('Remove', this);\n\t\t}\n\t\tthis._dataSource = dataSource;\n\t\tthis._dataSource.subscribe('Update', this, 'onUpdateItem');\n\t\tthis._dataSource.subscribe('Remove', this, 'onRemoveItem');\n\t\tthis._dataSource.forEach(function(item, key) {\n\t\t\tthis.onUpdateItem(key, item);\n\t\t}, this);\n\t}\n\n\tthis.defaultRenderer = function(item) {\n\t\tvar key = this._dataSource.getKey();\n\t\treturn item.displayName || item.label || item.title || item.text || item[key];\n\t}\n\n\tthis.onUpdateItem = function(id, item) {\n\t\tvar el = this._items[id];\n\t\tvar keyField = this._dataSource.getKey();\n\n\t\tif (typeof(item) === 'string') {\n\t\t\tvar o = {};\n\t\t\to[keyField] = item;\n\t\t\titem = o;\n\t\t}\n\n\t\tif (!el) {\n\t\t\tvar el = this._items[id] = $.create({tag: 'option'});\n\t\t\t$.insertBefore(this._select, el);\n\t\t}\n\n\t\tel.setAttribute('value', item[keyField]);\n\t\tvar renderer = this._opts.renderer;\n\t\tel.innerText = (typeof renderer === 'string' ? item[renderer] : renderer(item))\n\t\tel.value = item[keyField];\n\t}\n\n\tthis.onRemoveItem = function(id) {\n\t\tvar el = this._items[id];\n\t\tvar prevValue = this.getValue();\n\t\tif (el) {\n\t\t\t$.remove(el);\n\t\t\tdelete this._items[id];\n\t\t}\n\t\tvar newValue = this.getValue();\n\t\tif (newValue != prevValue) {\n\t\t\tthis._onSelect(); // the old value was removed, so select a new one\n\t\t}\n\t}\n\n\n\tthis.setName = function(name) { this._select.name = name; }\n\tthis.setValue = function(value) { this._select.value = value; }\n\n\tthis.getValue = function() { return this._select.value; }\n});\n");
jsio.setCachedSrc('devkit-view-inspector/debugger/DetailsWidget.js',"/* globals Class, bind, logger */\n\njsio('from util.browser import $');\njsio('import squill.Widget as Widget');\njsio('import .InputWidget');\n\nfunction noop(e) {\n  e.stopPropagation();\n  e.preventDefault();\n  return false;\n}\n\nvar PropRow = Class(Widget, function (supr) {\n  this.init = function (opts) {\n    var children = [];\n    this._def = {\n      className: 'propRow',\n      children: children\n    };\n\n    if (typeof opts.prop == 'string') { opts.prop = {title: opts.prop, id: opts.prop}; }\n\n    var props = opts.props || [opts.prop];\n    props.forEach(function (prop) {\n      children.push({className: 'propTitle', text: prop.title || prop.id}, {id: prop.id, type: InputWidget, prop: prop});\n    });\n\n    this._def.className += ' propCount' + props.length;\n\n    supr(this, 'init', arguments);\n\n    this.props = props;\n  };\n});\n\nexports = Class(Widget, function (supr) {\n  this._def = {\n    children: [\n      {id: '_header', children: [\n        {text: 'editing: ', tag: 'span'},\n        {id: '_editorType', tag: 'span', text: 'simulator', type: 'label'},\n        {id: '_closeBtn', type: 'button', children: [{className: 'glyphicon glyphicon-remove'}]}\n      ]},\n      {id: 'details', children: [\n        {id: 'viewDetails', type: 'label'}\n      ]},\n      {id: 'detailsScroller', children: [\n        {className: 'propRow propSection', text: 'position'},\n        {type: PropRow, props: [{title: 'x', id: 'relX'}, {title: 'y', 'id': 'relY'}]},\n        {type: PropRow, prop: {title: 'r', id: 'relR', increment: 0.01}},\n        {type: PropRow, props: [{title: 'width', id: 'relWidth'}, {title: 'height', id: 'relHeight'}]},\n        {type: PropRow, prop: {title: 'scale', id: 'relScale'}},\n\n        {className: 'propRow propSection', text: 'style'},\n        {type: PropRow, prop: {id: 'opacity', min: 0, max: 1, increment: 0.01}},\n        {type: PropRow, prop: 'zIndex'},\n        {type: PropRow, prop: {id: 'visible', type: 'boolean'}},\n        {type: PropRow, props: [{title: 'anchor x', id: 'anchorX'}, {title: 'y', id: 'anchorY'}]},\n        {type: PropRow, props: [{title: 'offset x', id: 'offsetX'}, {title: 'y', id: 'offsetY'}]},\n        {type: PropRow, prop: {id: 'clip', type: 'boolean'}},\n        {type: PropRow, prop: {id: 'inLayout', type: 'boolean'}},\n        {type: PropRow, prop: 'order'},\n        {type: PropRow, prop: 'flex'},\n        {type: PropRow, prop: 'layout'},\n\n        {id: 'boxProps', children: [\n          {className: 'propRow propSection', text: 'box layout'},\n          {type: PropRow, props: [{id: 'left'}, {id: 'right'}]},\n          {type: PropRow, props: [{id: 'top'}, {id: 'bottom'}]},\n\n          {type: PropRow, props: [{id: 'minWidth'}, {title: 'height', id: 'minHeight'}]},\n          {type: PropRow, props: [{id: 'maxWidth'}, {title: 'height', id: 'maxHeight'}]},\n          {type: PropRow, props: [{id: 'layoutWidth'}, {title: 'height', id: 'layoutHeight'}]},\n          {type: PropRow, props: [{id: 'centerX', type: 'boolean'}, {id: 'centerY', type: 'boolean'}]},\n\n        ]},\n\n        {id: 'linearProps', children: [\n          {className: 'propRow propSection', text: 'linear layout'},\n          {type: PropRow, prop: 'subviews'},\n          {type: PropRow, prop: 'direction'},\n          {type: PropRow, prop: 'justifyContent'},\n          {type: PropRow, prop: {id: 'padding', type: 'string'}},\n        ]},\n\n        {className: 'propRow propSection', text: 'absolute position'},\n        {type: PropRow, props: [{title: 'x', id: 'absX'}, {title: 'y', 'id': 'absY'}]},\n        {type: PropRow, prop: {title: 'r', id: 'absR', increment: 0.01}},\n        {type: PropRow, props: [{title: 'width', id: 'absWidth'}, {title: 'height', id: 'absHeight'}]},\n        {type: PropRow, prop: {title: 'scale', id: 'absScale'}},\n\n        {tag: 'div', id: 'dropArea', text: 'Drop Here \\u2193', children: [\n          {tag: 'button', id: 'saveImg', text: \"save image\"}\n        ]}\n      ]}\n    ]\n  };\n\n  this.buildWidget = function () {\n\n    this._children.forEach(function (child) {\n      if (child instanceof PropRow) {\n        child.props.forEach(function (prop) {\n          this[prop.id] = child[prop.id];\n          this[prop.id].subscribe('ValueChange', this, '_onValueChange', prop.id);\n        }, this);\n      }\n    }, this);\n  };\n\n  this.delegate = function (key) {\n    if (key == '_closeBtn') {\n      this._inspector.close();\n    }\n  };\n\n  this._onValueChange = function (key) {\n    if (this._viewUID) {\n      var value = this[key].getValue();\n      this._inspector.setViewProp(this._viewUID, key, value);\n    }\n  };\n\n  this.setInspector = function (inspector) {\n    this._inspector = inspector;\n  };\n\n  this.imageView = function (uid, node) {\n    // get the view properties\n    this._inspector\n      .getViewProps({uid: uid})\n      .bind(this)\n      .then(function (res) {\n        // show the drop area\n        this.dropArea.style.display = res.isImageView ? \"block\" : \"none\";\n\n        // if already data set, show save button\n        if (!node.currentImage || !node.currentImage.data) {\n          this.saveImg.style.display = \"none\";\n        } else {\n          this.saveImg.style.display = \"block\";\n        }\n\n        if (res.isImageView) {\n          // create the object if not set\n          if (!node.currentImage) {\n            node.currentImage = {};\n          }\n\n          // update the uid and path\n          node.currentImage.uid = uid;\n          node.currentImage.path = res.imagePath;\n        } else {\n          // delete the property\n          delete node.currentImage;\n        }\n      }, function (e) {\n        logger.warn(e);\n      });\n  };\n\n  this.showView = function (uid) {\n    this._viewUID = uid;\n\n    if (uid) {\n      this._inspector\n        .getViewProps({uid: uid})\n        .bind(this)\n        .then(function (res) {\n          this.viewDetails.setText(res.description);\n          if (res.layout == 'linear') {\n            $.show(this.linearProps);\n          } else {\n            $.hide(this.linearProps);\n          }\n\n          for (var key in res) {\n            if (this[key] && this[key].setValue) {\n              this[key].setValue(res[key]);\n            }\n          }\n        }, function (e) {\n          logger.warn(e);\n        });\n    }\n  };\n\n  this.hideProps = function () {\n    for (var i = 0, p; p = arguments[i]; ++i) {\n      $.hide(this['_row' + p]);\n    }\n  };\n\n  this.showProps = function () {\n    for (var i = 0, p; p = arguments[i]; ++i) {\n      $.show(this['_row' + p]);\n    }\n  };\n\n  this.init = function() {\n    supr(this, \"init\", arguments);\n\n    this.dropArea.addEventListener(\"dragenter\", noop, false);\n    this.dropArea.addEventListener(\"dragexit\", bind(this, function(e) {\n      this.dropArea.className = \"\";\n      return noop(e);\n    }), false);\n\n    // modify the styles\n    this.dropArea.addEventListener(\"dragover\", bind(this, function(e) {\n      this.dropArea.className = \"over\";\n      return noop(e);\n    }), false);\n\n    this.dropArea.addEventListener(\"drop\", bind(this, this.dropImage), false);\n\n    this.saveImg.addEventListener(\"click\", bind(this, this.saveImage), false);\n  };\n\n  this.dropImage = function(e) {\n    var files = e.dataTransfer.files;\n    var count = files.length;\n    var file  = files[0];\n\n    if (count < 1) {\n      return console.log(\"No image found\");\n    }\n\n    var reader = new FileReader();\n    reader.onload = bind(this, function(evt) {\n      // set the preview\n      if (!currentNode || !currentNode.currentImage) return;\n\n      this._inspector.setImage(currentNode.currentImage.uid, evt.target.result);\n      currentNode.currentImage.data = evt.target.result;\n    });\n\n    reader.readAsDataURL(file);\n\n    this.saveImg.style.display = \"block\";\n    return noop(e);\n  }\n;\n  this.saveImage = function() {\n    var img = currentNode && currentNode.currentImage;\n    if (!img) return;\n\n    var path = encodeURIComponent(img.path.substr(10));\n\n    util.ajax.post({\n      url: \"/art/replaceImage/\" + this._opts.appID + \"/\" + path,\n      data: {data: img.data},\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }, bind(this, function(err, resp) {\n      if (!err) {\n        delete currentNode.currentImage.data;\n        this.saveImg.style.display = \"none\";\n      }\n    }));\n  };\n});\n");
jsio.setCachedSrc('devkit-view-inspector/debugger/InputWidget.js',"jsio('import squill.Widget as Widget');\njsio('from util.browser import $');\n\nexports = Class(Widget, function (supr) {\n  this._def = {\n    children: [\n      {type: 'text', id: '_value'}\n    ]\n  };\n\n  this.buildWidget = function () {\n    this._value.subscribe('ValueChange', this, 'publish', 'ValueChange');\n    this._value.subscribe('Blur', this, '_onBlur');\n    this._value.subscribe('Focus', this, '_onFocus');\n\n    this._value.subscribe('Down', this, '_onMouseDown');\n    this._value.subscribe('KeyDown', this, '_onKeyDown');\n\n    var inputEl = this._value.getInputElement();\n\n    var prop = this._opts.prop || {};\n\n    if (prop.readOnly) {\n      this._isReadyOnly = true;\n      inputEl.style.cursor = 'default';\n    }\n\n    switch (prop.type) {\n      case 'boolean':\n        this._type = 'boolean';\n        inputEl.style.cursor = 'pointer';\n        break;\n      case 'string':\n        this._type = 'string';\n        break;\n      case 'number':\n      default:\n        this._type = 'number';\n        if ('min' in prop) {\n          this._min = prop.min;\n        }\n\n        if ('max' in prop) {\n          this._max = prop.max;\n        }\n\n        this._increment = prop.increment;\n        break;\n    }\n\n    this.initMouseEvents();\n  };\n\n  this._onMouseDown = function (e) {\n    if (this._isReadyOnly) {\n      $.stopEvent(e);\n      return;\n    }\n\n    if (this._type == 'boolean') {\n      this._setValue(!this.getValue());\n      $.stopEvent(e);\n    }\n  };\n\n  this._onFocus = function () {\n    switch (this._type) {\n      case 'boolean':\n        this._value.getElement().blur();\n        break;\n    }\n  };\n\n  this._onBlur = function () {\n    this.setValue(this.getValue());\n  };\n\n  // set and publish\n  this._setValue = function (value) {\n    this.setValue(value);\n    this.publish('ValueChange', this._value.getValue());\n  };\n\n  this.setValue = function (value) {\n    this._lastValue = value;\n\n    switch (this._type) {\n      case 'number':\n        if (value == undefined) { value = '-'; }\n        this._value.setValue(value);\n        break;\n      case 'boolean':\n        this._value.setValue(value ? 'true' : 'false');\n        break;\n      case 'string':\n      default:\n        this._value.setValue('' + value);\n        break;\n    }\n  };\n\n\n  // ugly way to do fixed-point sum\n  // e.g. 0.06 - 0.01 should be 0.05 (not 0.049999999999999996)\n  function add(value, incr) {\n    var sum = value + incr;\n    var str = incr.toString().split(\".\");\n    if (str.length > 1) {\n      var frac = str[1].length;\n      sum = +sum.toFixed(frac);\n    }\n\n    return sum;\n  }\n\n  this._onKeyDown = function (evt) {\n    switch (evt.keyCode) {\n      case 37: // left\n        break;\n      case 38: // up\n        this._setValue(add(this.getValue(), (this._increment || 1)));\n        $.stopEvent(evt);\n        break;\n      case 39: // right\n        break;\n      case 40: // down\n        this._setValue(add(this.getValue(), -(this._increment || 1)));\n        $.stopEvent(evt);\n        break;\n    }\n  };\n\n  this.getValue = function () {\n    switch (this._type) {\n      case 'number':\n        var val = this._value.getValue();\n        if (val == '-') { return undefined; }\n\n        val = parseFloat(val);\n        if (('_max' in this) && val > this._max) {\n          val = this._max;\n        }\n\n        if (('_min' in this) && val < this._min) {\n          val = this._min;\n        }\n\n        if (isNaN(val)) {\n          return this._lastValue;\n        } else {\n          return val;\n        }\n      case 'boolean':\n        return this._value.getValue() == 'true';\n      default:\n      case 'string':\n        return this._value.getValue();\n    }\n  };\n});\n");
jsio.setCachedSrc('devkit-view-inspector/debugger/ViewNode.js',"jsio('from util.browser import $');\n\njsio('import squill.Widget as Widget');\n\n/* globals exports, Class, logger */\n\nvar ViewNode = exports = Class(Widget, function(supr) {\n\n  this._def = {\n    className: 'viewNode',\n    children: [\n      {id: '_label', className: 'label', children: [\n        {id: '_toggleBtn', className: 'toggleBtn'},\n        {id: '_labelText', tag: 'span', type: 'label'}\n      ]},\n      {id: '_childNodes', className: 'children'}\n    ]\n  };\n\n  this.init = function (opts) {\n    this._inspector = opts.inspector;\n\n    this._viewUID = opts.viewUID;\n    this._indent = opts.indent || 0;\n    this._subs = [];\n    this._nodes = [];\n    this._getChildren = opts.getChildren === undefined ? true : !!opts.getChildren;\n\n    supr(this, 'init', arguments);\n  };\n\n  this.getViewUID = function() { return this._viewUID; };\n\n  this.buildWidget = function(el) {\n    var uid = this._viewUID;\n\n    $.style(this._label, {paddingLeft: 10 + this._indent * 15 + 'px'});\n\n    this._isToggled = false;\n\n    this.refresh();\n\n    this._subs.push(\n      $.onEvent(this._label, 'click', this, 'toggle'),\n      $.onEvent(this._label, 'click', this, 'select'),\n      $.onEvent(this._label, 'mouseover', this._inspector, 'highlightView', uid),\n      $.onEvent(this._label, 'mouseout', this._inspector, 'highlightView', null)\n    );\n\n    this._inspector._addNode(this._viewUID, this);\n  };\n\n  this.select = function () {\n    this._inspector.selectView(this._viewUID);\n    this._inspector.highlightView(this._viewUID);\n  };\n\n  this.highlight = function (isHighlighted, atTarget) {\n    var state = '' + isHighlighted + atTarget;\n    if (this._state == state) { return; }\n    this._state = state;\n\n    if (isHighlighted) {\n      if (atTarget === false) {\n        $.addClass(this._el, 'highlightParent');\n        $.removeClass(this._el, 'highlight');\n      } else {\n        $.addClass(this._el, 'highlight');\n        $.removeClass(this._el, 'highlightParent');\n      }\n    } else {\n      $.removeClass(this._el, 'highlight');\n      $.removeClass(this._el, 'highlightParent');\n    }\n  };\n\n  this.show = function() {\n    this._inspector.highlightView(this._viewUID);\n  };\n\n  this.destroy = function() {\n    for (var i = 0, unsubscribe; unsubscribe = this._subs[i]; ++i) {\n      unsubscribe();\n    }\n\n    for (var i = 0, node; node = this._nodes[i]; ++i) {\n      node.destroy();\n    }\n\n    $.remove(this._el);\n\n    this._inspector._removeNode(this._viewUID);\n    this._viewUID = null;\n  };\n\n  this.refresh = function() {\n    if (!this._inspector) return;\n\n    this._inspector\n      .requestView(this._viewUID)\n      .bind(this)\n      .then(function (details) {\n        this._details = details;\n\n        // update the view style of the node\n        if (details.tag != this._tag) {\n          this._tag = details.tag;\n          $.setText(this._labelText, details.tag);\n        }\n\n        this._hasChildren = details.subviewIds && (details.subviewIds.length > 0);\n        this.updateToggleText();\n\n        // if toggled, refresh the children\n        if (this._isToggled) {\n          // make a copy of the nodes array\n          var i, n, uid;\n          var uids = {};\n          for (i = 0; n = this._nodes[i]; ++i) {\n            uids[n.getViewUID()] = n;\n          }\n\n          // refresh the list of nodes, reusing existing nodes\n          this._nodes = [];\n          for (i = 0, uid; uid = details.subviewIds[i]; ++i) {\n            if (uid in uids) {\n              // reuse and reorder\n              this._nodes[i] = uids[uid];\n              delete uids[uid];\n              this._nodes[i].refresh();\n              if (i > 0 && this._nodes[i]._el.previousSibling != this._nodes[i - 1]._el) {\n                this._childNodes.insertBefore(this._nodes[i]._el, this._nodes[i - 1]._el.nextSibling);\n              }\n            } else {\n              // or create a new one\n              this._nodes[i] = new ViewNode({\n                inspector: this._inspector,\n                viewUID: uid,\n                parent: this._childNodes,\n                indent: this._indent + 1\n              });\n            }\n          }\n\n          // destroy any nodes that weren't reused\n          for (uid in uids) {\n            uids[uid].destroy();\n          }\n\n          // trace is displayed asynchronously\n          this._inspector.updateTrace();\n        }\n      }, function (err) {\n        logger.warn(err);\n      });\n  };\n\n  this.setSelected = function (isSelected) {\n    if (isSelected) {\n      $.addClass(this._el, 'selected');\n    } else {\n      $.removeClass(this._el, 'selected');\n    }\n  };\n\n  this.updateToggleText = function () {\n    var text = !this._hasChildren ? '\\u25CF'\n        : this._isToggled ? '\\u25BC'\n        : '\\u25B6';\n\n    if (text != this._toggleText) {\n      $.setText(this._toggleBtn, text);\n      this._toggleText = text;\n    }\n  };\n\n  this.isToggled = function() { return this._isToggled; };\n\n  this.toggle = function() {\n    this._isToggled = !this._isToggled;\n    this.updateToggleText();\n    $.style(this._childNodes, {display: this._isToggled ? 'block' : 'none'});\n  };\n});\n\n");
jsio.setCachedSrc('devkit-view-inspector/debugger/BatchGetView.js',"// devkit's bluebird Promise\nvar Promise = devkit.Promise;\n\n// batches get view requests:\n//  - only sends requests once per tick\n//  - dedups requests\n//  - enforces only one simultaneous request\nmodule.exports = Class(function () {\n  this.init = function (requestFunc) {\n    this._inflight = false;\n    this._uids = [];\n    this._pending = {};\n    this._requestFunc = requestFunc;\n  };\n\n  // queue up a request for a given uid\n  this.request = function (uid) {\n    if (!(uid in this._pending)) {\n      this._uids.push(uid);\n      var pending = this._pending[uid] = {};\n      pending.promise = new Promise(function (resolve, reject) {\n        pending.resolve = resolve;\n        pending.reject = reject;\n      });\n    }\n\n    return this._pending[uid].promise;\n  };\n\n  // dispatch pending requests if not in flight\n  this.dispatch = function () {\n    if (this._uids.length && !this._inflight) {\n      var uids = this._uids;\n      this._inflight = true;\n      this._uids = [];\n\n      this._requestFunc({uids: uids})\n        .bind(this)\n        .timeout(10000)\n        .then(function (res) {\n          uids.forEach(function (uid) {\n            var pending = this._pending[uid];\n            delete this._pending[uid];\n            if (uid in res) {\n              pending.resolve(res[uid]);\n            } else {\n              pending.reject(res[uid]);\n            }\n          }, this);\n        })\n        .finally(function () {\n          this._inflight = false;\n        });\n    }\n  };\n});\n");;jsio("import src.devkit-view-inspector.debugger")})(jsio.clone());